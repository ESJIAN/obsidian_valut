## 1. USB简介
    

USB（Universal Serial Bus）通用串行总线是由Compaq、Digital Equipment、Intel、Microsoft、IBM、NEC及Northern  Telecom等7家公司联合开发的一种流行的外设接口标准。

![](https://i-blog.csdnimg.cn/blog_migrate/0e69c02aec73cfe556953c4b2848a98a.png)

——1994年开始研究，

——1996年  USB 1.0 速度只有1.5Mb/s

——1998年  USB 1.1版本

传输速率（两种模式）：低速（Low Speed）1.5Mbps

                                        全速(Full Speed)12Mbps

——2000年4月  USB 2.0版本

USB 2.0兼容所有USB 1.0外部设备及电缆线等，传输速率达480Mbps（高速High Speed 系列）。

——2008年11月  USB 3.0版本　

最大传输速率高达5.0Gb/s，也就是625MB/s ——Super Speed

引入了新的电源管理机制，支持待机、休眠和暂停等状态。

---

## 2. USB的特性
    
 ### 2.1 USB的性能特点
    

Ø  **传输速度快**

Ø　**连接简单快捷** 

**可以****热插拔，**

Ø　**通用连接器**

![](https://i-blog.csdnimg.cn/blog_migrate/6603509f1328789e848f6f24fa53f489.png)

A型连接头用于固定的外围设备；B型连接头用于经常插拔的设备。 

Ø　**无须外接电源 数据线供电**

Ø  **扩充外设能力强**

Ø  **不需要系统资源**

USB设备不占用内存或I/O地址空间，而且也占用IRQ和DMA通道，所有事务处理都是由USB主机管理。

Ø  **错误检测和恢复**

USB事务处理包括错误保护机制，确保数据无错误发送。在发生错误时，事务处理可以重来。

### 2.2、USB的电气特性
    

**（1）信号线**

![](https://i-blog.csdnimg.cn/blog_migrate/e047d0be7748d10cbb85d3f97232e9f1.png)

|   |   |   |
|---|---|---|
|**连接序号**|**信号名称**|**典型连接线**|
|1|VBUS （USB电源）|红|
|2|D+（正差分信号）|白|
|3|D-（负差分信号)|绿|
|4|GND (USB地)|黑|
|外层|屏蔽层|—|

**（2）全速/低速USB总线设备连接方法**

**全速设备：**D+上接1.5k上拉电阻；

**低速设备：** D-上接1.5k上拉电阻；

![](https://i-blog.csdnimg.cn/blog_migrate/29316972c4c2adb89fd92ab896d589ff.jpeg)

                                                                  USB全速（高速）设备硬件接线图 

![](https://i-blog.csdnimg.cn/blog_migrate/80df4c3694453c7b61a83b1ef2f887f6.jpeg)

                                                                             USB低速设备硬件接线图

**（3）电气特性**

**收发器：**对地电源电压为4.75~5.25V，设备吸入的最大电流值为500mA ，D+、 D-上不加电压。

**USB****设备：**高速在D+上加3.0~3.6V电压, 低速反之。

**D+、D-线电气特性：**

    无驱动：高速VD+ ＞ 2.7V,  VD-＜0.8V, 低速反之；

    有驱动：高速VD+ ＞ 2.0V,  VD-＜2.0V, 低速反之。

**D+、D-线信号特性：**

    **高电平：**VD+ － VD-＞200mV，VD+ ＞2.0V ；

    **低电平：**VD- － VD+ ＞200mV，VD- ＞2.0V 。

**D+、D-线数据特性：NRZI（不归零反向码）**

    逻辑0：D+、D-线上电平高、低间跳变；

    逻辑1：D+、D-线上电平不变。

---

 ## 3.  USB总线系统中的设备
    

可以分为三个类型：

–**USB****主机（** **USB****主控制器****/****根集线器****(****USB Host****)** **）：**只能有一个，管理USB系统，每秒产生一帧数据；发送配置请求对USB设备进行配置操作，对总线上的错误进行管理和恢复。

–**USB** **集线器（****USB HUB****）：类似于网络集线器，**完成USB设备的添加（扩展）、删除和电源管理等。

–**USB****总线设备（****USB****功能外设** **USB function****）。**

![](https://i-blog.csdnimg.cn/blog_migrate/0280a0c9854063cd20bdbc4098b001c9.png)

---

 ##  4. USB2.0 传输协议
    

![](https://i-blog.csdnimg.cn/blog_migrate/cefd9c112547aabffef9b19a9493de12.png)

上面是**UART**协议一个8位数据传输的帧格式。

![](https://i-blog.csdnimg.cn/blog_migrate/6f7b06724dd4bb170b002c4139f4e8d6.png)

上面是**SPI**协议一个8位数据传输的时序。片选拉低，对应外设被选中，在相应时钟沿进行数据采样，片选拉高停止传输。

基本可以看出，要实现串口通信，想把数据一个接一个的传出去或收回来，至少传输数据前给个**开始信号**，传输结束后给个**停止信号**。

USB同样如此，以下是USB通信协议的几个重要概念：

我们定义这样几个状态：假设D+,D-分别表示usb信号线的电平信号。那么对于usb full speed function(high speed ,low speed是不同的),我们定义差分数据线上可能出现的四个状态：

Data J state:D+=1，D-=0；

Data K state:D+=0，D-=1；

SE0：D+=D-=0;

SE1：D+=D-=1;

---

- ###  4.1 **包（package）是什么？**
    

数字串构成域，域再构成包，包是USB系统中信息传输的基本单元，所有数据都是经过打包后在总线上传输的。

  USB包由五部分组成，即同步字段（[SYNC](https://so.csdn.net/so/search?q=SYNC&spm=1001.2101.3001.7020)）、包标识符字段（PID）、数据字段、循环冗余校验字段（CRC）和包结尾字段（EOP），包的基本格式如下：

|   |   |   |   |   |
|---|---|---|---|---|
|**SYNC**（8或32 bits）****|**PID**（8 bits）****|**DATA**（0-1023bytes）****|**CRC**(5或6bits )****|**EOP**（2 bit）****|

域（字段）由若干位组成(多少位由具体的域决定)，域可分为七个类型：

- #### **4.1.1 同步域(SYNC)**
    

由8位/32位组成，作为每个数据包的前导，用来产生同步作用，使USB设备与总线的包传输率同步，它的数值固定为000000001。

- 作用：① 通知USB串行接口引擎数据要开始传输；② 同步主机和设备之间的时钟。
- 格式：Full/low-speed为8位，high-speed为32位。① 全速/低速设备的同步域为00000001；② 高速设备的同步域为31个0，后面跟1个1；注意：这是对发送端的要求，接收端在解码时，0的个数可以少于这个数。

- #### **4.1.2 标识符字段(PID)**
    
- 包标识符PID是用来标识一个包的类型。
- PID共有8位，目前USB协议仅使用4位(PID0~PID3)，另外4位(PID4~PID7)是PID0~PID3的取反，用来校验PID。
- 传输的顺序为PID0,PID1,PID2,PID3,...,PID7。

|   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|
|**PID0**|**PID1**|**PID2**|**PID3**|**~PID0**|**~PID1**|**~PID2**|**~PID3**|

 包的类型包括**令牌包**(token packet, PID1~0为01)、**数据包**(data packet, PID1~0为11)、**握手包**(handshake packet, PID1~0为10)、**特殊包**(special packet, PID1~0为00)：

|   |   |   |   |
|---|---|---|---|
|**PID类型**|**PID名**|**PID[3:0]**|**说明**|
|**令牌类**|OUT|0001B|通知设备将要输出数据|
|IN|1001B|通知设备将要输入数据|
|SOF|0101B|通知设备这是一个帧起始包|
|SETUP|1101B|通知设备将要开始一个控制传输|
|**数据类**|DATA0|0011B|不同类的数据包|
|DATA1|1011B|
|DATA2*|0111B|
|MDATA*|1111B|
|**握手类**|ACK|0010B|确认|
|NACK|1010B|不确认|
|STALL|1110B|挂起|
|NYET*|0110B|未准备好|
|**特殊类**|PRE|1100B|前导（这是一个令牌包）|
|ERR*|1100B|错误（这是一个握手包）|
|SPLIT*|1000B|分裂事务（这是一个令牌包）|
|PING*|0100B|PING测试（这是一个令牌包）|
|-|0000B|保留，未使用|

- 4.1.2.1  令牌包
    

**（1）OUT、IN、SETUP令牌包格式：**

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**同步域**|**8位标识符PID**|**7位地址**|**4位端点号**|**5位CRC5校验**|**EOP**|

例如： 

![](https://i-blog.csdnimg.cn/blog_migrate/417edfcfb3bece1d29e950cff8dc9aa3.png)

**（2）SOF令牌包格式：**

在每帧（或微帧）开始时发送，以广播的形式发送，所有USB全速设备和高速设备都可以接收到SOF包。  

    1) 对于full-speed总线，每隔1.00 ms ±0.0005 ms发送一次；  
    2) 对于high-speed总线，每隔125 μs ±0.0625 μs发送一次；

|   |   |   |   |   |
|---|---|---|---|---|
|**同步域**|**8位标识符PID**|**11位帧号**|**5位CRC5校验**|**EOP**|

例如：

![](https://i-blog.csdnimg.cn/blog_migrate/2b0ac7d7811433ae32355d053e6e775a.png)

- 4.1.2.2 数据包
    
- 用来携带主机与设备之间要传递的信息，其内容和长度根据PID、传输类型的不同而各不相同，有四种类类型的数据包：DATA0, DATA1, DATA2,and MDATA。

**数据包格式：**

|   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|
|**同步域**|**8位标识符PID**|**字节0**|**字节1**|**…**|**字节n**|**16位CRC16校验**|**EOP**|

例如：

![](https://i-blog.csdnimg.cn/blog_migrate/880eb88621470f19f3f275d0465eee07.png)

- 4.1.2.3 握手包
    
- ACK：正确接收数据，并且有足够的空间容纳数据。主机和设备都可以使用ACK来确认，而NAK、STALL、NYET只有设备才能够返回，主机不能使用这些握手包。
- NAK：① 没有数据需要返回；② 数据接收正确，但是没有足够的空间容纳数据。
- STALL：设备无法执行这个请求或者设备已挂起。设备返回STALL，需要主机干预才能解除这种STALL状态。
- NYET：只在USB2.0高速设备输出设备中使用，表示设备本次数据成功接收，但是没有足够的空间来接收下一次的数据。主机在下一次输出数据前，将使用PING令牌包来探测设备是否有足够的空间接收数据，以免浪费不必要的带宽和时间。

握手包格式：

|   |   |   |
|---|---|---|
|**同步域**|**8位标识符PID**|**EOP**|

例如： 

![](https://i-blog.csdnimg.cn/blog_migrate/45852dfb068ec715a8bbda8fa6d85d93.png)

- 4.1.2.4 特殊包不介绍 
    

- #### 4.1.3  数据字段(DATA)
    

在USB包中，数据字段可以包含设备地址、端点号、帧序列号以及数据等内容。它仅存于DATA数据包中，根据不同的传输类型，拥有不同的字节大小，从0到1023字节（同步传输）。在总线传输中，总是先传输字节的最低位，最后传输字节的最高位。

（1）ADDR设备地址数据域：

ADDR数据域由7位组成，可用来寻址多达127个外围设备。

（2）ENDP端点数据域：

ENDP数据域由4位组成，通过这4个位最多可寻址出32个端点。这个ENDP数据域仅用在IN、OUT与SETUP令牌信息包中。对于慢速设备可支持端点0以及端点1作为中断传输模式，而全速设备则可以拥有16个输入端点（IN）与16个输出端点（OUT）共32个端点。

（3）Frame Number：

当USB令牌包的PID为SOF时，其数据字段必须为11位的帧序列号。帧序列号由主机产生，且每个数据帧自动加一，最大数值为0x7FF。当帧序列号达到最大数时将自动从0开始循环。

- #### 4.1.4  循环冗余校验字段(CRC)
    

根据不同的信息包类型，CRC数据域由不同数目的位所组成。其中重要的数据信息包采用CRC16的数据域（16位），而其余的信息包类型则采用CRC5的数据域（5位）。

- #### 4.1.5 包结尾字段
    

全速/高速模式的EOP是一个约为2个数据宽度的SE0，高速模式的EOP是通过故意的位填充错误实现的。单端0(SE0)：D+和D-同时保持低电平。单端0的用处：① 包结束；② 复位信号（USB集线器对USB设备的复位操作，就是将总线设置为SE0约10ms）。

Q: 如何一个位填充错误是EOP还是传输错误？A: 通过CRC校验，即如果CRC正确，则说明这个位填充是EOP；否则说明传输错误。

---

- ### **4.2 事务（transaction）是什么？**
    

在USB上数据信息的一次接收或发送的处理过程称为事务处理（Transaction）即：The delivery of service to an endpoint。 一个**transaction**由一个到几个packet组成，具体由哪些packet组成，它取决于具体的事务。

**Transaction**可以分成**IN**、**OUT**和**SETUP**三大事务，如下： 

Setup transaction：主机用来向设备发送控制命令 ；  
                       Data IN transaction：主机用来从设备读取数据 ；  
                                   Data OUT transaction：主机用来向设备发送数据  ；

**Transaction**可能由如下包组成：

       • 一个token packet

       • 可选的data pcket

       • 可选的handshake packet

       • 可选的special packet

- #### 4.2.1 输入（IN）事务处理
    

     输入事务处理：表示USB主机从总线上的某个USB设备接收一个数据包的过程。

        •【正常】的输入事务处理

![](https://i-blog.csdnimg.cn/blog_migrate/3af6ca5addf70ec472fe06fde8e19553.png)

       •【设备忙】时的输入事务处理    

![](https://i-blog.csdnimg.cn/blog_migrate/c027dbccb77dd4ff4d787f3197b2020a.png)

  
     •【设备出错】时的输入事务处理

![](https://i-blog.csdnimg.cn/blog_migrate/919d695fcd77228872beb895326c3c13.png)

#### 4.2.2. 输出（OUT）事务处理

        输出事务处理：表示USB主机把一个数据包输出到总线上的某个USB设备接收的过程。

    •【正常】的输出事务处理

![](https://i-blog.csdnimg.cn/blog_migrate/08dce0945b79a32c13d35cc8f87cf1c6.png)

    •【设备忙时】的输出事务处理

![](https://i-blog.csdnimg.cn/blog_migrate/218ac1e801f04f413079e90a5fb34af3.png)

    •【设备出错】的输出事务处理

![](https://i-blog.csdnimg.cn/blog_migrate/22e4553c94c839d0e159aef210be74fc.png)

#### 4.2.3 设置（SETUP）事务处理  

   •【正常】的设置事务处理

![](https://i-blog.csdnimg.cn/blog_migrate/8f5e5e3d194490749182e20dac47b2f8.png)

   
   •【设备忙时】的设置事务处理

![](https://i-blog.csdnimg.cn/blog_migrate/8dddd2d34fcc998b5f0f50ac821e2a5f.png)

  
   •【设备出错】的设置事务处理

![](https://i-blog.csdnimg.cn/blog_migrate/6eb9c120b255eeb4818dc8a1b838028b.png)

---

 **4.3 什么是传输？**

  在USB的传输中，定义了4种传输类型：

       • 控制传输 (Control Transfer)

       • 中断传输 (Interrupt Transfer)

       • 批量传输 (Bulk Transfer)

       • 同步传输 (Isochronous)

#### 4.3.1 控制传输 (Control Transfer)

      控制传输由2～3个阶段组成：

      1) 建立阶段(Setup)

      2) 数据阶段（无数据控制没有此阶段）(DATA)

      3) 状态阶段(Status)

     •每个阶段都由一次或多次（数据阶段）事务传输组成（Transaction）。

      控制数据由USB系统软件用于配置设备(在枚举时)，其它的驱动软件可以选择使用control transfer实现具体的功能，数据传输是不可丢失的。

**4.3.1.1 建立阶段**

     主机从USB设备获取配置信息，并设置设备的配置值。建立阶段的数据交换包含了SETUP令牌封包、紧随其后的DATA0数据封包以及ACK握手封包。它的作用是执行一个设置（概念含糊）的数据交换，并定义此控制传输的内容(即：在Data Stage中IN或OUT的data包个数，及发送方向，在Setup Stage已经被设定)。

![](https://i-blog.csdnimg.cn/blog_migrate/359b73edbf3bb160cb8a5b8eb628c95b.png)

**4.3.1.2 数据阶段**

     根据数据阶段的数据传输的方向，控制传输又可分为3种类型：

     1) 控制读取（读取USB描述符）

     2) 控制写入（配置USB设备）

     3) 无数据控制

     数据传输阶段：用来传输主机与设备之间的数据。

     **• 控制读取**

     是将数据从设备读到主机上，读取的数据USB设备描述符。该过程如下图的【Control Read】所示。对每一个数据信息包而言，首先，主机会发送一个IN令牌信息包，表示要读数据进来。然后，设备将数据通过DATA1/DATA0数据信息包回传给主机。最后，主机将以下列的方式加以响应：当数据已经正确接收时，主机送出ACK令牌信息包；当主机正在忙碌时，发出NAK握手信息包；当发生了错误时，主机发出STALL握手信息包。

     **• 控制写入**

       是将数据从主机传到设备上，所传的数据即为对USB设备的配置信息，该过程如下的图【Control Wirte】所示。对每一个数据信息包而言，主机将会送出一个OUT令牌信息包，表示数据要送出去。紧接着，主机将数据通过DATA1/DATA0数据信息包传递至设备。最后，设备将以下列方式加以响应：当数据已经正确接收时，设备送出ACK令牌信息包；当设备正在忙碌时，设备发出NAK握手信息包；当发生了错误时，设备发出STALL握手信息包。

![](https://i-blog.csdnimg.cn/blog_migrate/b9b008b7296590f989a39f8ddf65987e.png)

**4.3.1.3 状态阶段**

       状态阶段：用来表示整个传输的过程已完全结束。  
       状态阶段传输的方向必须与数据阶段的方向相反，即原来是IN令牌封包，这个阶段应为OUT令牌封包；反之，原来是OUT令牌封包，这个阶段应为IN令牌封包。

       对于【控制读取】而言，主机会送出OUT令牌封包，其后再跟着0长度的DATA1封包。而此时，设备也会做出相对应的动作，送ACK握手封包、NAK握手封包或STALL握手封包。

      相对地对于【控制写入】传输，主机会送出IN令牌封包，然后设备送出表示完成状态阶段的0长度的DATA1封包，主机再做出相对应的动作：送ACK握手封包、NAK握手封包或STALL握手封包。  
 

####  4.3.2 批量传输 (Bulk Transfer)

      •用于传输大量数据，要求传输不能出错，但对时间没有要求，适用于打印机、存储设备等。

      •批量传输是可靠的传输，需要握手包来表明传输的结果。若数据量比较大，将采用多次批量事务传输来完成全部数据的传输，传输过程中数据包的PID 按照 DATA0-DATA1-DATA0-…的方式翻转，以保证发送端和接收端的同步。  
      • USB 允许连续 3次以下的传输错误，会重试该传输，若成功则将错误次数计数器清零，否则累加该计数器。超过三次后，HOST 认为该端点功能错误（STALL），放弃该端点的传输任务。  
      • 一次批量传输（Transfer）由 1 次到多次批量事务传输（Transaction）组成。  
      • 翻转同步：发送端按照 DATA0-DATA1-DATA0-…的顺序发送数据包，只有成功的事务传输才会导致 PID 翻转，也就是说发送端只有在接收到 ACK 后才会翻转 PID，发送下一个数据包，否则会重试本次事务传输。同样，若在接收端发现接收到到的数据包不是按照此顺序翻转的，比如连续收到两个 DATA0，那么接收端认为第二个 DATA0 是前一个 DATA0 的重传。

      它通过在硬件级执行“错误检测”和“重传”来确保host与device之间“准确无误”地传输数据，即可靠传输。它由三种包组成(即IN事务或OUT事务)：

        1) token

        2) data

        3) handshake

![](https://i-blog.csdnimg.cn/blog_migrate/480c72765f006dcd1bec581a61a7fa51.png)

**1) For IN Token (即：IN Transaction)**

     • ACK: 表示host正确无误地接收到数据

     • NAK: 指示设备暂时不能返回或接收数据  (如：设备忙)

     • STALL:指示设备永远停止，需要host软件的干预 (如：设备出错) 

**2) For OUT Token (即：OUT Transaction)**

     如果接收到的数据包有误，如：CRC错误，Device不发送任何handshake包

     • ACK: Device已经正确无误地接收到数据包，且通知Host可以按顺序发送下一个数据包

        • NAK: Device 已经正确无误地接收到数据包，且通知Host重传数据，由于Device临时状况(如buffer满)

        • STALL: 指示Device endpoint已经停止，且通知Host不再重传

**3) Bulk读写序列**

![](https://i-blog.csdnimg.cn/blog_migrate/557d8e005fda8d780fdd438c2af107b0.png)

      即由一系统IN事务或OUT事务组成。

#### 4.3.3 中断传输(Interrupt Transfer)

    中断传输由IN或OUT事务组成。 

    中断传输在流程上除不支持PING 之外，其他的跟批量传输是一样的。他们之间的区别也仅在于事务传输发生的端点不一样、支持的最大包长度不一样、优先级不一样等这样一些对用户来说透明的东西。  
     主机在排定中断传输任务时，会根据对应中断端点描述符中指定的查询间隔发起中断传输。中断传输有较高的优先级，仅次于同步传输。  
     同样中断传输也采用PID翻转的机制来保证收发端数据同步。下图为中断传输的流程图。

     中断传输方式总是用于对设备的查询，以确定是否有数据需要传输。因此中断传输的方向总是从USB设备到主机。

![](https://i-blog.csdnimg.cn/blog_migrate/f96b42f2e9f54be97a04ac26f2206abd.png)

     DATA0或DATA1中的包含的是中断信息，而不是中断数据。

#### 4.3.4 同步传输(Isochronous Transfer)

**1) 它由两种包组成：**

        1) token

        2) data

       同步传输不支持“handshake”和“重传能力”，所以它是不可靠传输。

      同步传输是不可靠的传输，所以它没有握手包，也不支持PID翻转。主机在排定事务传输时，同步传输有最高的优先级。

      同步传输适用于必须以固定速率抵达或在指定时刻抵达，可以容忍偶尔错误的数据上。实时传输一般用于麦  
克风、喇叭、UVC Camera等设备。实时传输只需令牌与数据两个信息包阶段，没有握手包，故数据传错时不会重传。

![](https://i-blog.csdnimg.cn/blog_migrate/98912337f0743881b3cc09308a9b911a.png)

#### 4.4  USB总线上的工作情况

![](https://i-blog.csdnimg.cn/blog_migrate/00ef552e522716b46851b81cf9d4c4be.png)

---

##  5. 几点重要备注

### 5.1 几个概念之间的关系

-  一个【传输】（控制、批量、中断、等时）由多个【事务】组成；一个【事务】(IN、OUT、SETUP)由一个或多个【Packet】组成。
- 包是USB总线上数据传输的最小单位，不能被打断或干扰，否则会引发错误。若干个数据包组成一次事务传输，一次事务传输也不能打断，属于一次事务传输的几个包必须连续，不能跨帧完成。一次传输由一次到多次事务传输构成，可以跨帧完成。
- USB数据在【主机软件】与【USB设备特定的端点】间被传输。【主机软件】与【USB设备特定的端点】间的关联叫做【pipes】。一个USB设备可以有多个管道(pipes)。
- **帧（frame）****是什么？**

帧是一个时间概念，在USB中，高速USB 总线的帧周期为125us，全速以及低速 USB 总线的帧周期为 1ms，它是一个独立的单元，包含了一系列总线动作，USB将1帧分为好几份，不同的部分执行不同的功能。

数据在 USB总线上的传输以包为单位，包只能在帧内传输。帧的起始即帧头由一个特定的包（SOF 包）表示，帧尾为 EOF。EOF不是一个包，而是一种电平状态，EOF期间不允许有数据传输。 

### 5.2 几点补充

（1） 虽然高速USB总线和全速/低速USB总线的帧周期不一样，但是SOF包中帧编号的增加速度是一样的，因为在高速USB系统中，SOF包中帧编号实际上取得是计数器的高11位，最低三位作为微帧编号没有使用，因此其帧编号的增加周期也为 1mS。

**（2） PC机识别USB设备是否插入**

USB接口只有4条线: VCC（5V）,GND,D-,D+。 PC机的USB插孔的D-和D+数据线均连接15K欧姆的下拉电阻。而USB设备端的D-或D+数据线连接1.5K欧姆的上拉电阻。当设备插入PC机的时候，会将PC机的D-或D+端的电压拉高，**当PC机在D-或D+端检测到高电平时，就知道有设备插入了。**如果是PC机D-端被拉高，接入的则是USB低速设备；如果是PC机D+端被拉高，接入的则是USB全速或高速设备，具体是全速设备还是高速设备，会由PC机和USB设备发包握手确定。

**（3） PC机获取外部设备信息**

![](https://i-blog.csdnimg.cn/blog_migrate/40611dfa0f984c34f3b018c009edcadd.jpeg)

检测到设备插入，主机以描述符的形式向从机索要它的信息，从机同样以描述符的形式实话实说（一旦知道你插入了，人家就得问你是谁，你也必须说实话，获取她的同意，否则违法）。明确一点：和其他主从机设备通信一样，USB外部设备（从机）不会主动给PC机（主机）发数据，除非主机有那个需求，向从机索要。

**（4）USB的传输类型:**

      a. 控制传输：可靠，时间有保证，比如：USB设备的识别过程  
      b. 批量传输: 可靠, 时间没有保证, 比如：U盘  
      c. 中断传输：可靠，实时，比如：USB鼠标  
      d. 实时传输：不可靠，实时，比如：USB摄像头

- 所有USB通信数据的来源和目的都是基于端点，每个USB外设只有唯一一个地址，最多包含16个端点，注意：3.(IN) 和3.(OUT)是两个不同的端点。
- **USB传输的对象：端点(endpoint)**

     每一个端点都有传输类型，传输方向。我们说"读U盘"、"写U盘"，可以细化为：把数据写到U盘的端点1，从U盘的端点2里读出数据。除了端点0外，每一个端点只支持一个方向的数据传输。注意：端点0用于控制传输，既能输出也能输入。 主从模式通信中，不特别声明，程序里说的输入(IN)、输出(OUT) "都是" 基于USB主机的立场说的。比如鼠标的数据是从键盘传到PC机, 对应的端点称为"输入端点"。

**（5）数据编解码和位填充** 

USB采用NRZI（**非归零编码**）对发送的数据包进行编码 。  
       输入数据0， 编码成“电平翻转” ；输入数据1， 编码成“电平不变” ；（**NRZI遇0翻转，遇1不变**）。  
       编码出来的序列，高电平：J状态；低电平：K状态 。

![](https://i-blog.csdnimg.cn/blog_migrate/202118dbc9de9bd3a6e90eec8949e5a8.png)

在USB中，每个USB数据包，最开始都有个同步域（SYNC），这个域固定为 0000 0001，这个域通过NRZI编码之后，就是一串方波，接受者可以用这个 SYNC 域来同步之后的数据信号。此外，因为在 USB的NRZI编码下，逻辑0会造成电平翻转，所以接受者在接受数据的同时，根据接收到的翻转信号不断调整同步频率，保证数据传输正确.但是，这样还是会有一个问题，就是虽然接受者可以主动和发送者的频率匹配，但是两者之间总会有误差。假如数据信号是 1000 个逻辑1，经过 USB 的 NRZI 编码之后，就是很长一段没有变化的电平，在这种情况下，即使接受者的频率和发送者相差千分之一，就会造成把数据采样成 1001 个或者 999 个 1了。USB 对这个问题的解决办法，就是**强制插 0，也就是传说中的 bit-stuffing**，如果要传输的数据中有 7 个连续的 1，发送前就会在第 6 个 1 后面强制插入一个 0，让发送的信号强制出现翻转，从而强制接受者进行频率调整。接受者只要删除 6个连续1之后的 0，就可以恢复原始的数据了。



## 6. USB的几种状态

USB协议的讲到USB可见设备状态分为连接(Attached)，上电(Powered)，默认(Default)，地址(Address)，配置(Configured)和[挂起](https://so.csdn.net/so/search?q=%E6%8C%82%E8%B5%B7&spm=1001.2101.3001.7020)(Suspended)6个状态。所谓可见，即USB系统和主机可见的状态，其他状态属于USB设备内部而不可见。

### **1. 连接(Attached)**

设备接入主机后，主机通过检测信号线上的电平变化来发现设备的接入；

###  **2. 上电(Powered)**

USB设备的电源可来自外部电源，也可从USB接口的集线器而来。电源来自外部电源的USB设备被称作自给电源式的(self-powered)。尽管自给电源式的USB设备可能在连接上USB接口以前可能已经带电，但它们直到连线上USB接口后才能被看作是加电状态(Powered state)。而这时候VBUS已经对设备产生作用了.

一个设备可能有既支持自给电源的，同时也支持总线电源式的配置。有一些支持其中的一种，而另一些设备配置可能只有在自给电源下才能被使用。设备对电源支持的能力是通过配置描述表(configuration descriptor)来反映的。当前的电源供给形式被作为设备状态的一部分被反映出来。设备可在任何时候改变它们的供电来源，比如说：从自给式向总线式改变，如果一个配置同时支持两种模式，那此状态的最大电源需求就是指设备在两种模式下从VBUS上获取电能的最大值。设备必须以此最大电源作为参照，而究竟处于何状态是不考虑的。如果有一配置仅支持一种电源模式，那么电源模式的改变会使得设备失去当前配置与地址，返回加电状态。如果一个设备是自给电源式，并且当前配置需要大于100mA电流，那么如果此设备转到了总线电源式，它必须返回地址状态(Address state)。自给电源式集线器使用VBUS来为集线控制器(Hub controller)提供电源，因而可以仍然保持配置状态(Configured state)，尽管自给电源停止提供电源。

###   **3. 默认状态(Default)**

设备上电后,它不响应任何总线处理,直到总线接收到复位信号为止.接收到复位信号后,用默认的地址可以对设备寻址.  

当用复位过程完成后,USB设备在正确的速度下操作(即低速/全速/高速).低速和全速的数据选择由设备的终端电阻决定.能进行高速操作的设备决定它是否在复位的过程的一部分执行高速操作.  
    
能进行高速操作的设备在全速的电气环境中操作时,必须能以全速成功复位.设备成功复位后,设备必须成功响应设备和配置描述符请求,并且返回适当的信息.当在全速下工作时,设备可能或者不能支持预定义的功能.

###   **4. 地址(Address)** 

所有的USB设备在加电复位以后都使用缺省地址。每一设备在连接或复位后由主机分配一个唯一的地址。当USB设备处于挂起状态时，它保持这个地址不变。  
        USB设备只对缺省通道(Pipe)请求发生响应，而不管设备是否已经被分配地址或在使用缺省地址。

###   **5. 配置状态( Configured )**

在USB设备正常工作以前，设备必须被正确配置。从设备的角度来看，配置包括一个将非零值写入设备配置寄存器的操作。配置一个设备或改变一个可变的设备设置会使得与这个相关接口的终端结点的所有的状态与配置值被设成缺省值。这包括将正在使用(date toggle)的结点(end point)的 (Date toggle)被设置成DATA0。

###   **6. 挂起状态**

为节省电源，USB设备在探测不到总线传输时自动进入中止状态。当中止时，USB设备保持本身的内部状态，包括它的地址及配置。  
        所有的设备在一段特定的时间内探测不到总线活动时必须进入中止态。不管设备是被分配了非缺省的地址或者是被配置了，已经连接的设备必须在任何加电的时刻随时准备中止。总线活动的中止可能是因为主机本身进入了中止状态。另外，USB设备必须在所连接的集线器端口失效时进入中止态。这就是所指的选择性中止(Selective suspend)。  
       USB设备在总线活动来到时结束中止态。USB设备也可以远程唤醒的电流信号来请求主机退出中止态或选择性中止态。具体设备具有的远程唤醒的能力是可选的，也就是说，如果一个设备有远程唤醒的能力，此设备必须能让主机控制此能力的有效与否。当设备复位时，远程唤醒能力必须被禁止。

### 7. 总结

- **接入态（Attached）**：设备接入主机后，主机通过检测信号线上的电平变化来发现设备的接入；
- **供电态（Powered）：**就是给设备供电，分为设备接入时的默认供电值，配置阶段后的供电值（按数据中要求的最大值，可通过编程设置）
- **缺省态（Default）：**USB在被配置之前，通过缺省地址0与主机进行通信；
- **地址态（Address）：**经过了配置，USB设备被复位后，就可以按主机分配给它的唯一地址来与主机通信，这种状态就是地址态；
- **配置态（Configured）：**通过各种标准的USB请求命令来获取设备的各种信息，并对设备的某此信息进行改变或设置。
- **挂起态（Suspended）：**USB总线处于空闲状态的话，该设备就要自动进入挂起状态，在进入挂起状态后，总的电流功耗不超过280UA。

|   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|
|**连****接**|**加****电**|**缺****省**|**编****址**|**配****置**|**挂****起**|**说**   **明**|
|不|__ __|__ __|__ __|__ __|__ __|设备尚未连接至接口.其他特性无关|
|是|不|__ __|__ __|__ __|__ __|设备已连接至接口,但未加电. 其他特性无关.|
|是|是|不|__ __|__ __|__ __|设备已连接至接口,并且已加电.但尚未被复位.|
|是|是|是|不|__ __|__ __|设备已连接至接口,已加电. 并被复位.<br><br>但尚未分配地址.设备在缺省地址处可寻址.|
|是|是|是|是|不|__ __|设备已连接至接口,已加电. 并被复位.且分配了唯一地址.<br><br>尚未被配置.|
|是|是|是|是|是|不|设备已连接至接口,已加电. 并被复位.且分配了唯一地址,并被配置.<br><br>设备功能可被使用.|
|是|是|__ __|__ __|__ __|是|设备在至少3毫秒以内探测不到总线活动,自动进如挂起.<br><br>设备功能不可用.|

![](https://i-blog.csdnimg.cn/blog_migrate/b342ca8d92bf482568f66739cecd32c9.png)

---

## 8. USB的[枚举](https://so.csdn.net/so/search?q=%E6%9E%9A%E4%B8%BE&spm=1001.2101.3001.7020)

### 1. 枚举是什么

USB主机在检测到USB设备插入后，就要对设备进行枚举了。为什么要枚举呢？**枚举就是**USB的Host和Device之间的对话，即Host根据Device所报告上来的参数，获得一些信息，**知道设备是什么样的设备，如何进行通信，这样主机就可以根据这些信息来加****载合适的驱动程序**。

已经知道USB设备驱动向USB控制器驱动请求的每次传输被称为一个事务（Transaction），事务有四种类型，分别是Bulk Transaction、Control Transaction、Interrupt Transaction和Isochronous Transaction。每次事务都会分解成若干个数据包在USB总线上传输。每次传输必须历经两个或三个部分，第一部分是USB控制器向USB设备发出命令，第二部分是USB控制器和USB设备之间传递读写请求，其方向主要看第一部分的命令是读还是写，第二部分有时候可以没有。第三部分是握手信号。

Control Transaction这种传输在USB中是非常重要的，它要保证数据的正确性，在设备的枚举过程中都是使用控制传输。控制传输分为三个过程：①建立过程。②可选的数据过程。③状态过程。

建立（Setup）过程都是由USB主机发起，它开始于一个Setup令牌包，后面紧跟一个DATA0包。如果是控制输入传输，那么数据过程就是输入数据；如果是控制输出传输，那么数据过程是输出数据。如果在设置过程中，指定了数据长度为0，则没有数据过程。**数据过程之后是状态过程。状态过程刚好与数据过程的数据传输方向相反**：如果是控制输入传输，则状态过程是一个输出数据包；如果是控制输出传输，则状态过程是一个输入数据包。**状态阶段用来确认所有的数据都已经正确传输**。

### 2. 枚举过程

2.0协议：

- **检测电压变化，报告主机**
    

    首先，USB设备上电后，一直监测USB设备接口电平变化HUB检测到有电压变化，将利用自己的中断端点将信息反馈给主控制器有设备连接。

- **Host了解连接的设备**
    

  每个hub利用它自己的中断端点向主机报告它的各个端口的状态（对于这个过程，设备是看不到的，也不必关心），报告的内容只是hub端口的设备连接／断开的事件。如果有连接／断开事件发生，那么host会发送一个 Get_Port_Status请求(request)给hub以了解此次状态改变的确切含义。Get_Port_Status等请求属于所有hub都要求支持的hub类标准请求（standard hub-class requests）。

- **Hub检测所插入的设备是高速还是低速设备**
    

 hub通过检测USB总线空闲(Idle)时差分线的高低电压来判断所连接设备的速度类型，当host发来Get_Port_Status请求时，hub就可以将此设备的速度类型信息回复给host。USB 2.0规范要求速度检测要先于复位（Reset）操作。

- **hub复位设备**
    

      主机一旦得知新设备已连上以后，它至少等待100ms以使得插入操作的完成以及设备电源稳定工作。然后主机控制器就向hub发出一个 Set_Port_Feature请求让hub复位其管理的端口(刚才设备插上的端口)。hub通过驱动数据线到复位状态(D+和D-全为低电平 )，并持续至少10ms。当然，hub不会把这样的复位信号发送给其他已有设备连接的端口，所以其他连在该hub上的设备自然看不到复位信号，不受影响。

- **Host检测所连接的全速设备是否是支持高速模式**
    

       因为根据USB 2.0协议，高速（High Speed）设备在初始时是默认全速（Full Speed ）状态运行，所以对于一个支持USB 2.0的高速hub，当它发现它的端口连接的是一个全速设备时，会进行高速检测，看看目前这个设备是否还支持高速传输，如果是，那就切到高速信号模式，否则就一直在全速状态下工作。  
       同样的，从设备的角度来看，如果是一个高速设备，在刚连接bub或上电时只能用全速信号模式运行（根据USB 2.0协议，高速设备必须向下兼容USB 1.1的全速模式）。随后hub会进行高速检测，之后这个设备才会切换到高速模式下工作。假如所连接的hub不支持USB 2.0，即不是高速hub，不能进行高速检测，设备将一直以全速工作。

- **Hub建立设备和主机之间的信息通道**
    

       主机不停地向hub发送Get_Port_Status请求，以查询设备是否复位成功。Hub返回的报告信息中有专门的一位用来标志设备的复位状态。  
       当hub撤销了复位信号，设备就处于默认／空闲状态（Default state），准备接收主机发来的请求。设备和主机之间的通信通过控制传输，默认地址0，端点号0进行。此时，设备能从总线上得到的最大电流是100mA。(**所有的USB设备在总线复位后其地址都为0，这样主机就可以跟那些刚刚插入的设备通过地址0通信**。)

- **主机发送Get_Descriptor请求获取默认管道的最大包长度**
    

       默认管道（Default Pipe）在设备一端来看就是端点0。主机此时发送的请求是默认地址0，端点0，虽然所有未分配地址的设备都是通过地址0来获取主机发来的请求，但由于枚举过程不是多个设备并行处理，而是一次枚举一个设备的方式进行，所以不会发生多个设备同时响应主机发来的请求。  
      设备描述符的第8字节代表设备端点0的最大包大小。虽然说设备所返回的设备描述符（Device Descriptor）长度只有18字节，但系统也不在乎，此时，描述符的长度信息对它来说是最重要的，其他的瞄一眼就过了。当完成第一次的控制传输后，也就是完成控制传输的状态阶段，系统会要求hub对设备进行再一次的复位操作（USB规范里面可没这要求）。再次复位的目的是使设备进入一个确定的状态。

- **主机给设备分配一个地址**
    

       主机控制器通过Set_Address请求向设备分配一个唯一的地址。在完成这次传输之后，设备进入地址状态（Address state），之后就启用新地址继续与主机通信。这个地址对于设备来说是终生制的，设备在，地址在；设备消失（被拔出，复位，系统重启），地址被收回。同一个设备当再次被枚举后得到的地址不一定是上次那个了。

- **主机获取设备的信息**
    

       主机发送 Get_Descriptor请求到新地址读取设备描述符，这次主机发送Get_Descriptor请求可算是诚心，它会认真解析设备描述符的内容。设备描述符内信息包括端点0的最大包长度，设备所支持的配置（Configuration）个数，设备类型，VID（Vendor ID，由USB-IF分配）， PID（Product ID，由厂商自己定制）等信息。

接着说到描述符。总的来讲描述符就是USB设备之间通信的规范。当一个新的USB设备接入时，他的默认地址为0，此时主设备通过描述符识别从设备，并与其通信，来获得更多关于从设备的信息。并为从设备在1到127找到一个没有分配的地址。并将该地址赋给这个从设备，这样，这个从设备就可以使用新获得的地址和主设备通信了。

- **GET_INTERFACE(取获取接口)**
    

      这个请求向指定接口返回选中的备用设备。  
      一些USB设备有接口设置互斥的配置。这个请求允许主机确定当前选定的备用设置。如果wValue或者wLength的值与上面指定的不一致，那么设备的行为没有定义；如果指定的接口不存在，那么设备将用请求错误响应。  
     •默认状态：当设备处于默认状态时接收到这个请求，设备的行为没  有定义  
     •地址状态：设备给出请求错误  
     •配置状态：当设备处于配置状态时，这是一个有效的请求

