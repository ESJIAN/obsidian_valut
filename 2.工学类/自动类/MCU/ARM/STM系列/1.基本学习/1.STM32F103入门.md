STM32库开发实战指南——基于野火指南者开发板

《[野火]STM32库开发实战指南——基于野火指南者开发板》

本书主要面向无MCU开发经验，希望从零开始学习STM32开发的开发者及在校学生。

[书本在线文档地址](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/index.html)

[书籍配套例程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/README.html#id2 "永久链接至标题")

请在开发板资料中获取对应图书名字下的配套例程压缩包。

- [关于本项目](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/README.html)
- [关于野火](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/about_us.html)

零死角玩转STM32

- [1. 前言与学习必读](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/foreword.html)
- [2. 如何安装KEIL5和打开例程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/KEIL5.html)
- [3. 如何用DAP仿真器下载程序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/DAP_download.html)
- [4. 如何用串口下载程序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/ISP_download.html)
- [5. 初识STM32](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/First_acquaintance.html)
- [6. 什么是寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html)
- [7. 新建工程—寄存器版](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Newproject_register.html)
- [8. 使用寄存器点亮LED灯](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html)
- [9. 自己写库—构建库函数雏形](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html)
- [10. 初识STM32标准库](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html)
- [11. 新建工程—库函数版](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Newproject_lib.html)
- [12. GPIO输出—使用固件库点亮LED](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html)
- [13. GPIO输入—按键检测](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_input.html)
- [14. GPIO—位带操作](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_bit.html)
- [15. 启动文件详解](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Startup_file.html)
- [16. RCC—使用HSE/HSI配置时钟](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/RCC.html)
- [17. STM32中断应用概览](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Interrupt_application.html)
- [18. EXTI—外部中断/事件控制器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html)
- [19. SysTick—系统定时器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SysTick.html)
- [20. 通讯的基本概念](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/communication.html)
- [21. USART—串口通讯](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html)
- [22. DMA—直接存储区访问](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/DMA.html)
- [23. 常用存储器介绍](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/storage.html)
- [24. I2C—读写EEPROM](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html)
- [25. SPI—读写串行FLASH](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html)
- [26. 串行FLASH文件系统FatFs](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html)
- [27. LCD—液晶显示](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LCD.html)
- [28. LCD—液晶显示中英文](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LCD_display.html)
- [29. 电阻触摸屏—触摸画板](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/touch.html)
- [30. ADC—电压采集](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/ADC.html)
- [31. TIM—基本定时器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/TIM_basic.html)
- [32. TIM—高级定时器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/TIM_senior.html)
- [33. TIM—电容按键检测](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/TIM_key.html)
- [34. IWDG—独立看门狗](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/IWDG.html)
- [35. WWDG—窗口看门狗](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/WWDG.html)
- [36. SDIO—SD卡读写测试](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SDIO.html)
- [37. 基于SD卡的FatFs文件系统](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SD_FatFs.html)
- [38. DAC—输出正弦波](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/DAC.html)
- [39. 全彩LED灯实验](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/COLOR_TIM.html)
- [40. 呼吸灯与SPWM波](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPWM.html)
- [41. 电源管理—实现低功耗](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Power.html)
- [42. RTC—实时时钟](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/RTC.html)
- [43. MDK的编译过程及文件类型全解](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/MDK.html)
- [44. 在SRAM中调试代码](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SRAM.html)
- [45. 读写内部FLASH](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH.html)
- [46. 设置FLASH的读写保护及解除](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_protect.html)
- [47. MPU6050传感器—姿态检测](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/MPU6050.html)
- [48. OV7725摄像头驱动](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/OV7725.html)

版权

- [版权说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/LICENSE.html)


# 1. 前言与学习必读

## 1.1. 本书的学习顺序

本书分为基础入门篇和提高篇，入门篇需要按照顺序学习，讲究循序渐进，步步为营。学习完基础篇之后，应该算基本入门M3。提高篇属于高级例程， 学习的时候并不一定要按照书中的章节排序，可根据需要跳跃式的学习。另外教程1至6章节不含具体程序内容，2至4章节可以用8-使用寄存器点亮LED灯例程试，例程文件夹序号从7开始排列。

## 1.2. 本书的参考资料

本书参考资料为：《STM32F10x-中文参考手册》和《Cortex-M3权威指南》，这两本是ST官方的手册，属于精华版，面面俱到，无所不包。 限于篇幅问题，本书不可能面面具到，着重框图分析和代码讲解，有关寄存器的详细描述则略过，在学习本书的时候，涉及到寄存器描述部分还请参考这两本手册， 这样学习效果会更佳。

## 1.3. 本书的编写风格

本书着重讲解F103的外设以及外设的应用，力争全面分析每个外设的功能框图和外设的使用方法，让读者可以零死角的玩转STM32—F103系列。 基本每个章节对应一个外设，每章的主要内容大概分为三个部分，第一部分为简介，第二部分为外设功能框图分析，第三部分为代码讲解。

外设简介则是用自己的话把外设概括性的介绍一遍，力图语句简短，通俗易懂，并不会完全照抄数据手册的介绍。

外设功能框图分析则是章节的重点，该部分会详细讲解功能框图的每个部分的作用，这是学习F103的精髓所在，掌握了整个外设的框图则可以熟练的使用该外设， 熟练的编程，日后学习其他型号的单片机，也将会得心应手。因为即使单片机的型号不同，外设的框图还是基本一样的。这一步的学习比较枯燥，但是必须死磕，方能达成所愿 。

代码分析则是讲解使用该外设的实验讲解，主要分析代码流程，和一些编程的注意事项。在掌握了框图之后，代码部分则是手到擒来而已。

## 1.4. 本书的配套硬件

本书配套的硬件平台为：野火STM32-F103VE-指南者，型号简称“指南者”，学习的时候如果配套该硬件平台做实验， 学习必会达到事半功倍的效果，可以省去中间移植时遇到的各种问题。

![野火STM32F103—指南者](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/forewo002.png)

## 1.5. 本书的技术论坛

如果在学习过程中遇到问题，可以到论坛：[www.firebbs.cn发帖交流](http://www.firebbs.xn--cn-y82cv7ruzoy9v/) ，开源共享，共同进步。

鉴于水平有限，本书难免有纰漏，热心的读者也可把勘误发到论坛好让我们改进做得更好，祝您学习愉快，M3的世界，野火与您同行。






# 2. 如何安装KEIL5和打开例程

本章内容所涉及的软件只供教学使用，不得用于商业用途。个人或公司因商业用途导致的法律责任，后果自负。

## 2.1. 温馨提示

1. 安装路径不能带中文，必须是英文路径
    
2. 安装目录不能跟51的KEIL或者KEIL4冲突，三者目录必须分开
    
3. KEIL5的安装比起KEIL4多了一个步骤，必须添加MCU库，不然没法使用。
    
4. 如果使用的时候出现莫名其妙的错误，先百度查找解决方法，莫乱阵脚。
    

## 2.2. 获取KEIL5安装包

要想获得KEIL5的安装包，在百度里面搜索“KEIL5下载”即可找到很多网友提供的下载文件， 或者到KEIL的官网下载：[https://www.keil.com/download/product/](https://www.keil.com/download/product/)，一大堆注册非常麻烦。建议使用最新或者靠近最新版本都可以。

![../_images/KEIL5002.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5002.png)

## 2.3. 开始安装KEIL5

双击KEIL5安装包，开始安装，next。

![../_images/KEIL5003.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5003.png)

Agree，Nest

![../_images/KEIL5004.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5004.png)

选择安装 路径，路径不能带中文，next

**提示：** Pack目录下后续可能会安装以后会用到的各种芯片的芯片包容易占空间， 建议C盘剩余空间不多的用户可以直接在框中编辑改路径，把 C 改为 D（或其他盘，直接改第一个字符就行，注意不要删错后面符号）

![../_images/KEIL5005.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5005.png)

填写用户信息，全部填空格（键盘的space键）即可，next

![../_images/KEIL5006.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5006.png)

Finish，安装完毕

![../_images/KEIL5007.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5007.png)

## 2.4. 安装STM32芯片包

KEIL5不像KEIL4那样自带了很多厂商的MCU型号，KEIL5需要自己安装。

把下面弹出的界面关掉，我们直接去keil的官网下载：[http://www.keil.com/dd2/pack/](http://www.keil.com/dd2/pack/)，或者直接用我们下载好的包。

![../_images/KEIL5008.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5008.png)

在官网中找到STM32F1、STM32F4、STM32F7这3个系列的包下载到本地电脑，具体下载哪个系列的根据你使用的型号下载即可， 这里我只下载我自己需要使用的F1/4/7这三个系列的包，F1代表M3，F4代表M4，F7代表M7。

![../_images/KEIL5009.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5009.png)

把下载好的包双击安装即可，安装路径选择跟KEIL5一样的安装路径，安装成功之后，在KEIL5 的 Pack Installer 中就可以看到我们安装的包， 以后我们新建工程的时候，就有单片机的型号可选。

![../_images/KEIL5010.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5010.png)

到这里KEIL5就安装完毕。要特别注意的是KEIL5的安装目录不能跟其他版本的KEIL冲突， 如果冲突了则卸载后重新安装。最后还要记得安装STM32芯片包。

keil官网对芯片包下载页面进行升级，下载更方便，对于新的芯片包下载页面：[https://www.keil.arm.com/devices/](https://www.keil.arm.com/devices/)

![../_images/KEIL5011.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5011.png)

第一步先找到要下载的芯片系列如STM32F1 Series、STM32F4 Series和STM32F7 Series，也可以通过搜索“STM32F“关键词快速找到STM32 F系列芯片包

![../_images/KEIL5012.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5012.png)

具体下载哪个系列的芯片包根据你使用的型号下载即可， 这里我举例STM32F103RC型号下载芯片包，在STM32F1 Series系列中选STM32F103的具体型号STM32F103RC，进入到下面型号介绍页面，然后点击STM32F1xx_DFP跳转芯片包下载页面

![../_images/KEIL5013.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5013.png)

点击 Download Recommended Pack 即可下载官方推荐的F1系列芯片包

![../_images/KEIL5014.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5014.png)

---

**提示：** 安装完Keil5启动后会弹出一个Pack Installer窗口，它是在线的包管理工具，与在http://www.keil.com/dd2/pack/里面下载的包单独安装效果一样， 例如在Pack Installer界面左边选择了芯片类后，右侧的 xx_DFP 就包含了对应的芯片描述信息，启动文件，固件库等等，下面栏目的是更多的组件库，不在本书范围之内不再描述。 以上的Pack都是安装在安装Keil时填的Pack安装路径，在线的安装方式一般非常慢或者根本没有反应。

## 2.5. 打开例程工程

从我们野火产品资料下载中心提供的网盘下载并且解压好或从野火大学堂下载好对应板子的例程，找到对应存放路径并打开。 野火产品资料下载中心链接： [https://doc.embedfire.com/products/link/zh/latest/index.html](https://doc.embedfire.com/products/link/zh/latest/index.html)

![../_images/KEIL5015.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5015.png)

对于KEIL5打开工程文件，主要找到.uvprojx后缀名文件。前面的部分例程直接找到.uvprojx文件打开即可，从新建工程-固件库版本例程开始就是以工程模板形式打开项目，此时.uvprojx文件主要存放在Project文件夹下，找到并双击打开。

![../_images/KEIL5016.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5016.png)

简单来认识一下KEIL5的主窗口界面

> - 菜单栏：包含File文件、Edit编辑、View视图、Project工程、Help帮助等
>     
> - 工具栏：常见工具的快捷按钮，下面会重点介绍一些常用的工具
>     
> - 工程窗口：主要显示项目内容，文件组、源文件和头文件等
>     
> - 编辑窗口：编写代码的地方
>     
> - 消息窗口：反馈编译信息、烧录信息等
>     
> - 状态栏：光标的行列位置、字符编码、键盘NUM锁定等一些状态信息
>     

![../_images/KEIL5017.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5017.png)

三类常用工具快捷按钮

![../_images/KEIL5018.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/KEIL5018.png)

1. 仿真类快捷按钮：在进行仿真时使用，具有断电标记作用
    

|英文名称|中文描述|快捷键|
|---|---|---|
|Start/Stop Debug Session|打开/关闭调试|Ctrl + F5|
|Insert/Remove Breakpoint|插入/移除断点|F9|
|Enable/Disable Breakpoint|使能/失能断点|Ctrl + F9|
|Disable All Breakpoints|失能所有断点|–|
|Kill All Breakpoints|取消所有断点|Ctrl + Shift + F9|

2. 编译类快捷按钮：对代码进行编译下载
    

|英文名称|中文描述|快捷键|
|---|---|---|
|Translate|编译当前文件|Ctrl + F7|
|Build|编译工程目标|F7|
|Rebuild|重新编译所有目标文件|–|
|Batch Build|分批编译(多工程)|–|
|Stop Build|停止编译(正在编译时有效)|–|
|Download|下载|F8|

3. 工程目标选项又称魔术棒：即对工程目标的配置，如芯片设备选择、C/C++选项、仿真配置等等
    

**注意：** 如何将程序下载到开发板中 请看第3节如何用DAP仿真器下载程序或第4节如何用串口下载程序

# 3. 如何用DAP仿真器下载程序

## 3.1. 仿真器简介

本书配套的仿真器为Fire-Debugger，遵循ARM公司的CMSIS-DAP标准，支持所有基于Cortex-M内核的单片机，常见的M3、M4和M7都可以完美支持。

Fire-Debugger支持下载和在线仿真程序，支持XP/WIN7/WIN8/WIN10这四个操作系统，免驱，不需要安装驱动即可使用，支持KEIL和IAR直接下载，非常方便。

## 3.2. 硬件连接

把仿真器用USB线连接电脑，如果仿真器的灯亮则表示正常，可以使用。然后把仿真器的另外一端连接到开发板，给开发板上电， 然后就可以通过软件KEIL或者IAR给开发板下载程序。

![仿真器与电脑和开发板连接方式](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DAPdow002.png)![仿真器与指南者连接图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DAPdow003.png)![仿真器与霸道连接图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DAPdow004.png)

## 3.3. 仿真器配置

在仿真器连接好电脑和开发板且开发板供电正常的情况下，打开编译软件KEIL，在魔术棒选项卡里面选择仿真器的型号，具体过程看图示：

### 3.3.1. Debug选项配置

![Debug选择CMSIS-DAP Debugger](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DAPdow005.png)

### 3.3.2. Utilities选项配置

![Utilities选择 Use Debug Driver](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DAPdow006.png)

### 3.3.3. Debug Settings 选项配置
![Debug Settings 选项配置](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DAPdow007.png)

注意：

- 上面，CMSIS-DAP Adapter一栏下面显示的型号和Serial No里显示的和视频如果有差异没有关系，能识别到仿真器和板子就行。
    
- 底下，Reset一栏如果没有Autodetect选项，可以选择SYSRESETREQ；
    

特别注意：1.如果是普通DAP 记得打开我们提供的写好的每一个工程后，在仿真器配置界面左下角改选为 Connect：under Reset 才能下载。

2.普通DAP要试Debug时，Reset 选择 HW RESET 或者 VECTRESTET 这样在Debug时可以正确控制复位。

## 3.4. 选择目标板

选择目标板，具体选择多大的FLASH要根据板子上的芯片型号决定。 野火STM32开发板的配置是：F1选512K，F4选1M。这里面有个小技巧就是把Reset and Run也勾选上， 这样程序下载完之后就会自动运行，否则需要手动复位。擦除的FLASH大小选择Sectors即可，不要选择Full Chip，不然下载会比较慢。

![选择目标板](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DAPdow008.png)

## 3.5. 下载程序

如果前面步骤都成功了，接下来就可以把编译好的程序下载到开发板上运行。要先点编译（Build），确认编译正确后再点击下载，下载程序不需要其他额外的软件，直接点击KEIL中的LOAD按钮即可。

![../_images/DAPdow009.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DAPdow009.png)

程序下载后，Build Output选项卡如果打印出 Application running…则表示程序下载成功。如果没有出现实验现象，按复位键试试。

![../_images/DAPdow010.png](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DAPdow010.png)

---

**提示：** 更多关于DAP仿真器使用方面的问题请参考此链接内容 [https://doc.embedfire.com/stm32_products/must_read/zh/latest/doc/quickstart/DAP/DAP.html](https://doc.embedfire.com/stm32_products/must_read/zh/latest/doc/quickstart/DAP/DAP.html)
# 4. 如何用串口下载程序

野火STM32F103VET6— “指南者”自带串口下载电路，配合上位机可实现一键ISP下载，不需要修改开发板上的BOOT设置。 与仿真器Fire-Debugger相比，ISP只能下载程序，不能在线调试且下载速度慢。

## 4.1. 安装USB转串口驱动

野火的STM32开发板用的USB转串口的驱动芯片是CH340，要使用串口得先在电脑中安装USB转串口驱动—CH340版本。 驱动可在网上搜索下载或者使用我们光盘里面提供的。WIN7用户请用管理员身份安装。如果不能安装成功，请先百度查找原因自行解决。

如果USB转串口驱动安装成功，USB线跟板子连接没有问题，在计算机->管理->设备管理器->端口中可识别到串口。

![USB转串口驱动安装成功](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/ISPdow002.png)

如果识别不了串口，请检查USB线是否完好，可换一根USB线试试。

## 4.2. 硬件连接

用USB线连接电脑和开发板的USB转串口接口：USB TO UART，给开发板上电。

![串口下载连接图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/ISPdow003.png)![霸道串口下载接线图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/ISPdow004.png)

## 4.3. 开始下载

目前有两款串口下载软件来实现串口下载程序，mcuisp和FlyMcu软件，建议使用提供的FlyMcu V0.188版本。

打开mcuisp软件，配置如下：①搜索串口，设置波特率115200（尽量不要设置的太高） 、②选择要下载的HEX文件、 ③校验、编程后执行、④DTR低电平复位，RTS高电平进入bootloader（上位机软件为232逻辑电平标准）、⑤开始编程。如果出现一直连接的情况，按一下开发板的复位键即可。

![ISP下载配置](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/ISPdow005.png)![ISP下载成功](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/ISPdow006.png)

打开FlyMcu软件，具体配置见图 [下载配置和下载成功现象](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/ISP_download.html#id8) ：①搜索串口，设置波特率为76800（不要超过115200）、 ②选择要下载的HEX文件、③校验、编程后执行、④DTR低电平复位，RTS高电平进入bootloader（上位机软件为232逻辑电平标准）、⑤开始编程、⑥选项字节的勾去掉，如果勾选上则下载程序后不能自动运行。 如果出现一直连接的情况，按一下开发板的复位键即可。 下载成功后的现象具体见图 [下载配置和下载成功现象](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/ISP_download.html#id8) 中的下载成功现象指示的方框部分。

![下载配置和下载成功现象](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/ISPdow008.png)

（注意：mcuisp和FlyMcu上位机软件都是基于232逻辑电平标准，而后面介绍ISP一键下载原理分析及硬件原理图是基于TTL逻辑电平标准，232标准与TTL标准在逻辑电平上是相反的，所以导致实际硬件上是DTR高电平复位，RTS低电平进入bootloader，而上位机软件设置为DTR低电平复位，RTS高电平进入bootloader。）

## 4.4. ISP一键下载原理分析

### 4.4.1. ISP简介

ISP（In-System Programming）在系统可编程，指电路板上的空白器件可以编程写入最终用户代码， 而不需要从电路板上取下器件， 已经编程的器件也可以用ISP方式擦除或再编程。

ISP的时候需要用到(bootloader)自举程序，自举程序存储在 STM32 器件的内部自举 ROM 存储器（系统存储器）中。 其主要任务是通过一种可用的串行外设（ USART、 CAN、 USB、 I2C 等）将应用程序下载到内部 Flash中。每种串行接口都定义了相应的通信协议， 其中包含兼容的命令集和序列。

### 4.4.2. ISP普通下载

现在我们针对USART1的ISP进行分析，通常的ISP的步骤如下：

1. 电脑通过USB转串口线连接STM32的USART1，并打开电脑端的上位机；
    
2. 设置跳线保持BOOT0为高电平，BOOT1为低电平；
    
3. 复位单片机使其进入bootloader模式，通过上位机下载程序；
    
4. 下载完毕，设置跳线保持BOOT0为低电平，BOOT1为低电平；
    
5. 复位单片机即可启动用户代码，正常运行。
    

以上步骤有个不好的地方就是下载程序需要跳线及复位操作，很繁琐。通过对ISP的原理认识，一键ISP就诞生了，它需要做的事情就是用上位机去控制BOOT0脚和单片机的复位脚，原理图如下：

![ISP一键下载电路](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/ISPdow007.png)

### 4.4.3. BOOT配置

在ISP下载电路中，我们需要配置BOOT引脚，有关BOOT引脚不同的配置会产生不同的启动方式，见下表。

|BOOT0|BOOT1|启动方式|
|---|---|---|
|0|X|内部FLASH|
|1|0|系统存储器|
|1|1|内部SRAM|

### 4.4.4. ISP一键下载

USB转串口估计大家都很熟悉，一般都是用到RXD和TXD这两个口，一键ISP电路中我们需要用USB转串口的芯片的DTR口和RTS口来控制单片机的BOOT0和NRST，原理如下：

1. 通过上位机控制U6(CH340G)的RTS脚为低电平，Q1导通，BOOT0的电平上拉为高电平。
    
2. 通过上位机控制U6(CH340G)的DTR脚为高电平，由于RTS为低电平，Q2导通，U8的2脚为低电平，U18为一个模拟开关， 使能端由4脚控制，默认高电平，U18的1脚和2脚导通，所以NRST为低电平系统复位。
    
3. 单片机进入ISP模式，此时可以将DTR脚设置为低电平，RTS设置为高电平。Q1和Q2为截至状态，BOOT0和NRST还原默认电平。
    
4. 上位机将程序下载到单片机，下载完毕之后，程序自动运行。
    
5. 至此，很多人还会认为U18、Q1、Q2是多余的，用U6的RTS和DTR直接控制也可以。正常情况下，这样理解没有问题，但是我们忽略了一点， 就是单片机上电瞬间如果USB转串口连接了电脑，DTR和RTS的电平是变化的，如果不处理好，单片机会一直进入ISP模式，或者系统会复位多次，这种情况是不允许的。
    
6. 于是，就有了我们全新的一键ISP电路。我们主要是分析上电瞬间的逻辑关系，单片机上电时我们通过示波器观察波形得知DTR和RTS的电平是变化的， 但是也有一个规律就是：只要RTS为低电平的时候，DTR的电平也是低，因此一般情况Q2不会导通，但由于这两个IO口的电平存在“竞争冒险”， 会出现RTS的下降沿的时 候刚好遇到DTR的上升沿，这个时候Q2导通，导致系统复位，而BOOT0此时有可能也为高电平，就会进入ISP模式。 这个是不受我们控制的，我们不想系统出现这样的情况。因此加入了模拟开关来切断这种干扰。
    
7. 加入模拟开关U18，通过控制U18的4脚的开关来达到隔离干扰电平的目的。下面我们分析一下延时开关电路，上电瞬间，电容C65通过电阻R18来充电， 由于电阻100k很大，电容的充电电流很小，等电容充电达到U18的4脚的有效电平2V时，大概耗时1S，在这个1S时间内U18的模拟开关是断开的， 因此RTS和DTR的干扰电平不会影响到系统复位。系统正常运行。
    

---

**提示：** 更多关于串口下载使用方面的问题请参考此链接内容 [https://doc.embedfire.com/stm32_products/must_read/zh/latest/doc/quickstart/DAP/DAP](https://doc.embedfire.com/stm32_products/must_read/zh/latest/doc/quickstart/DAP/DAP).html#




# 5. 初识STM32

本章参考资料：1、《STM8和STM32产品选型手册》

## 5.1. 什么是STM32

STM32，从字面上来理解，ST是意法半导体，M是Microelectronics的缩写，32表示32位，合起来理解，STM32就是指ST公司开发的32位微控制器。 在如今的32位控制器当中，STM32可以说是最璀璨的新星，它受宠若娇，大受工程师和市场的青睐，无芯能出其右。

### 5.1.1. STM32诞生的背景

51 是嵌入式学习中一款入门级的精典 MCU，因其结构简单，易于教学，且可以通过

串口编程而不需要额外的仿真器，所以在教学时被大量采用，至今很多大学在嵌入式教学 中用的还是 51。51 诞生于 70 年代， 属于传统的 8 位单片机，如今，久经岁月的洗礼，既 有其辉煌又有其不足。现在的市场产品竞争越来越激烈，对成本极其敏感， 相应地对 MCU 的性能要求也更苛刻：更多功能，更低功耗，易用界面和多任务。面对这些要求，51 现有的 资源就显得得抓襟见肘。 所以无论是高校教学还是市场需求，都急需一款新的 MCU 来 为这个领域注入新的活力。

基于这样的市场需求， ARM 公司推出了其全新的基于 ARMv7 架构的 32 位 Cortex-M3 微控制器内核。 紧随其后，ST（意法半导体）公司就推出了基于 Cortex-M3 内核的 MCU—STM32。STM32 凭借其产品线的多样化、 极高的性价比、简单易用的库开发方式，迅速在众多Cortex-M3 MCU 中脱颖而出，成为最闪亮的一颗新星。 STM32 一上市就迅速占领了中低端 MCU 市场，受到了市场和工程师的无比青睐，颇有星火燎原之势。

作为一名合格的嵌入式工程师，面对新出现的技术，我们不是充耳不闻，而是要尽快吻合市场的需要，跟上技术的潮流。 如今 STM32 的出现就是一种趋势，一种潮流，我们要 做的就是搭上这趟快车，让自己的技术更有竞争力。

## 5.2. STM32能做什么

STM32属于一个微控制器，自带了各种常用通信接口，比如USART、I2C、SPI等，可接非常多的传感器，可以控制很多的设备。 现实生活中，我们接触到的很多电器产品都有STM32的身影，比如智能手环，微型四轴飞行器，平衡车、移动POST机，智能电饭锅， 3D打印机等等。下面我们以最近最为火爆的两个产品来讲解下，一个是手环，一个是飞行器。

### 5.2.1. 智能手环

![三星 GearFit 智能手环](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Firsta002.png)

- 红圈：STM32F439ZIY6S处理器，2048KB FLASH ，256KB RAM ,WLCSP143封装。
    
- 橙圈：Macronix MX69V28F64 16 MB闪存，基于MCP封装的存储器，是一种包含了NOR和SRAM的闪存， 这在手环手机这种移动设备中经常使用，优点是体积小，可以减小PCB的尺寸。这个闪存用的439的FSMC接口驱动。
    
- 黄圈：InvenSense MPU-6500陀螺仪/加速度计，用439的I2C接口驱动。
    
- 绿圈：博通BCM4334WKUBG芯片，支持802.11n，蓝牙4.0+HS以及FM接收芯片，用439的SDIO或者SPI接口驱动。
    
- 显示：1.84”可弯曲屏幕(Super AMOLED)，432 x 128像素。触摸部分用439的I2C接口驱动，OLED显示部分用LTDC接口驱动。
    

![三星Gear Fit 和野火STM32f103“指南者”资源对比](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Firsta01.png)

除了这几个重要资源的对比，我们的指南者开发板上还板载了EEPROM，USB转串口，蜂鸣器，LED，普通按键，电容按键等外设资源， 还可以扩展VS1053 MP3模块，W5500以太网模块，利用这些可以充分的学习STM32F103VET6这个芯片。在板子上面，还可以跑系统ucosiii， 学习图形界面emwin。如果功夫所至，学完之后，自己都可以做一个类似Gear Fit这样的手环。可很多人又会说，Gear Fit 涉及硬件和软件， 整个系统这么复杂，并不是一个人可以完成的。说的没错，我们可以做不了，但是我们的能力可以无限接近，多学点，技多不压身嘛。

![ucosiii+emwin 做的系统界面（指南者的开机界面）](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Firsta003.png)

### 5.2.2. 微型四轴飞行器

现在无人机非常火热，高端的无人机用STM32做不来，但是小型的四轴飞行器用STM32还是绰绰有余的。 如图 [微型四轴飞行器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/First_acquaintance.html#id6) 所示飞行器的基本都可以用STM32搞定。

![微型四轴飞行器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Firsta004.png)

上面的是属于产品，如果想自己DIY，可以在入门STM32之后，买一本飞行器DIY的书， 边做边学。入门级的书籍推荐《四轴飞行器DIY—基于STM32微控制器》， 见图 [四轴飞行器DIY_基于STM32微控制器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/First_acquaintance.html#diy-stm32) 。

![四轴飞行器DIY—基于STM32微控制器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Firsta005.png)

### 5.2.3. 淘宝众筹

学会了STM32，想自己做产品，如何实现自己的梦想，淘宝众筹吧。做出产品原型，用别人的钱为自己的梦想买单。

淘宝众筹科技类网址：这里面有很多小玩意都可以用STM32实现，只要你的创意到了，就会有人买单，前提是我们要先学会STM32。（注意目前淘宝众筹网已经关闭，可以在网络上搜索类似的众筹网站，然后选择科技类目查看。例如： [https://izhongchou.taobao.com/list.htm?page=1&spm=a215p.128754.0.0.658b47dbPcWM5v&type=121288001](https://izhongchou.taobao.com/list.htm?page=1&spm=a215p.128754.0.0.658b47dbPcWM5v&type=121288001) ）

[https://hi.taobao.com/market/hi/list.php?spm=a215p.1596646.1.8.LbVyJk#type=121288001](https://hi.taobao.com/market/hi/list.php?spm=a215p.1596646.1.8.LbVyJk#type=121288001)

![淘宝众筹科技类](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Firsta006.png)

## 5.3. STM32怎么选型

### 5.3.1. STM32分类

STM32有很多系列，可以满足市场的各种需求，从内核上分有Cortex-M0、M3、M4和M7这几种，每个内核又大概分为主流、高性能和低功耗。 具体的见表格 [STM8和STM32分类](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/First_acquaintance.html#stm8stm32) 。

单纯从学习的角度出发，可以选择F1和F4，F1代表了基础型，基于Cortex-M3内核，主频为72MHZ，F4代表了高性能，基于Cortex-M4内核，主频180M。

之于F1，F4（429系列以上）除了内核不同和主频的提升外，升级的明显特色就是带了LCD控制器和摄像头接口，支持SDRAM， 这个区别在项目选型上会被优先考虑。但是从大学教学和用户初学来说，还是首选F1系列，目前在市场上资料最多，产品占有量最多的就是F1系列的STM32。

![STM8和STM32分类](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Firsta002.png)

### 5.3.2. STM32 命名方法

这里我们以野火F103指南者用的型号STM32F103VET6来讲解下STM32的命名方法。

![STM32F103VET6命名解释](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Firsta03.png)

有关更详细的命名方法见图 [STM8和STM32命名方法](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/First_acquaintance.html#id12) 。

![STM8和STM32命名方法，摘自《STM8和STM32选型手册》](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Firsta007.png)

### 5.3.3. 选择合适的MCU

了解了STM32的分类和命名方法之后，就可以根据项目的具体需求先大概选择哪类内核的MCU，普通应用， 不需要接大屏幕的一般选择Cortex-M3内核的F1系列，如果要追求高性能，需要大量的数据运算，且需要外接RGB大屏幕的则选择Cortex-M4内核的F429系列。

明确了大方向之后，接下来就是细分选型，先确定引脚，引脚多的功能就多，价格也贵，具体得根据实际项目中需要使用到什么功能， 够用就好。确定好了引脚数目之后再选择FLASH大小，相同引脚数的MCU会有不同的FLASH大小可供选择，这个也是根据实际需要选择， 程序大的就选择大点的FLASH，要是产品一量产，这些省下来的都是钱啊。有些月出货量以KK（百万数量级）为单位的产品，不仅是MCU， 连电阻电容能少用就少用，更甚者连PCB的过孔的多少都有讲究。项目中的元器件的选型的水深的很，很多学问。

#### 5.3.3.1. 如何分配原理图IO

在画原理图之前，一般的做法是先把引脚分类好，然后才开始画原理图， 引脚分类具体见表格 [画原理图时的引脚分类](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/First_acquaintance.html#id13) 。

![画原理图时的引脚分类](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Firsta04.png)

#### 5.3.3.2. 如何寻找IO的功能说明

要想根据功能来分配IO，那就得先知道每个IO的功能说明，这个我们可以从官方的数据手册里面找到。在学习的时候， 有两个官方资料我们会经常用到，一个是参考手册（英文叫Reference manual），另外一个是数据手册（英文叫Data Sheet）。 两者的具体区别见表格 [参考手册和数据手册的内容区别](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/First_acquaintance.html#id15) 。

![参考手册和数据手册的内容区别](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Firsta05.png)

一句话概括：数据手册主要用于芯片选型和设计原理图时参考，参考手册主要用于在编程的时候查阅。 官方的这两个文档可以从官方网址里面下载：[https://www.stmcu.com.cn/Product/pro_detail/STM32F1/product](https://www.stmcu.com.cn/Product/pro_detail/STM32F1/product)，也可以从我们配置的光盘资料里面找到。

在数据手册中，有关引脚定义的部分在Pinouts and pin description这个小节中，具体定义见表格 [数据手册中对引脚定义](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/First_acquaintance.html#id16) 。

![数据手册中对引脚定义](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Firsta008.png)![对引脚定义的解读](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Firsta07.png)

#### 5.3.3.3. 开始分配原理图IO

比如我们的F103“指南者”使用的MCU型号是STM32F103VET6，封装为LQFP100，我们在数据手册中找到这个封装的引脚定义， 然后根据引脚序号，一个一个复制出来，整理成excel表。 具体整理方法按照表格 [画原理图时的引脚分类](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/First_acquaintance.html#id13) 画原理图时的引脚分类即可。分配好之后就开始画原理图。

### 5.3.4. PCB哪里打样

设计好原理图，画好PCB之后，需要把板子做出来，进行软硬件联调。首先得PCB打样，这里我推荐一家我经常打样的厂家，深圳嘉立创（JLC）， 行业标杆，良心价格，网址：[http://www.sz-jlc.com](http://www.sz-jlc.com/)。一块10CM*10CM以内的板子，三天做好，50块就可以搞定，还包邮，简直便宜到掉渣。 如果你足够懒，不想自己焊接电阻电容二三极管什么的，嘉立创还可以帮你把PCB样板上的阻容贴好给你，打样贴片一条龙。

样品做好了，软硬件什么都OK，要小批量怎么办？还是找JLC。


# 6. 什么是寄存器

本章参考资料：《STM32F10xx 参考手册》、《STM32F10xx数据手册》、

学习本章时，配合《STM32F10xx 参考手册》“存储器和总线架构”及“通用I/O(GPIO)”章节一起阅读，效果会更佳，特别是涉及到寄存器说明的部分。

## 6.1. 什么是寄存器

我们经常说寄存器，那么什么是寄存器？这是我们本章需要讲解的内容，在学习的过程中，大家带着这个疑问好好思考下，到最后看看大家能否用一句话给寄存器下一个定义。

## 6.2. STM32长啥样

我们开发板中使用的芯片是100pin的STM32F103VET6，具体见图 [STM32F103VET6实物图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#stm32f103vet6) 。 这个就是我们接下来要学习的STM32，它将带领我们进入嵌入式的殿堂。

芯片正面是丝印，ARM应该是表示该芯片使用的是ARM的内核，STM32F103VET6是芯片型号，后面的字应该是跟生产批次相关，最上面的是ST的LOGO。

芯片四周是引脚，左下角的小圆点表示1脚，然后从1脚起按照逆时针的顺序排列（所有芯片的引脚顺序都是逆时针排列的）。 开发板中把芯片的引脚引出来，连接到各种传感器上，然后在STM32上编程（实际就是通过程序控制这些引脚输出高电平或者低电平）来控制各种传感器工作， 通过做实验的方式来学习STM32芯片的各个资源。开发板是一种评估板，板载资源非常丰富，引脚复用比较多， 力求在一个板子上验证芯片的全部功能。[STM32F103VET6正面引脚图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id3)

![STM32F103VET6实物图（红色框中部分）](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist002.png)![STM32F103VET6正面引脚图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist003.png)

## 6.3. 芯片里面有什么

我们看到的STM32芯片是已经封装好的成品，主要由内核和片上外设组成。若与电脑类比，内核与外设就如同电脑上的CPU与主板、内存、显卡、硬盘的关系。

STM32F103采用的是Cortex-M3内核，内核即CPU，由ARM公司设计。ARM公司并不生产芯片，而是出售其芯片技术授权。 芯片生产厂商(SOC)如ST、TI、Freescale，负责在内核之外设计部件并生产整个芯片，这些内核之外的部件被称为核外外设或片上外设。 如GPIO、USART（串口）、I2C、SPI等都叫做片上外设。具体见图 [STM32芯片架构简图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id5) 。

![STM32芯片架构简图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist004.png)

芯片（这里指内核，或者叫CPU）和外设之间通过各种总线连接，其中驱动单元有4个，被动单元也有4个， 具体见图 [STM32F10xx系统框图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#stm32f10xx) 。为了方便理解，我们都可以把驱动单元理解成是CPU部分，被动单元都理解成外设。 下面我们简单介绍下驱动单元和被动单元的各个部件。

### 6.3.1. ICode总线

ICode中的I表示Instruction，即指令。我们写好的程序编译之后都是一条条指令，存放在FLASH中， 内核要读取这些指令来执行程序就必须通过ICode总线，它几乎每时每刻都需要被使用，它是专门用来取指的。

### 6.3.2. 驱动单元

#### 6.3.2.1. DCode总线

DCode中的D表示Data，即数据，那说明这条总线是用来取数的。我们在写程序的时候，数据有常量和变量两种， 常量就是固定不变的，用C语言中的const关键字修饰，是放到内部的FLASH当中的，变量是可变的，不管是全局变量还是局部变量都放在内部的SRAM。 因为数据可以被Dcode总线和DMA总线访问，所以为了避免访问冲突，在取数的时候需要经过一个总线矩阵来仲裁，决定哪个总线在取数。

#### 6.3.2.2. 系统总线

系统总线主要是访问外设的寄存器，我们通常说的寄存器编程，即读写寄存器都是通过这根系统总线来完成的。

#### 6.3.2.3. DMA总线

DMA总线也主要是用来传输数据，这个数据可以是在某个外设的数据寄存器，可以在SRAM，可以在内部的FLASH。 因为数据可以被Dcode总线和DMA总线访问，所以为了避免访问冲突，在取数的时候需要经过一个总线矩阵来仲裁，决定哪个总线在取数。

### 6.3.3. 被动单元

#### 6.3.3.1. 内部的闪存存储器

内部的闪存存储器即FLASH，我们编写好的程序就放在这个地方。内核通过ICode总线来取里面的指令。

#### 6.3.3.2. 内部的SRAM

内部的SRAM，即我们通常说的RAM，程序的变量，堆栈等的开销都是基于内部的SRAM。内核通过DCode总线来访问它。

#### 6.3.3.3. FSMC

FSMC的英文全称是Flexible static memory controller，叫灵活的静态的存储器控制器， 是STM32F10xx中一个很有特色的外设， 通过FSMC，我们可以扩展内存，如外部的SRAM，NANDFLASH和NORFLASH。但有一点我们要注意的是，FSMC只能扩展静态的内存， 即名称里面的S：static，不能是动态的内存，比如SDRAM就不能扩展。

#### 6.3.3.4. AHB到APB的桥

从AHB总线延伸出来的两条APB2和APB1总线，上面挂载着STM32各种各样的特色外设。我们经常说的GPIO、串口、I2C、SPI这些外设就挂载在这两条总线上， 这个是我们学习STM32的重点，就是要学会编程这些外设去驱动外部的各种设备。

![STM32F10xx系统框图（不包括互联型）](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist005.png)

## 6.4. 存储器映射

在图 [STM32F10xx系统框图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#stm32f10xx) 中，被控单元的FLASH， RAM，FSMC和AHB到APB的桥（即片上外设），这些功能部件共同排列在一个4GB的地址空间内。 我们在编程的时候，可以通过他们的地址找到他们，然后来操作他们（通过C语言对它们进行数据的读和写）。

### 6.4.1. 存储器映射

存储器本身不具有地址信息，它的地址是由芯片厂商或用户分配，给存储器分配地址的过程就称为存储器映射， 具体见图 [存储器映射](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id12) 。如果给存储器再分配一个地址就叫存储器重映射。

![存储器映射（摘自参考手册-存储器映射章节）](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist006.png)

#### 6.4.1.1. 存储器区域功能划分

在这4GB的地址空间中，ARM已经粗线条的平均分成了8个块，每块512MB，每个块也都规定了用途，具体分类见表格 [存储器功能分类](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id14) 。 每个块的大小都有512MB，显然这是非常大的，芯片厂商在每个块的范围内设计各具特色的外设时并不一定都用得完，都是只用了其中的一部分而已。

![存储器功能分类](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist01.png)

在这8个Block里面，有3个块非常重要，也是我们最关心的三个块。Block0用来设计成内部FLASH，Block1用来设计成内部RAM， Block2用来设计成片上的外设，下面我们简单的介绍下这三个Block里面的具体区域的功能划分。

##### 6.4.1.1.1. 存储器Block0内部区域功能划分

Block0主要用于设计片内的FLASH，我们使用的STM32F103ZET6（霸道）和STM32F103VET6（指南者）的FLASH都是512KB， 属于大容量。要在芯片内部集成更大的FLASH或者SRAM都意味着芯片成本的增加，往往片内集成的FLASH都不会太大， ST能在追求性价比的同时做到512KB，实乃良心之举。Block内部区域的功能划分具体见表格 [存储器Block0内部区域功能划分](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id15) 。

![存储器Block0内部区域功能划分](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist02.png)

##### 6.4.1.1.2. 储存器Block1内部区域功能划分

Block1用于设计片内的SRAM。我们使用的STM32F103ZET6（霸道）和STM32F103VET6（指南者）的SRAM都是64KB， Block内部区域的功能划分具体见表格 [存储器Block1内部区域功能划分](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id16) 。

![存储器Block1内部区域功能划分](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist03.png)

##### 6.4.1.1.3. 储存器Block2内部区域功能划分

Block2用于设计片内的外设，根据外设的总线速度不同，Block被分成了APB和AHB两部分，其中APB又被分为APB1和APB2， 具体见表格 [存储器Block2内部区域功能划分](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id17) 。

![存储器Block2内部区域功能划分](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist04.png)

## 6.5. 寄存器映射

我们知道，存储器本身没有地址，给存储器分配地址的过程叫存储器映射，那什么叫寄存器映射？寄存器到底是什么？

在存储器Block2这块区域，设计的是片上外设，它们以四个字节为一个单元，共32bit，每一个单元对应不同的功能， 当我们控制这些单元时就可以驱动外设工作。我们可以找到每个单元的起始地址，然后通过C语言指针的操作方式来访问这些单元， 如果每次都是通过这种地址的方式来访问，不仅不好记忆还容易出错，这时我们可以根据每个单元功能的不同，以功能为名给这个内存单元取一个别名， 这个别名就是我们经常说的寄存器，这个给已经分配好地址的有特定功能的内存单元取别名的过程就叫寄存器映射。

比如，我们找到GPIOB端口的输出数据寄存器ODR的地址是0x40010C0C（至于这个地址如何找到可以先跳过，后面我们会有详细的讲解）， ODR寄存器是32bit，低16bit有效，对应着16个外部IO，写0/1对应的的IO则输出低/高电平。现在我们通过C语言指针的操作方式， 让GPIOB的16个IO都输出高电平，具体见代码清单:寄存器-1。

代码清单:寄存器-1 通过绝对地址访问内存单元[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id19 "永久链接至代码")

|   |   |
|---|---|
|1<br>2|// GPIOB 端口全部输出 高电平<br>*(unsigned int*)(0x4001 0C0C) = 0xFFFF;|

0x4001 0C0C在我们看来是GPIOB端口ODR的地址，但是在编译器看来，这只是一个普通的变量，是一个立即数， 要想让编译器也认为是指针，我们得进行强制类型转换，把它转换成指针， 即(unsigned int *)0x4001 0C0C，然后再对这个指针进行 * 操作。

刚刚我们说了，通过绝对地址访问内存单元不好记忆且容易出错，我们可以通过寄存器的方式来操作，具体见代码清单:寄存器-2。

代码清单:寄存器-2 通过寄存器别名方式访问内存单元[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id20 "永久链接至代码")

|   |   |
|---|---|
|1<br>2<br>3|// GPIOB 端口全部输出 高电平<br>#define GPIOB_ODR                   (unsigned int*)(GPIOB_BASE+0x0C)<br>* GPIOB_ODR = 0xFF;|

为了方便操作，我们干脆把指针操作“*”也定义到寄存器别名里面，具体见代码清单:寄存器-3。

代码清单:寄存器-3 通过寄存器别名访问内存单元[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id21 "永久链接至代码")

|   |   |
|---|---|
|1<br>2<br>3|// GPIOB 端口全部输出 高电平<br>#define GPIOB_ODR                   *(unsigned int*)(GPIOB_BASE+0x0C)<br>GPIOB_ODR = 0xFF;|

### 6.5.1. STM32的外设地址映射

片上外设区分为三条总线，根据外设速度的不同，不同总线挂载着不同的外设，APB1挂载低速外设，APB2和AHB挂载高速外设。 相应总线的最低地址我们称为该总线的基地址，总线基地址也是挂载在该总线上的首个外设的地址。其中APB1总线的地址最低，片上外设从这里开始，也叫外设基地址。

#### 6.5.1.1. 总线基地址
![总线基地址](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist05.png)

表格 [总线基地址](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id24) 的“相对外设基地址偏移”即该总线地址与“片上外设”基地址0x4000 0000的差值。关于地址的偏移我们后面还会讲到。

#### 6.5.1.2. 外设基地址

总线上挂载着各种外设，这些外设也有自己的地址范围，特定外设的首个地址称为“XX外设基地址”，也叫XX外设的边界地址。 具体有关STM32F10xx外设的边界地址请参考《STM32F10xx参考手册》的2.3小节的存储器映射的表1：STM32F10xx 寄存器边界地址。

这里面我们以GPIO这个外设来讲解外设的基地址，GPIO属于高速的外设 ，挂载到APB2总线上，具体见表格 [外设GPIO基地址](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#gpio) 。

![外设GPIO基地址](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist06.png)

#### 6.5.1.3. 外设寄存器

在XX外设的地址范围内，分布着的就是该外设的寄存器。以GPIO外设为例，GPIO是通用输入输出端口的简称， 简单来说就是STM32可控制的引脚，基本功能是控制引脚输出高电平或者低电平。最简单的应用就是把GPIO的引脚连接到LED灯的阴极， LED灯的阳极接电源，然后通过STM32控制该引脚的电平，从而实现控制LED灯的亮灭。

GPIO有很多个寄存器，每一个都有特定的功能。每个寄存器为32bit，占四个字节，在该外设的基地址上按照顺序排列， 寄存器的位置都以相对该外设基地址的偏移地址来描述。这里我们以GPIOB端口为例，来说明GPIO都有哪些寄存器， 具体见表格 [GPIOB端口的寄存器地址列表](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#gpiob) 。

![GPIOB端口的寄存器地址列表](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist07.png)

有关外设的寄存器说明可参考《STM32F10xx参考手册》中具体章节的寄存器描述部分，在编程的时候我们需要反复的查阅外设的寄存器说明。

这里我们以“GPIO端口置位/复位寄存器”为例，教大家如何理解寄存器的说明， 具体见图 [GPIO端口置位_复位寄存器说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id27) 。

![GPIO端口置位_复位寄存器说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist007.png)

- ①名称
    
    > 寄存器说明中首先列出了该寄存器中的名称，“(GPIOx_BSRR)(x=A…E)”这段的意思是该寄存器名为“GPIOx_BSRR”其中的“x”可以为A-E， 也就是说这个寄存器说明适用于GPIOA、GPIOB至GPIOE，这些GPIO端口都有这样的一个寄存器。
    
- ②偏移地址
    
    > 偏移地址是指本寄存器相对于这个外设的基地址的偏移。本寄存器的偏移地址是0x10， 从参考手册中我们可以查到GPIOA外设的基地址为0x4001 0800 ， 我们就可以算出GPIOA的这个GPIOA_BSRR寄存器的地址为：0x4001 0800+0x10；同理， 由于GPIOB的外设基地址为0x4001 0C00， 可算出GPIOB_BSRR寄存器的地址为：0x4001 0C00+0x10 。其他GPIO端口以此类推即可。
    
- ③寄存器位表
    
    > 紧接着的是本寄存器的位表，表中列出它的0-31位的名称及权限。表上方的数字为位编号，中间为位名称，最下方为读写权限，其中w表示只写， r表示只读，rw表示可读写。本寄存器中的位权限都是w，所以只能写，如果读本寄存器，是无法保证读取到它真正内容的。而有的寄存器位只读， 一般是用于表示STM32外设的某种工作状态的，由STM32硬件自动更改，程序通过读取那些寄存器位来判断外设的工作状态。
    
- ④位功能说明
    
    > 位功能是寄存器说明中最重要的部分，它详细介绍了寄存器每一个位的功能。例如本寄存器中有两种寄存器位，分别为BRy及BSy， 其中的y数值可以是0-15，这里的0-15表示端口的引脚号，如BR0、BS0用于控制GPIOx的第0个引脚，若x表示GPIOA，那就是控制GPIOA的第0引脚， 而BR1、BS1就是控制GPIOA第1个引脚。
    > 
    > 其中BRy引脚的说明是“0：不会对相应的ODRx位执行任何操作；1：对相应ODRx位进行复位”。这里的“复位”是将该位设置为0的意思， 而“置位”表示将该位设置为1；说明中的ODRx是另一个寄存器的寄存器位，我们只需要知道ODRx位为1的时候，对应的引脚x输出高电平， 为0的时候对应的引脚输出低电平即可(感兴趣的读者可以查询该寄存器GPIOx_ODR的说明了解)。所以，如果对BR0写入“1”的话， 那么GPIOx的第0个引脚就会输出“低电平”，但是对BR0写入“0”的话，却不会影响ODR0位，所以引脚电平不会改变。要想该引脚输出“高电平”， 就需要对“BS0”位写入“1”，寄存器位BSy与BRy是相反的操作。
    

### 6.5.2. C语言对寄存器的封装
以上所有的关于存储器映射的内容，最终都是为大家更好地理解如何用C语言控制读写外设寄存器做准备，此处是本章的重点内容。

#### 6.5.2.1. 封装总线和外设基地址

在编程上为了方便理解和记忆，我们把总线基地址和外设基地址都以相应的宏定义起来，总线或者外设都以他们的名字作为宏名， 具体见 [代码清单:寄存器-4](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id29) 。

代码清单:寄存器-4 总线和外设基址宏定义[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id29 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27|/* 外设基地址 */<br>#define PERIPH_BASE           ((unsigned int)0x40000000)<br><br>/* 总线基地址 */<br>#define APB1PERIPH_BASE       PERIPH_BASE<br>#define APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000)<br>#define AHBPERIPH_BASE        (PERIPH_BASE + 0x00020000)<br><br>/* GPIO外设基地址 */<br>#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)<br>#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)<br>#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)<br>#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)<br>#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)<br>#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)<br>#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)<br><br>/* 寄存器基地址，以GPIOB为例 */<br>#define GPIOB_CRL             (GPIOB_BASE+0x00)<br>#define GPIOB_CRH             (GPIOB_BASE+0x04)<br>#define GPIOB_IDR             (GPIOB_BASE+0x08)<br>#define GPIOB_ODR             (GPIOB_BASE+0x0C)<br>#define GPIOB_BSRR            (GPIOB_BASE+0x10)<br>#define GPIOB_BRR             (GPIOB_BASE+0x14)<br>#define GPIOB_LCKR            (GPIOB_BASE+0x18)|

[代码清单:寄存器-4](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id29) 首先定义了 “片上外设”基地址PERIPH_BASE，接着在PERIPH_BASE上加入各个总线的地址偏移， 得到APB1、APB2总线的地址APB1PERIPH_BASE、APB2PERIPH_BASE，在其之上加入外设地址的偏移，得到GPIOA-G的外设地址， 最后在外设地址上加入各寄存器的地址偏移，得到特定寄存器的地址。一旦有了具体地址，就可以用指针读写， 具体见 [代码清单:寄存器-5](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id30) 。

代码清单:寄存器-5 使用指针控制BSRR寄存器[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id30 "永久链接至代码")

|   |   |
|---|---|
|1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9|/* 控制GPIOB 引脚0输出低电平(BSRR寄存器的BR0置1) */<br>*(unsigned int *)GPIOB_BSRR = (0x01<<(16+0));<br><br>/* 控制GPIOB 引脚0输出高电平(BSRR寄存器的BS0置1) */<br>*(unsigned int *)GPIOB_BSRR = 0x01<<0;<br><br>unsigned int temp;<br>/* 读取GPIOB 端口所有引脚的电平(读IDR寄存器) */<br>temp = *(unsigned int *)GPIOB_IDR;|

该代码使用 (unsigned int *) 把GPIOB_BSRR宏的数值强制转换成了地址，然后再用“*”号做取指针操作，对该地址的赋值， 从而实现了写寄存器的功能。同样，读寄存器也是用取指针操作，把寄存器中的数据取到变量里，从而获取STM32外设的状态。

#### 6.5.2.2. 封装寄存器列表

用上面的方法去定义地址，还是稍显繁琐，例如GPIOA-GPIOE都各有一组功能相同的寄存器，如GPIOA_ODR/GPIOB_ODR/GPIOC_ODR等等， 它们只是地址不一样，但却要为每个寄存器都定义它的地址。为了更方便地访问寄存器，我们引入C语言中的结构体语法对寄存器进行封装， 具体见 [代码清单:寄存器-6](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id32) 。

代码清单:寄存器-6 使用结构体对GPIO寄存器组的封装[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id32 "永久链接至代码")

|                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13 | typedef unsigned           int uint32_t; /*无符号32位变量*/<br>typedef unsigned short     int uint16_t; /*无符号16位变量*/<br><br>/* GPIO寄存器列表 */<br>typedef struct {<br>    uint32_t CRL;     /*GPIO端口配置低寄存器    地址偏移: 0x00 */<br>    uint32_t CRH;     /*GPIO端口配置高寄存器    地址偏移: 0x04 */<br>    uint32_t IDR;     /*GPIO数据输入寄存器      地址偏移: 0x08 */<br>    uint32_t ODR;     /*GPIO数据输出寄存器      地址偏移: 0x0C */<br>    uint32_t BSRR;    /*GPIO位设置/清除寄存器   地址偏移: 0x10 */<br>    uint32_t BRR;     /*GPIO端口位清除寄存器     地址偏移: 0x14 */<br>    uint16_t LCKR;    /*GPIO端口配置锁定寄存器   地址偏移: 0x18 */<br>} GPIO_TypeDef; |

这段代码用typedef 关键字声明了名为GPIO_TypeDef的结构体类型，结构体内有7个 成员变量，变量名正好对应寄存器的名字。 C语言的语法规定，结构体内变量的存储空间是连续的，其中32位的变量占用4个字节，16位的变量占用2个字节， 具体见图 [GPIO_TypeDef结构体成员的地址偏移](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#gpio-typedef) 。

![GPIO_TypeDef结构体成员的地址偏移](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/regist008.png)

也就是说，我们定义的这个GPIO_TypeDef ，假如这个结构体的首地址为0x4001 0C00（这也是第一个成员变量CRL的地址）， 那么结构体中第二个成员变量CRH的地址即为0x4001 0C00 +0x04 ，加上的这个0x04，正是代表CRL所占用的4个字节地址的偏移量， 其它成员变量相对于结构体首地址的偏移，在上述代码右侧注释已给。

这样的地址偏移与STM32 GPIO外设定义的寄存器地址偏移一一对应，只要给结构体设置好首地址，就能把结构体内成员的地址确定下来， 然后就能以结构体的形式访问寄存器，具体见 [代码清单:寄存器-7](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id33) 。

代码清单:寄存器-7 通过结构体指针访问寄存器[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id33 "永久链接至代码")

|   |   |
|---|---|
|1<br>2<br>3<br>4<br>5<br>6<br>7<br>8|GPIO_TypeDef * GPIOx;      //定义一个GPIO_TypeDef型结构体指针GPIOx<br>GPIOx = GPIOB_BASE;        //把指针地址设置为宏GPIOB_BASE地址<br>GPIOx->IDR = 0xFFFF;<br>GPIOx->ODR = 0xFFFF;<br><br>uint32_t temp;<br>temp = GPIOx->IDR;          //读取GPIOB_IDR寄存器的值到变量temp中|

这段代码先用GPIO_TypeDef类型定义一个结构体指针GPIOx，并让指针指向地址GPIOB_BASE(0x4001 0C00)，使用地址确定下来， 然后根据C语言访问结构体的语法，用GPIOx->ODR及GPIOx->IDR等方式读写寄存器。

最后，我们更进一步，直接使用宏定义好GPIO_TypeDef类型的指针，而且指针指向各个GPIO端口的首地址， 使用时我们直接用该宏访问寄存器即可，具体 [代码清单:寄存器-8](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id34) 。

代码清单:寄存器-8 定义好GPIO端口首地址址针[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id34 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28|/*使用GPIO_TypeDef把地址强制转换成指针*/<br>#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)<br>#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)<br>#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)<br>#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)<br>#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)<br>#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)<br>#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)<br>#define GPIOH               ((GPIO_TypeDef *) GPIOH_BASE)<br><br>/*使用定义好的宏直接访问*/<br>/*访问GPIOB端口的寄存器*/<br>GPIOB->BSRR = 0xFFFF;       //通过指针访问并修改GPIOB_BSRR寄存器<br>GPIOB->CRL = 0xFFFF;        //修改GPIOB_CRL寄存器<br>GPIOB->ODR =0xFFFF;         //修改GPIOB_ODR寄存器<br><br>uint32_t temp;<br>temp = GPIOB->IDR;          //读取GPIOB_IDR寄存器的值到变量temp中<br><br>/*访问GPIOA端口的寄存器*/<br>GPIOA->BSRR = 0xFFFF;<br>GPIOA->CRL = 0xFFFF;<br>GPIOA->ODR =0xFFFF;<br><br>uint32_t temp;<br>temp = GPIOA->IDR;          //读取GPIOA_IDR寄存器的值到变量temp中|

这里我们仅是以GPIO这个外设为例，给大家讲解了C语言对寄存器的封装。以此类推，其他外设也同样可以用这种方法来封装。好消息是， 这部分工作都由固件库帮我们完成了，这里我们只是分析了下这个封装的过程，让大家知其然，也只其所以然。

### 6.5.3. 修改寄存器的位操作方法

使用C语言对寄存器赋值时，我们常常要求只修改该寄存器的某几位的值，且其它的寄存器位不变，这个时候我们就需要用到C语言的位操作方法了。

#### 6.5.3.1. 把变量的某位清零

此处我们以变量a代表寄存器，并假设寄存器中本来已有数值，此时我们需要把变量a的某一位清零，且其它位不变， 方法见 [代码清单:寄存器-9](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id37) 。

代码清单:寄存器-9 对某位清零[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id37 "永久链接至代码")

```c
//定义一个变量a = 1001 1111 b (二进制数)
unsigned char a = 0x9f;

//对bit2 清零

a &= ~(1<<2);

//括号中的1左移两位，(1<<2)得二进制数：0000 0100 b
//按位取反，~(1<<2)得1111 1011 b
//假如a中原来的值为二进制数： a = 1001 1111 b
//所得的数与a作”位与&”运算，a = (1001 1111 b)&(1111 1011 b),
//经过运算后，a的值 a=1001 1011 b
// a的bit2 位被清零，而其它位不变。
```

#### 6.5.3.2. 把变量的某几个连续位清零

由于寄存器中有时会有连续几个寄存器位用于控制某个功能，现假设我们需要把寄存器的某几个连续位清零， 且其它位不变，方法见 [代码清单:寄存器-10](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id39) 。

代码清单:寄存器-10 对某几个连续位清零[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id39 "永久链接至代码")

```c
//若把a中的二进制位分成2个一组
//即bit0、bit1为第0组，bit2、bit3为第1组，
//  bit4、bit5为第2组，bit6、bit7为第3组
//要对第1组的bit2、bit3清零

a &= ~(3<<2*1);

//括号中的3左移两位，(3<<2*1)得二进制数：0000 1100 b
//按位取反，~(3<<2*1)得1111 0011 b
//假如a中原来的值为二进制数： a = 1001 1111 b
//所得的数与a作”位与&”运算，a = (1001 1111 b)&(1111 0011 b),
//经过运算后，a的值 a=1001 0011 b
// a的第1组的bit2、bit3被清零，而其它位不变。

//上述(~(3<<2*1))中的(1)即为组编号;如清零第3组bit6、bit7此处应为3
//括号中的(2)为每组的位数，每组有2个二进制位;若分成4个一组，此处即为4
//括号中的(3)是组内所有位都为1时的值;若分成4个一组，此处即为二进制数“1111 b”

//例如对第2组bit4、bit5清零
a &= ~(3<<2*2);
```

#### 6.5.3.3. 对变量的某几位进行赋值。

寄存器位经过上面的清零操作后，接下来就可以方便地对某几位写入所需要的数值了，且其它位不变， 方法见 [代码清单:寄存器-11](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id41) ，这时候写入的数值一般就是需要设置寄存器的位参数。

代码清单:寄存器-11 对某几位进行赋值[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id41 "永久链接至代码")

|   |   |
|---|---|
|1<br>2<br>3<br>4<br>5|//a = 1000 0011 b<br>//此时对清零后的第2组bit4、bit5设置成二进制数“01 b ”<br><br>a \|= (1<<2*2);<br>//a = 1001 0011 b，成功设置了第2组的值，其它组不变|

#### 6.5.3.4. 对变量的某位取反

某些情况下，我们需要对寄存器的某个位进行取反操作，即 1变0 ，0变1，这可以直接用如下操作，其它位不变， 见 [代码清单:寄存器-12](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id43) 。

代码清单:寄存器-12 对某位进行取反操作[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/register.html#id43 "永久链接至代码")

|   |   |
|---|---|
|1<br>2<br>3<br>4<br>5|//a = 1001 0011 b<br>//把bit6取反，其它位不变<br><br>a ^=(1<<6);<br>//a = 1101 0011 b|

关于修改寄存器位的这些操作，在下一章中有应用实例代码，可配合阅读。



# 7. 新建工程—寄存器版

本章内容所涉及的软件只供教学使用，不得用于商业用途。个人或公司因商业用途导致的法律责任，后果自负。

版本说明：MDK5.15，如果有更高的版本可使用高版本。

版本号可从MDK软件的“Help–>About uVision”选项中查询到。

## 7.1. 新建工程

### 7.1.1. 新建本地工程文件夹

为了工程目录更加清晰，我们在本地电脑上新建1个文件夹用于存放整个工程，如命名为“LED”，然后在该目录下新建2个文件夹，具体如下：

![工程目录文件夹清单](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro016.png)![工程文件夹目录](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro002.jpeg)

在本地新建好文件夹后，在文件夹下新建一些文件：

![工程目录文件夹内容清单](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro021.png)

### 7.1.2. 新建工程

打开KEIL5，新建一个工程，工程名根据喜好命名，我这里取LED-REG，直接保存在LED文件夹下。

![在KEIL5中新建工程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro0031.jpeg)

#### 7.1.2.1. 选择CPU型号

这个根据你开发板使用的CPU具体的型号来选择，F103-“指南者”选STM32F103VE型号。如果这里没有出现你想要的CPU型号， 或者一个型号都没有，那么肯定是你的KEIL5没有添加device库，KEIL5不像KEIL4那样自带了很多MCU的型号， KEIL5需要自己添加，关于如何添加请参考《如何安装KEIL5》这一章。

![选择具体的CPU型号](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro0041.png)

#### 7.1.2.2. 在线添加库文件

用寄存器控制STM32时我们不需要在线添加库文件，这里我们点击关掉。

![库文件管理](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro0051.png)

#### 7.1.2.3. 添加文件

在新建的工程中添加文件，文件从本地建好的工程文件夹下获取，双击组文件夹就会出现添加文件的路径，然后选择文件即可。我们对要添加的三个文件说明如下：

- **startup_stm32f10x_hd.s**
    

启动文件，系统上电后第一个运行的程序，由汇编编写，C编程用的比较少，可暂时不管，这个文件从固件库里面拷贝而来，由官方提供。 文件在这个目录： STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport \ST\STM32F10x\startup\arm\startup_stm32f10x_hd.s。

- **stm32f10x.h**
    

用户手动新建，用于存放寄存器映射的代码，暂时为空。

**提示：** 在正式使用官方固件库之前，这里的stm32f10x.h是用户手动新建的一个文本和改后缀名.h，并非是从官方固件库中的文件。

- **main.c**
    

用户手动新建，用于存放main函数，暂时为空。

![如何在工程中添加文件](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro0061.png)

#### 7.1.2.4. 配置魔术棒选项卡

这一步的配置工作很重要，很多人串口用不了printf函数，编译有问题，下载有问题，都是这个步骤的配置出了错。

1. Target中选中微库“ Use MicroLib”，为的是在日后编写串口驱动的时候可以使用printf函数。
    

![添加微库](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro007.jpeg)

b. Output选项卡中把输出文件夹定位到我们工程目录下的output文件夹， 如果想在编译的过程中生成hex文件，那么那Create HEX File选项勾上。

![配置Output选项卡](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro008.jpeg)

3. 在Listing选项卡中把输出文件夹定位到我们工程目录下的Listing文件夹。
    

![配置Listing选项卡](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro0091.png)

#### 7.1.2.5. 下载器配置

在仿真器连接好电脑和开发板且开发板供电正常的情况下，打开编译软件KEIL，在魔术棒选项卡里面选择仿真器的型号，具体过程看图示：

Debug选项配置

![Debug选择CMSIS-DAP Debugger](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro0101.png)

Utilities选项配置

![Utilities选择 Use Debug Driver](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro0111.png)

Debug Settings 选项配置

![Debug Settings 选项配置](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro0121.png)

选择目标板，具体选择多大的FLASH要根据板子上的芯片型号决定。F103-“指南者”选512K。 这里面有个小技巧就是把Reset and Run也勾选上，这样程序下载完之后就会自动运行，否则需要手动复位。 擦除的FLASH大小选择Sectors即可，不要选择Full Chip，不然下载会比较慢。

![选择目标板](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro0131.png)

## 7.2. 下载程序

如果前面步骤都成功了，接下来就可以把编译好的程序下载到开发板上运行。下载程序不需要其他额外的软件，直接点击KEIL中的LOAD按钮即可。

![下载程序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro0141.png)

程序下载后，Build Output选项卡如果打印出 Application running…则表示程序下载成功。如果没有出现实验现象，按复位键试试。 当然，这只是一个工程模版，我们还没写程序，开发板不会有任何现象。

至此，一个新的工程模版新建完毕。



# 8. 使用寄存器点亮LED灯

本章参考资料：《STM32F10X-中文参考手册》GPIO和RCC章节。

学习本章时，配合《STM32F10X-中文参考手册》 “通用I/O(GPIO)”章节一起阅读，效果会更佳， 特别是涉及到寄存器说明的部分。关于建立工程时使用KEIL5的基本操作，请参考前面的章节。

## 8.1. GPIO简介

GPIO是通用输入输出端口的简称，简单来说就是STM32可控制的引脚，STM32芯片的GPIO引脚与外部设备连接起来，从而实现与外部通讯、 控制以及数据采集的功能。STM32芯片的GPIO被分成很多组，每组有16个引脚，如型号为STM32F103VET6型号的芯片有GPIOA、GPIOB、 GPIOC至GPIOE共5组GPIO，芯片一共100个引脚，其中GPIO就占了一大部分，所有的GPIO引脚都有基本的输入输出功能。

最基本的输出功能是由STM32控制引脚输出高、低电平，实现开关控制，如把GPIO引脚接入到LED灯，那就可以控制LED灯的亮灭， 引脚接入到继电器或三极管，那就可以通过继电器或三极管控制外部大功率电路的通断。

最基本的输入功能是检测外部输入电平，如把GPIO引脚连接到按键，通过电平高低区分按键是否被按下。

## 8.2. GPIO框图剖析

![GPIO结构框图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LEDreg002.png)

通过GPIO硬件结构框图，就可以从整体上深入了解GPIO外设及它的各种应用模式。该图从最右端看起，最右端就是代表STM32芯片引出的GPIO引脚，其余部件都位于芯片内部。

### 8.2.1. 基本结构分析

下面我们按图中的编号对GPIO端口的结构部件进行说明。

#### 8.2.1.1. 保护二极管及上、下拉电阻

引脚的两个保护二级管可以防止引脚外部过高或过低的电压输入，当引脚电压高于VDD时， 上方的二极管导通，当引脚电压低于VSS时，下方的二极管导通，防止不正常电压引入芯片导致芯片烧毁。 尽管有这样的保护，并不意味着STM32的引脚能直接外接大功率驱动器件，如直接驱动电机，强制驱动要么电机不转，要么导致芯片烧坏，必须要加大功率及隔离电路驱动。

#### 8.2.1.2. P-MOS管和N-MOS管

GPIO引脚线路经过两个保护二极管后，向上流向“输入模式”结构，向下流向“输出模式”结构。先看输出模式部分，线路经过一个由P-MOS和N-MOS管组成的单元电路。 这个结构使GPIO具有了“推挽输出”和“开漏输出”两种模式。

所谓的推挽输出模式，是根据这两个MOS管的工作方式来命名的。在该结构中输入高电平时，经过反向后，上方的P-MOS导通，下方的N-MOS关闭， 对外输出高电平；而在该结构中输入低电平时，经过反向后，N-MOS管导通，P-MOS关闭，对外输出低电平。当引脚高低电平切换时，两个管子轮流导通， P管负责灌电流，N管负责拉电流，使其负载能力和开关速度都比普通的方式有很大的提高。推挽输出的低电平为0伏，高电平为3.3伏， 具体参考图 [推挽等效电路](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#id5) ，它是推挽输出模式时的等效电路。

![推挽等效电路](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LEDreg003.png)

而在开漏输出模式时，上方的P-MOS管完全不工作。如果我们控制输出为0，低电平，则P-MOS管关闭，N-MOS管导通，使输出接地， 若控制输出为1 (它无法直接输出高电平)时，则P-MOS管和N-MOS管都关闭，所以引脚既不输出高电平，也不输出低电平，为高阻态。 为正常使用时必须外部接上拉电阻，参考图 [开漏电路](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#id6) 中等效电路。它具有“线与”特性，也就是说，若有很多个开漏模式引脚连接到一起时， 只有当所有引脚都输出高阻态，才由上拉电阻提供高电平，此高电平的电压为外部上拉电阻所接的电源的电压。若其中一个引脚为低电平， 那线路就相当于短路接地，使得整条线路都为低电平，0伏。

推挽输出模式一般应用在输出电平为0和3.3伏而且需要高速切换开关状态的场合。在STM32的应用中，除了必须用开漏模式的场合，我们都习惯使用推挽输出模式。

开漏输出一般应用在I2C、SMBUS通讯等需要“线与”功能的总线电路中。除此之外，还用在电平不匹配的场合，如需要输出5伏的高电平， 就可以在外部接一个上拉电阻，上拉电源为5伏，并且把GPIO设置为开漏模式，当输出高阻态时，由上拉电阻和电源向外输出5伏的电平， 具体见图 [STM32_IO对外输出5V电平](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#stm32-io5v) 。

![开漏电路](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LEDreg004.png)![STM32_IO对外输出5V电平](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LEDreg005.png)

#### 8.2.1.3. 输出数据寄存器

前面提到的双MOS管结构电路的输入信号，是由GPIO“输出数据寄存器GPIOx_ODR”提供的，因此我们通过修改输出数据寄存器的值就可以修改GPIO引脚的输出电平。 而“置位/复位寄存器GPIOx_BSRR”可以通过修改输出数据寄存器的值从而影响电路的输出。

#### 8.2.1.4. 复用功能输出

“复用功能输出”中的“复用”是指STM32的其它片上外设对GPIO引脚进行控制，此时GPIO引脚用作该外设功能的一部分，算是第二用途。 从其它外设引出来的“复用功能输出信号”与GPIO本身的数据据寄存器都连接到双MOS管结构的输入中，通过图中的梯形结构作为开关切换选择。

例如我们使用USART串口通讯时，需要用到某个GPIO引脚作为通讯发送引脚，这个时候就可以把该GPIO引脚配置成USART串口复用功能，由串口外设控制该引脚，发送数据。

// GPIOB 16个IO全部输出 0XFFFF
GPIOB->ODR = 0XFFFF;

#### 8.2.1.5. 输入数据寄存器

看GPIO结构框图的上半部分，GPIO引脚经过内部的上、下拉电阻，可以配置成上/下拉输入，然后再连接到施密特触发器，信号经过触发器后， 模拟信号转化为0、1的数字信号，然后存储在“输入数据寄存器GPIOx_IDR”中，通过读取该寄存器就可以了解GPIO引脚的电平状态。

// 读取GPIOB端口的16位数据值
uint16_t temp;
temp = GPIOB->IDR;

#### 8.2.1.6. 复用功能输入
与“复用功能输出”模式类似，在“复用功能输入模式”时，GPIO引脚的信号传输到STM32其它片上外设，由该外设读取引脚状态。

同样，如我们使用USART串口通讯时，需要用到某个GPIO引脚作为通讯接收引脚，这个时候就可以把该GPIO引脚配置成USART串口复用功能，使USART可以通过该通讯引脚的接收远端数据。

#### 8.2.1.7. 模拟输入输出

当GPIO引脚用于ADC采集电压的输入通道时，用作“模拟输入”功能，此时信号是不经过施密特触发器的，因为经过施密特触发器后信号只有0、1两种状态， 所以ADC外设要采集到原始的模拟信号，信号源输入必须在施密特触发器之前。类似地，当GPIO引脚用于DAC作为模拟电压输出通道时，此时作为“模拟输出”功能， DAC的模拟信号输出就不经过双MOS管结构，模拟信号直接输出到引脚。

### 8.2.2. GPIO工作模式

总结一下，由GPIO的结构决定了GPIO可以配置成以下模式：

代码清单:点亮LED-1 GPIO 8种工作模式[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-1 "永久链接至代码")

```c
typedef enum
{
    GPIO_Mode_AIN = 0x0,           // 模拟输入
    GPIO_Mode_IN_FLOATING = 0x04,  // 浮空输入
    GPIO_Mode_IPD = 0x28,          // 下拉输入
    GPIO_Mode_IPU = 0x48,          // 上拉输入
    GPIO_Mode_Out_OD = 0x14,       // 开漏输出
    GPIO_Mode_Out_PP = 0x10,       // 推挽输出
    GPIO_Mode_AF_OD = 0x1C,        // 复用开漏输出
    GPIO_Mode_AF_PP = 0x18         // 复用推挽输出
} GPIOMode_TypeDef;
```

在固件库中，GPIO总共有8种细分的工作模式，稍加整理可以大致归类为以下三类：

#### 8.2.2.1. 输入模式(模拟/浮空/上拉/下拉)

在输入模式时，施密特触发器打开，输出被禁止，可通过输入数据寄存器GPIOx_IDR读取I/O状态。其中输入模式，可设置为上拉、 下拉、浮空和模拟输入四种。

上拉和下拉输入很好理解，默认的电平由上拉或者下拉决定。浮空输入的电平是不确定的，完全由外部的输入决定， **一般接按键的时候用的是这个模式**。**模拟输入则用于ADC采集**。

>**总结**：确定、不确定电平、采集输入


#### 8.2.2.2. 输出模式(推挽/开漏)

在输出模式中，推挽模式时双MOS管以轮流方式工作，输出数据寄存器GPIOx_ODR可控制I/O输出高低电平。

开漏模式时，只有N-MOS管工作， 输出数据寄存器可控制I/O输出高阻态或低电平。输出速度可配置，有2MHz10MHz50MHz的选项。此处的输出速度即I/O支持的高低电平状态最高切换频率， 支持的频率越高，功耗越大，如果功耗要求不严格，把速度设置成最大即可。

在输出模式时施密特触发器是打开的，即输入可用，通过输入数据寄存器GPIOx_IDR可读取I/O的实际状态。

#### 8.2.2.3. 复用功能(推挽/开漏)

复用功能模式中，输出使能，输出速度可配置，可工作在开漏及推挽模式，但是输出信号源于其它外设，输出数据寄存器GPIOx_ODR无效； 输入可用，通过输入数据寄存器可获取I/O实际状态，但一般直接用外设的寄存器来获取该数据信号。

通过对GPIO寄存器写入不同的参数，就可以改变GPIO的工作模式，再强调一下， 要了解具体寄存器时一定要查阅《STM32F10X-中文参考手册》中对应外设的寄存器说明。在GPIO外设中， 控制端口高低控制寄存器CRH和CRL可以配置每个GPIO的工作模式和工作的速度，每4个位控制一个IO， CRH控制端口的高八位，CRL控制端口的低8位，具体的看CRH和CRL的寄存器描述。


![GPIO端口配置低寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LEDreg006.png)![GPIO端口配置高寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LEDreg007.png)

## 8.3. 实验：使用寄存器点亮LED灯

本小节中，我们以实例讲解如何通过控制寄存器来点亮LED灯。此处侧重于讲解原理，请直接用KEIL5软件打开我们提供的实验例程配合阅读， 先了解原理，学习完本小节后，再尝试自己建立一个同样的工程。本节配套例程名称为“GPIO输出—使用寄存器点亮LED灯”， 在工程目录下找到后缀为“.uvprojx”的文件，用KEIL5打开即可。

自己尝试新建工程时，请对照查阅《新建工程— 寄存器版》章节。若没有安装KEIL5软件，请参考《如何安装KEIL5》章节。

打开该工程，见图 [工程文件结构](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#id19) ，可看到一共有三个文件，分别startup_stm32f10x_hd.s 、 stm32f10x.h 以及main.c，下面我们对这三个文件进行讲解。

![工程文件结构](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LEDreg008.jpg)

### 8.3.1. 硬件连接

在本教程中STM32芯片与LED灯的连接见图 [LED灯电路连接图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#id21) ， 这是一个RGB灯，里面由红蓝绿三个小灯构成，使用PWM控制时可以混合成256不同的颜色。

![LED灯电路连接图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LEDreg009.png)

图中从3个LED灯的阳极引出连接到3.3V电源，阴极各经过1个限流电阻引入至STM32的3个GPIO引脚中，所以我们只要控制这三个引脚输出高低电平， 即可控制其所连接LED灯的亮灭。如果您的实验板STM32连接到LED灯的引脚或极性不一样，只需要修改程序到对应的GPIO引脚即可，工作原理都是一样的。

我们的目标是把GPIO的引脚设置成推挽输出模式并且默认下拉，输出低电平，这样就能让LED灯亮起来了。

### 8.3.2. 启动文件

启动文件在这里只是简要的介绍下，关于这个文件的详解请参考后面的《启动文件详解》章节。

名为“startup_stm32f10x_hd.s”的文件，它里边使用汇编语言写好了基本程序，当STM32芯片上电启动的时候，首先会执行这里的汇编程序， 从而建立起C语言的运行环境，所以我们把这个文件称为启动文件。该文件使用的汇编指令是Cortex-M3内核支持的指令， 可参考《Cortex-M3权威指南》中指令集章节。

startup_stm32f10x_hd.s文件由官方提供，一般有需要也是在官方的基础上修改，不会自己完全重写。该文件从 ST 固件库里面找到， 找到该文件后把启动文件添加到工程里面即可。不同型号的芯片以及不同编译环境下使用的汇编文件是不一样的，但功能相同。

对于启动文件这部分我们主要总结它的功能，不详解讲解里面的代码，其功能如下：

> - 初始化堆栈指针SP;
>     
> - 初始化程序计数器指针PC;
>     
> - 设置堆、栈的大小;
>     
> - 初始化中断向量表;
>     
> - 配置外部SRAM作为数据存储器（这个由用户配置，一般的开发板可没有外部SRAM）;
>     
> - 调用SystemIni() 函数配置STM32的系统时钟。
>     
> - 设置C库的分支入口“__main”（最终用来调用main函数）;
>     

先去除繁枝细节，挑重点的讲，主要理解最后两点，在启动文件中有一段复位后立即执行的程序，代码见 [代码清单:点亮LED-2](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-2) 。 在实际工程中阅读时，可使用编辑器的搜索(Ctrl+F)功能查找这段代码在文件中的位置，搜索Reset_Handler即可找到。

代码清单:点亮LED-2复位后执行的程序[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-2 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11|;Reset handler<br>Reset_Handler    PROC<br>                EXPORT  Reset_Handler     [WEAK]<br>    IMPORT  SystemInit<br>    IMPORT  __main<br><br>        LDR     R0, =SystemInit<br>        BLX     R0<br>        LDR     R0, =__main<br>        BX      R0<br>        ENDP|

开头的是程序注释，在汇编里面注释用的是“;”，相当于 C 语言的“//”注释符

第二行是定义了一个子程序：Reset_Handler。PROC 是子程序定义伪指令。这里就相当于C语言里定义了一个函数，函数名为Reset_Handler。

第三行 EXPORT 表示 Reset_Handler 这个子程序可供其他模块调用。相当于C语言的函数声明。关键字[WEAK] 表示弱定义， 如果编译器发现在别处定义了同名的函数，则在链接时用别处的地址进行链接，如果其它地方没有定义，编译器也不报错，以此处地址进行链接。

第四行和第五行 IMPORT 说明 SystemInit 和__main 这两个标号在其他文件，在链接的时候需要到其他文件去寻找。 相当于C语言中，从其它文件引入函数声明。以便下面对外部函数进行调用。

SystemInit 需要由我们自己实现，即我们要编写一个具有该名称的函数，用来初始化 STM32 芯片的时钟，一般包括初始化AHB、APB等各总线的时钟， 需要经过一系列的配置STM32才能达到稳定运行的状态。其实这个函数在固件库里面有提供，官方已经为我们写好。

__main 其实不是我们定义的(不要与C语言中的main函数混淆)，这是一个C库函数，当编译器编译时，只要遇到这个标号就会定义这个函数， 该函数的主要功能是：负责初始化栈、堆，配置系统环境，并在函数的最后调用用户编写的 main 函数，从此来到 C 的世界。

第六行把 SystemInit 的地址加载到寄存器 R0。

第七行程序跳转到 R0 中的地址执行程序，即执行SystemInit函数的内容。

第八行把__main 的地址加载到寄存器 R0。

第九行程序跳转到 R0 中的地址执行程序，即执行__main函数，执行完毕之后就去到我们熟知的 C 世界，进入main函数。

第十行表示子程序的结束。

总之，看完这段代码后，了解到如下内容即可：我们需要在外部定义一个SystemInit函数设置STM32的时钟；STM32上电后，会执行SystemInit函数，最后执行我们C语言中的main函数。

### 8.3.3. stm32f10x.h文件

看完启动文件，那我们立即写SystemInit和main函数吧？别着急，定义好了SystemInit函数和main我们又能写什么内容？连接LED灯的GPIO引脚， 是要通过读写寄存器来控制的，就这样空着手，如何控制寄存器。我们知道寄存器就是给一个已经分配好地址的特殊的内存空间取的一个别名， 这个特殊的内存空间可以通过指针来操作。在编程之前我们要先实现寄存器映射，有关寄存器映射的代码都统一写在stm32f10x.h文件中， 见 [代码清单:点亮LED-2](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-2) 。

代码清单:点亮LED-3 外设地址定义[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-3 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24|/*片上外设基地址  */<br>#define PERIPH_BASE         ((unsigned int)0x40000000)<br><br>/*总线基地址，GPIO都挂载到APB2上 */<br>#define APB2PERIPH_BASE     (PERIPH_BASE + 0x10000)<br>/* AHB总线基地址 */<br>#define AHBPERIPH_BASE      (PERIPH_BASE + 0x20000)<br><br>/*GPIOB外设基地址*/<br>#define GPIOB_BASE          (APB2PERIPH_BASE + 0x0C00)<br><br>/* GPIOB寄存器地址,强制转换成指针 */<br>#define GPIOB_CRL           *(unsigned int*)(GPIOB_BASE+0x00)<br>#define GPIOB_CRH           *(unsigned int*)(GPIOB_BASE+0x04)<br>#define GPIOB_IDR           *(unsigned int*)(GPIOB_BASE+0x08)<br>#define GPIOB_ODR           *(unsigned int*)(GPIOB_BASE+0x0C)<br>#define GPIOB_BSRR          *(unsigned int*)(GPIOB_BASE+0x10)<br>#define GPIOB_BRR           *(unsigned int*)(GPIOB_BASE+0x14)<br>#define GPIOB_LCKR          *(unsigned int*)(GPIOB_BASE+0x18)<br><br>/*RCC外设基地址*/<br>#define RCC_BASE           (AHBPERIPH_BASE + 0x1000)<br>/*RCC的AHB1时钟使能寄存器地址,强制转换成指针*/<br>#define RCC_APB2ENR        *(unsigned int*)(RCC_BASE+0x18)|

GPIO外设的地址跟前面章节讲解的相同，不过此处把寄存器的地址值都直接强制转换成了指针，方便使用。 代码的最后两段是RCC外设寄存器的地址定义，RCC外设是用来设置时钟的，以后我们会详细分析，本实验中只要了解到使用GPIO外设必须开启它的时钟即可。

### 8.3.4. main文件

现在就可以开始编写程序，在main文件中先编写一个 main 函数，里面什么都没有，暂时为空。

int main (void)
{
}

此时直接编译的话，会出现如下错误：

**Error: L6218E: Undefined symbol SystemInit (referred from startup_stm32f10x.o)**

错误提示SystemInit 没有定义。从分析启动文件时我们知道，Reset_Handler 调用了该函数用来初始化SMT32系统时钟， 为了简单起见，我们在 main 文件里面定义一个 SystemInit空函数，什么也不做，为的是骗过编译器，把这个错误去掉。 关于配置系统时钟我们在后面再写。当我们不配置系统时钟时，STM32会把HSI当作系统时钟，HSI=8M， 由芯片内部的振荡器提供。我们在main中添加如下函数：

// 函数为空，目的是为了骗过编译器不报错
void SystemInit(void)
{
}

这时再编译就没有错了，完美解决。还有一个方法就是在启动文件中把有关SystemInit 的代码注释掉也可以，见 [代码清单:点亮LED-4](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-4) 。

代码清单:点亮LED-4 注释掉启动文件中调用SystemInit的代码[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-4 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11|; Reset handler<br>Reset_Handler    PROC<br>        EXPORT  Reset_Handler             [WEAK]<br>        ;IMPORT  SystemInit<br>        IMPORT  __main<br><br>        ;LDR     R0, =SystemInit<br>        ;BLX     R0<br>        LDR     R0, =__main<br>        BX      R0<br>        ENDP|

接下来在main函数中添加代码，实现我们的点灯之旅。

#### 8.3.4.1. GPIO模式

首先我们把连接到LED灯的GPIO引脚PB0配置成输出模式，即配置GPIO的端口配置低寄存器CRL，见图 [GPIO端口控制低寄存器CRL](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#gpiocrl) 。 CRL中包含0-7号引脚，每个引脚占用4个寄存器位。MODE位用来配置输出的速度，CNF位用来配置各种输入输出模式。在这里我们把PB0配置为通用推挽输出， 输出的速度为10M，具体见 [代码清单:点亮LED-5](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-5) 。

代码清单:点亮LED-5 配置输出模式[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-5 "永久链接至代码")

|   |   |
|---|---|
|1<br>2<br>3<br>4|// 清空控制PB0的端口位<br>GPIOB_CRL &= ~( 0x0F<< (4*0));<br>// 配置PB0为通用推挽输出，速度为10M<br>GPIOB_CRL \|= (1<<4*0);|

![GPIO端口控制低寄存器CRL](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LEDreg010.png)

在代码中，我们先把控制PB0的端口位清0，然后再向它赋值“0001 b”，从而使GPIOB0引脚设置成输出模式，速度为10M。

代码中使用了 **&=~**、**|=** 这种操作方法是为了避免影响到寄存器中的其它位，因为寄存器不能按位读写，假如我们直接给CRL寄存器赋值：

GPIOB_CRL = 0x0000001;

这时CRL的的低4位被设置成“0001”输出模式，但其它GPIO引脚就有意见了，因为其它引脚的MODER位都已被设置成输入模式。

#### 8.3.4.2. 控制引脚输出电平

在输出模式时，对端口位设置/清除寄存器BSRR寄存器、端口位清除寄存器BRR和ODR寄存器写入参数即可控制引脚的电平状态， 其中操作BSRR和BRR最终影响的都是ODR寄存器，然后再通过ODR寄存器的输出来控制GPIO。为了一步到位，我们在这里直接操作ODR寄存器来控制GPIO的电平。 具体见 [代码清单:点亮LED-6](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-6) 。

代码清单:点亮LED-6 控制引脚输出电平[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-6 "永久链接至代码")

|   |   |
|---|---|
|1<br>2|// PB0输出低电平<br>GPIOB_ODR &= ~(1<<0);|

![数据输出寄存器ODR](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LEDreg011.png)

#### 8.3.4.3. 开启外设时钟

设置完GPIO的引脚，控制电平输出，以为现在总算可以点亮 LED 了吧，其实还差最后一步。由于STM32的 外设很多，为了降低功耗， 每个外设都对应着一个时钟，在芯片刚上电的时候这些时钟都是被关闭的，如果想要外设工作，必须把相应的时钟打开。

STM32 的所有外设的时钟由一个专门的外设来管理，叫 RCC（reset and clockcontrol）， RCC 在《 STM32 中文参考手册》的第六章。 关于RCC外设中的时钟部分，我们在后面的章节《RCC—使用HSE/HIS配置》中有详细的讲解，这里我们暂时先了解下。

所有的 GPIO都挂载到 APB2 总线上，具体的时钟由APB2外设时钟使能寄存器(RCC_ APB2ENR)来控制， 具体见 [代码清单:点亮LED-7](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-7) 。

代码清单:点亮LED-7 开启端口时钟[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-7 "永久链接至代码")

|   |   |
|---|---|
|1<br>2|// 开启 GPIOB 端口 时钟<br>RCC_APB2ENR \|= (1<<3);|

![APB2外设时钟使能寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/LEDreg012.png)

#### 8.3.4.4. 水到渠成

开启时钟，配置引脚模式，控制电平，经过这三步，我们总算可以控制一个 LED了。现在我们完整组织下用 STM32 控制一个 LED 的代码， 见 [代码清单:点亮LED-8](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-8) 。

代码清单:点亮LED-8 main文件中控制LED灯的代码[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/LED_register.html#led-8 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16|int main(void)<br>{<br>    // 开启GPIOB 端口时钟<br>    RCC_APB2ENR \|= (1<<3);<br><br>    //清空控制PB0的端口位<br>    GPIOB_CRL &= ~( 0x0F<< (4*0));<br>    // 配置PB0为通用推挽输出，速度为10M<br>    GPIOB_CRL \|= (1<<4*0);<br><br>    // PB0 输出 低电平<br>    GPIOB_ODR \|= (0<<0);<br><br>    while (1);<br><br>}|

在本章节中，要求完全理解stm32f10x.h文件及main文件的内容(RCC相关的除外)。

### 8.3.5. 下载验证

把编译好的程序下载到开发板并复位，可看到板子上的LED灯被点亮。



# 9. 自己写库—构建库函数雏形

本章参考资料：《STM32F10X-中文参考手册》GPIO章节和RCC章节。

虽然我们上面用寄存器点亮了 LED，乍看一下好像代码也很简单，但是我们别侥幸以后就可以一直用寄存器开发。 在用寄存器点亮 LED 的时候，我们会发现 STM32 的寄存器都是 32位的，每次配置的时候都要对照着《STM32F10X-中文参考手册》中寄存器的说明， 然后根据说明对每个控制的寄存器位写入特定参数，因此在配置的时候非常容易出错，而且代码还很不好理解， 不便于维护。所以学习 STM32 最好的方法是用固件库，然后在固件库的基础上了解底层，学习寄存器。

## 9.1. 什么是STM32函数库

以上所说的固件库是指“STM32标准函数库”，它是由ST公司针对STM32提供的函数接口， 即API (Application Program Interface)， 开发者可调用这些函数接口来配置STM32的寄存器，使开发人员得以脱离最底层的寄存器操作，有开发快速，易于阅读，维护成本低等优点。

当我们调用库API的时候不需要挖空心思去了解库底层的寄存器操作，就像当年我们刚开始学习C语言的时候，用prinft()函数时只是学习它的使用格式， 并没有去研究它的源码实现，但需要深入研究的时候，经过千锤百炼的库源码就是最佳学习范例。

实际上，库是架设在寄存器与用户驱动层之间的代码，向下处理与寄存器直接相关的配置，向上为用户提供配置寄存器的接口。 库开发方式与直接配置寄存器方式的区别见图 [固件库开发与寄存器开发对比图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id2) 。

![固件库开发与寄存器开发对比图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel001.png)

## 9.2. 为什么采用库来开发及学习？

在以前8位机时代的程序开发中，一般直接配置芯片的寄存器，控制芯片的工作方式，如中断，定时器等。配置的时候， 常常要查阅寄存器表，看用到哪些配置位，为了配置某功能，该置1还是置0。这些都是很琐碎的、机械的工作，因为8位机的软件相对来说较简单， 而且资源很有限，所以可以直接配置寄存器的方式来开发。

对于STM32，因为外设资源丰富，带来的必然是寄存器的数量和复杂度的增加，这时直接配置寄存器方式的缺陷就突显出来了：

1. 开发速度慢
    
2. 程序可读性差
    
3. 维护复杂
    

这些缺陷直接影响了开发效率，程序维护成本，交流成本。库开发方式则正好弥补了这些缺陷。

而坚持采用直接配置寄存器的方式开发的程序员，会列举以下原因：

1. 具体参数更直观
    
2. 程序运行占用资源少
    

相对于库开发的方式，直接配置寄存器方式生成的代码量的确会少一点，但因为STM32有充足的资源，权衡库的优势与不足， 绝大部分时候，我们愿意牺牲一点CPU资源，选择库开发。一般只有在对代码运行时间要求极苛刻的地方，才用直接配置寄存器的方式代替，如频繁调用的中断服务函数。

对于库开发与直接配置寄存器的方式，就好比编程是用汇编好还是用 C 好一样。在STM32F1系列刚推出函数库时引起程序员的激烈争论， 但是，随着ST库的完善与大家对库的了解，更多的程序员选择了库开发。现在STM32F1系列和STM32F4系列各有一套自己的函数库， 但是它们大部分是兼容的，F1和F4之间的程序移植，只需要小修改即可。而如果要移植用寄存器写的程序，那简直跟脱胎换骨差不多。

用库来进行开发，市场已有定论，用户群说明了一切，但对于STM32的学习仍然有人认为用寄存器好，而且汇编不是还没退出大学教材么？ 认为这种方法直观，能够了解到是配置了哪些寄存器，怎样配置寄存器。事实上，库函数的底层实现恰恰是直接配置寄存器方式的最佳例子， 它代替我们完成了寄存器配置的工作，而想深入了解芯片是如何工作的话，只要直接查看库函数的最底层实现就能理解，相信你会为它严谨、 优美的实现方式而陶醉，要想修炼C语言，就从ST的库开始吧。所以在以后的章节中，使用软件库是我们的重点， 而且我们通过讲解库API去高效地学习STM32的寄存器，并不至于因为用库学习，就不会用寄存器控制STM32芯片。

## 9.3. 实验：构建库函数雏形

虽然库的优点多多，但很多人对库还是很忌惮，因为一开始用库的时候有很多代码，很多文件，不知道如何入手。 不知道您是否认同这么一句话：一切的恐惧都来源于无知。我们对库忌惮那是因为我们不知道什么是库，不知道库是怎么实现的。

接下来，我们在寄存器点亮 LED 的代码上继续完善，把代码一层层封装，实现库的最初的雏形，相信经过这一步的学习后， 您对库的运用会游刃有余。这里我们只讲如何实现GPIO函数库，其他外设的我们直接参考ST标准库学习即可，不必自己写。

下面请打开本章配套例程“构建库函数雏形”来阅读理解，该例程是在上一章的基础上修改得来的。

### 9.3.1. 外设寄存器结构体定义

上一章中我们在操作寄存器的时候，操作的是都寄存器的绝对地址，如果每个外设寄存器都这样操作，那将非常麻烦。 我们考虑到外设寄存器的地址都是基于外设基地址的偏移地址，都是在外设基地址上逐个连续递增的，每个寄存器占 32 个字节， 这种方式跟结构体里面的成员类似。所以我们可以定义一种外设结构体，结构体的地址等于外设的基地址，结构体的成员等于寄存器， 成员的排列顺序跟寄存器的顺序一样。这样我们操作寄存器的时候就不用每次都找到绝对地址， 只要知道外设的基地址就可以操作外设的全部寄存器，即操作结构体的成员即可。

在工程中的“stm32f10x.h”文件中，我们使用结构体封装GPIO及RCC外设的的寄存器，见 [代码清单:构建库-1](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id6) 。 结构体成员的顺序按照寄存器的偏移地址从低到高排列，成员类型跟寄存器类型一样。

代码清单:构建库-1 封装寄存器列表[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id6 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19|//寄存器的值常常是芯片外设自动更改的，即使CPU没有执行程序，也有可能发生变化<br>//编译器有可能会对没有执行程序的变量进行优化<br><br>//volatile表示易变的变量，防止编译器优化，<br>#define     __IO    volatile<br>typedef unsigned int uint32_t;<br>typedef unsigned short uint16_t;<br><br>// GPIO 寄存器结构体定义<br>typedef struct<br>{<br>    __IO uint32_t CRL;       // 端口配置低寄存器，     地址偏移0X00<br>    __IO uint32_t CRH;       // 端口配置高寄存器，     地址偏移0X04<br>    __IO uint32_t IDR;       // 端口数据输入寄存器，   地址偏移0X08<br>    __IO uint32_t ODR;       // 端口数据输出寄存器，   地址偏移0X0C<br>    __IO uint32_t BSRR;      // 端口位设置/清除寄存器，地址偏移0X10<br>    __IO uint32_t BRR;       // 端口位清除寄存器，     地址偏移0X14<br>    __IO uint32_t LCKR;      // 端口配置锁定寄存器，   地址偏移0X18<br>} GPIO_TypeDef;|

这段代码在每个结构体成员前增加了一个“__IO”前缀，它的原型在这段代码的第一行，代表了C语言中的关键字“volatile”， 在C语言中该关键字用于表示变量是易变的，要求编译器不要优化。这些结构体内的成员，都代表着寄存器，而寄存器很多时候是由外设或STM32芯片状态修改的， 也就是说即使CPU不执行代码修改这些变量，变量的值也有可能被外设修改、更新，所以每次使用这些变量的时候， 我们都要求CPU去该变量的地址重新访问。若没有这个关键字修饰，在某些情况下，编译器认为没有代码修改该变量， 就直接从CPU的某个缓存获取该变量值，这时可以加快执行速度，但该缓存中的是陈旧数据，与我们要求的寄存器最新状态可能会 有出入。

### 9.3.2. 外设存储器映射

外设寄存器结构体定义仅仅是一个定义，要想实现给这个结构体赋值就达到操作寄存器的效果，我们还需要找到该寄存器的地址， 就把寄存器地址跟结构体的地址对应起来。所以我们要再找到外设的地址，根据我们前面的学习， 我们可以把这些外设的地址定义成一个个宏，实现外设存储器的映射。

```c
/*片上外设基地址  */
#define PERIPH_BASE           ((unsigned int)0x40000000)

/*APB2 总线基地址 */
#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
/* AHB总线基地址 */
#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)

/*GPIO外设基地址*/
#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)
#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)
#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)
#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)
#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)

/*RCC外设基地址*/
#define RCC_BASE      (AHBPERIPH_BASE + 0x1000)
```

### 9.3.3. 外设声明

定义好外设寄存器结构体，实现完外设存储器映射后，我们再把外设的基址强制类型转换成相应的外设寄存器结构体指针， 然后再把该指针声明成外设名，这样一来，外设名就跟外设的地址对应起来了，而且该外设名还是一个该外设类型的寄存器结构体指针， 通过该指针可以直接操作该外设的全部寄存器，见 [代码清单:构建库-2](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id9) 。

代码清单:构建库-2 指向外设首地址的结构体指针[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id9 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15|/ GPIO 外设声明<br>#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)<br>#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)<br>#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)<br>#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)<br>#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)<br>#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)<br>#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)<br><br><br>// RCC 外设声明<br>#define RCC                 ((RCC_TypeDef *) RCC_BASE)<br><br>/*RCC的AHB1时钟使能寄存器地址,强制转换成指针*/<br>#define RCC_APB2ENR      *(unsigned int*)(RCC_BASE+0x18)|

首先通过强制类型转换把外设的基地址转换成GPIO_TypeDef类型的结构体指针，然后通过宏定义把GPIOA、GPIOB等定义成外设的结构体指针， 通过外设的结构体指针我们就可以达到访问外设的寄存器的目的。

通过操作外设结构体指针的方式，我们把main文件里对应的代码修改掉，见 [代码清单:构建库-3](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id10) else部分。

代码清单:构建库-3 C语言条件编译[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id10 "永久链接至代码")

```c
/*
* C语言知识，条件编译
* #if 为真
* 执行这里的程序
* #else
* 否则执行这里的程序
* #endif
*/
```

代码清单:构建库-4 使用寄存器结构体指针操作寄存器[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id11 "永久链接至代码")

```c
// 使用寄存器结构体指针点亮LED
int main(void)
{
#if 0 // 直接通过操作内存来控制寄存器
    // 开启GPIOB 端口时钟
    RCC_APB2ENR |= (1<<3);

    //清空控制PB0的端口位
    GPIOB_CRL &= ~( 0x0F<< (4*0));
    // 配置PB0为通用推挽输出，速度为10M
    GPIOB_CRL |= (1<<4*0);

    // PB0 输出 低电平
    GPIOB_ODR |= (0<<0);

    while (1);

#else // 通过寄存器结构体指针来控制寄存器

    // 开启GPIOB 端口时钟
    RCC->APB2ENR |= (1<<3);

    //清空控制PB0的端口位
    GPIOB->CRL &= ~( 0x0F<< (4*0));
    // 配置PB0为通用推挽输出，速度为10M
    GPIOB->CRL |= (1<<4*0);

    // PB0 输出 低电平
    GPIOB->ODR |= (0<<0);

    while (1);

#endif
}
```

乍一看，除了把“_”换成了“->”，其他都跟使用寄存器点亮LED那部分代码一样。这是因为我们现在只是实现了库函数的基础，还没有定义库函数。

打好了地基，下面我们就来建高楼。接下来使用函数来封装GPIO的基本操作，方便以后应用的时候不需要再查询寄存器， 而是直接通过调用这里定义的函数来实现。我们把针对GPIO外设操作的函数及其宏定义分别存放在“stm32f10x_gpio.c”和“stm32f10x_gpio.h”文件中， 这两个文件需要自己新建。

### 9.3.4. 定义位操作函数

在“stm32f10x_gpio.c”文件定义两个位操作函数，分别用于控制引脚输出高电平和低电平，见 [代码清单:构建库-5](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id13) 。

代码清单:构建库-5 GPIO置位函数与复位函数的定义[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id13 "永久链接至代码")

```c
/**
*函数功能：设置引脚为高电平
*参数说明：GPIOx:该参数为GPIO_TypeDef类型的指针，指向GPIO端口的地址
*        GPIO_Pin:选择要设置的GPIO端口引脚，可输入宏GPIO_Pin_0-15，
*                 表示GPIOx端口的0-15号引脚。
*/
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
    /*设置GPIOx端口BSRR寄存器的第GPIO_Pin位，使其输出高电平*/
    /*因为BSRR寄存器写0不影响，
    宏GPIO_Pin只是对应位为1，其它位均为0，所以可以直接赋值*/

    GPIOx->BSRR = GPIO_Pin;
}

/**
*函数功能：设置引脚为低电平
*参数说明：GPIOx:该参数为GPIO_TypeDef类型的指针，指向GPIO端口的地址
*        GPIO_Pin:选择要设置的GPIO端口引脚，可输入宏GPIO_Pin_0-15，
*                 表示GPIOx端口的0-15号引脚。
*/
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
    /*设置GPIOx端口BRR寄存器的第GPIO_Pin位,使其输出低电平*/
    /*因为BRR寄存器写0不影响，
    宏GPIO_Pin只是对应位为1，其它位均为0，所以可以直接赋值*/

    GPIOx->BRR = GPIO_Pin;
}
```

这两个函数体内都是只有一个语句，对GPIOx的BSRR或BRR寄存器赋值，从而设置引脚为高电平或低电平， 操作BSRR或者BRR可以实现单独的操作某一位，有关这两个的寄存器说明见图 [BSRR寄存器说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#bsrr) 和图 [BRR寄存器说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#brr) 。 其中GPIOx是一个指针变量，通过函数的输入参数我们可以修改它的值，如给它赋予GPIOA、GPIOB、GPIOH等结构体指针值， 这个函数就可以控制相应的GPIOA、GPIOB、GPIOH等端口的输出。

![BSRR寄存器说明（摘自STM32F10X-中文参考手册）](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel002.png)![BRR寄存器说明（摘自STM32F10X-中文参考手册）](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel003.png)

利用这两个位操作函数，可以方便地操作各种GPIO的引脚电平， 控制各种端口引脚的范例见 [代码清单:构建库-6](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id14) 。

代码清单:构建库-6 位操作函数使用范例[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id14 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14|/*控制GPIOB的引脚10输出高电平*/<br>GPIO_SetBits(GPIOB,(uint16_t)(1<<10));<br>/*控制GPIOB的引脚10输出低电平*/<br>GPIO_ResetBits(GPIOB,(uint16_t)(1<<10));<br><br>/*控制GPIOB的引脚10、引脚11输出高电平，使用“\|”同时控制多个引脚*/<br>GPIO_SetBits(GPIOB,(uint16_t)(1<<10)\|(uint16_t)(1<<11));<br>/*控制GPIOB的引脚10、引脚11输出低电平*/<br>GPIO_ResetBits(GPIOB,(uint16_t)(1<<10)\|(uint16_t)(1<<10));<br><br>/*控制GPIOA的引脚8输出高电平*/<br>GPIO_SetBits(GPIOA,(uint16_t)(1<<8));<br>/*控制GPIOB的引脚9输出低电平*/<br>GPIO_ResetBits(GPIOB,(uint16_t)(1<<9));|

使用以上函数输入参数，设置引脚号时，还是稍感不便，为此我们把表示16个引脚的操作数都定义成宏，见 [代码清单:构建库-7](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id15) 。

代码清单:构建库-7 选择引脚参数的宏[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id15 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18|/*GPIO引脚号定义*/<br>#define GPIO_Pin_0              (uint16_t)0x0001)  /*!< 选择Pin0 (1<<0) */<br>#define GPIO_Pin_1              ((uint16_t)0x0002)  /*!< 选择Pin1 (1<<1)*/<br>#define GPIO_Pin_2              ((uint16_t)0x0004)  /*!< 选择Pin2 (1<<2)*/<br>#define GPIO_Pin_3              ((uint16_t)0x0008)  /*!< 选择Pin3 (1<<3)*/<br>#define GPIO_Pin_4              ((uint16_t)0x0010)  /*!< 选择Pin4 */<br>#define GPIO_Pin_5              ((uint16_t)0x0020)  /*!< 选择Pin5 */<br>#define GPIO_Pin_6              ((uint16_t)0x0040)  /*!< 选择Pin6 */<br>#define GPIO_Pin_7              ((uint16_t)0x0080)  /*!< 选择Pin7 */<br>#define GPIO_Pin_8              ((uint16_t)0x0100)  /*!< 选择Pin8 */<br>#define GPIO_Pin_9              ((uint16_t)0x0200)  /*!< 选择Pin9 */<br>#define GPIO_Pin_10             ((uint16_t)0x0400)  /*!< 选择Pin10 */<br>#define GPIO_Pin_11             ((uint16_t)0x0800)  /*!< 选择Pin11 */<br>#define GPIO_Pin_12             ((uint16_t)0x1000)  /*!< 选择Pin12 */<br>#define GPIO_Pin_13             ((uint16_t)0x2000)  /*!< 选择Pin13 */<br>#define GPIO_Pin_14             ((uint16_t)0x4000)  /*!< 选择Pin14 */<br>#define GPIO_Pin_15             ((uint16_t)0x8000)  /*!< 选择Pin15 */<br>#define GPIO_Pin_All            ((uint16_t)0xFFFF)  /*!< 选择全部引脚 */|

这些宏代表的参数是某位置“1”其它位置“0”的数值，其中最后一个“GPIO_Pin_ALL”是所有数据位都为“1”， 所以用它可以一次控制设置整个端口的0-15所有引脚。利用这些宏， GPIO的控制代码可改为 [代码清单:构建库-8](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id16) 。

代码清单:构建库-8 使用位操作函数及宏控制GPIO[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id16 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16|/*控制GPIOB的引脚10输出高电平*/<br>GPIO_SetBits(GPIOB,GPIO_Pin_10);<br>/*控制GPIOB的引脚10输出低电平*/<br>GPIO_ResetBits(GPIOB,GPIO_Pin_10);<br><br>/*控制GPIOB的引脚10、引脚11输出高电平，使用“\|”，同时控制多个引脚*/<br>GPIO_SetBits(GPIOB,GPIO_Pin_10\|GPIO_Pin_11);<br>/*控制GPIOB的引脚10、引脚11输出低电平*/<br>GPIO_ResetBits(GPIOB,GPIO_Pin_10\|GPIO_Pin_11);<br>/*控制GPIOB的所有输出低电平*/<br>GPIO_ResetBits(GPIOB,GPIO_Pin_ALL);<br><br>/*控制GPIOA的引脚8输出高电平*/<br>GPIO_SetBits(GPIOA,GPIO_Pin_8);<br>/*控制GPIOB的引脚9输出低电平*/<br>GPIO_ResetBits(GPIOB,GPIO_Pin_9);|

使用以上代码控制GPIO，我们就不需要再看寄存器了，直接从函数名和输入参数就可以直观看出这个语句要实现什么操作。 (英文中“Set”表示“置位”，即高电平，“Reset”表示“复位”，即低电平)

### 9.3.5. 定义初始化结构体GPIO_InitTypeDef

定义位操作函数后，控制GPIO输出电平的代码得到了简化，但在控制GPIO输出电平前还需要初始化GPIO引脚的各种模式， 这部分代码涉及的寄存器有很多，我们希望初始化GPIO也能以如此简单的方法去实现。为此，我们先根据GPIO初始化时涉及到的初始化参数以结构体的形式封装起来， 声明一个名为GPIO_InitTypeDef的结构体类型，见 [代码清单:构建库-9](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id17)

代码清单:构建库-9 定义GPIO初始化结构体[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id17 "永久链接至代码")

|   |   |
|---|---|
|1<br>2<br>3<br>4<br>5<br>6<br>7<br>8|typedef struct<br>{<br>    uint16_t GPIO_Pin;      /*!< 选择要配置的GPIO引脚 */<br><br>    uint16_t GPIO_Speed;    /*!< 选择GPIO引脚的速率 */<br><br>    uint16_t GPIO_Mode;     /*!< 选择GPIO引脚的工作模式 */<br>} GPIO_InitTypeDef;|

这个结构体中包含了初始化GPIO所需要的信息，包括引脚号、工作模式、输出速率。设计这个结构体的思路是：初始化GPIO前， 先定义一个这样的结构体变量，根据需要配置GPIO的模式，对这个结构体的各个成员进行赋值，然后把这个变量作为“GPIO初始化函数”的输入参数， 该函数能根据这个变量值中的内容去配置寄存器，从而实现GPIO的初始化。

### 9.3.6. 定义引脚模式的枚举类型

上面定义的结构体很直接，美中不足的是在对结构体中各个成员赋值实现某个功能时还需要查询手册的寄存器说明， 我们不希望每次用到的时候都要去查询手册，我们可以使用C语言中的枚举定义功能，根据手册把每个成员的所有取值都定义好， 具体见代码9‑4。GPIO_Speed和GPIO_Mode这两个成员对应的寄存器是CRL和CRH这两个端口配置寄存器， 具体见图 [端口配置低寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id19) 和图 [端口配置高寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id20) 。

![端口配置低寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel004.png)![端口配置高寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel005.png)

代码清单:构建库-4 GPIO枚举类型定义[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id21 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25|/**<br>* GPIO输出速率枚举定义<br>*/<br>typedef enum<br>{<br>    GPIO_Speed_10MHz = 1,         // 10MHZ        (01)b<br>    GPIO_Speed_2MHz,              // 2MHZ         (10)b<br>    GPIO_Speed_50MHz              // 50MHZ        (11)b<br>} GPIOSpeed_TypeDef;<br><br>/**<br>* GPIO工作模式枚举定义<br>*/<br>typedef enum<br>{<br>    GPIO_Mode_AIN = 0x0,           // 模拟输入     (0000 0000)b<br>    GPIO_Mode_IN_FLOATING = 0x04,  // 浮空输入     (0000 0100)b<br>    GPIO_Mode_IPD = 0x28,          // 下拉输入     (0010 1000)b<br>    GPIO_Mode_IPU = 0x48,          // 上拉输入     (0100 1000)b<br><br>    GPIO_Mode_Out_OD = 0x14,       // 开漏输出     (0001 0100)b<br>    GPIO_Mode_Out_PP = 0x10,       // 推挽输出     (0001 0000)b<br>    GPIO_Mode_AF_OD = 0x1C,        // 复用开漏输出  (0001 1100)b<br>    GPIO_Mode_AF_PP = 0x18         // 复用推挽输出  (0001 1000)b<br>} GPIOMode_TypeDef;|

关于这两个枚举类型的值如何跟端口控制寄存器里面的说明对应起来，我们简单分析下。 有关速度的枚举类型有(01)b 10MHZ、(10)b 2MHZ和(11)b 50MHZ，这三个值跟寄存器说明对得上，很容易理解。 至于模式的枚举类型的值理解起来就比较绕，这让很多人费了脑筋，下面我们通过一个表格来梳理下，好帮助我们理解， 具体见图 [GPIO引脚工作模式真值表分析](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#gpio) 。

![GPIO引脚工作模式真值表分析](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel006.png)

如果但从这些枚举值的十六进制来看，很难发现规律，转化成二进制之后，就比较容易发现规律。bit4用来区分端口是输入还是输出， 0表示输入，1表示输出，bit2和bit3对应寄存器的CNFY[1:0]位，是我们真正要写入到CRL和CRH这两个端口控制寄存器中的值。 bit0和bit1对应寄存器的MODEY[1:0]位，这里我们暂不初始化， 在GPIO_Init()初始化函数中用来跟GPIOSpeed的值相加即可实现速率的配置。有关具体的代码分析见GPIO_Init()库函数。 其中在下拉输入和上拉输入中我们设置bit5和bit6的值为01和10来以示区别。

有了这些枚举定义，我们的GPIO_InitTypeDef结构体就可以使用枚举类型来限定输入参数， 见 [代码清单:构建库-11](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id22) 使用枚举定义的GPIO初始化结构体。

代码清单:构建库-11 使用枚举定义的GPIO初始化结构体[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id22 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14|/**<br>* GPIO初始化结构体类型定义<br>*/<br>typedef struct<br>{<br>    uint16_t GPIO_Pin;             /*!< 选择要配置的GPIO引脚<br>                                    可输入 GPIO_Pin_ 定义的宏 */<br><br>    GPIOSpeed_TypeDef GPIO_Speed;  /*!< 选择GPIO引脚的速率<br>                                    可输入 GPIOSpeed_TypeDef 定义的枚举值 */<br><br>    GPIOMode_TypeDef GPIO_Mode;    /*!< 选择GPIO引脚的工作模式<br>                                    可输入 GPIOMode_TypeDef 定义的枚举值 */<br>} GPIO_InitTypeDef;|

如果不使用枚举类型，仍使用“uint16_t”类型来定义结构体成员，那么成员值的范围就是0-255，而实际上这些成员都只能输入几个数值。 所以使用枚举类型可以对结构体成员起到限定输入的作用，只能输入相应已定义的枚举值。

利用这些枚举定义，给GPIO_InitTypeDef结构体类型赋值配置就变得非常直观，范例见 [代码清单:构建库-12](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id23) 。

代码清单:构建库-12给GPIO_InitTypeDef初始化结构体赋值范例[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id23 "永久链接至代码")

|   |   |
|---|---|
|1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9|GPIO_InitTypeDef GPIO_InitStructure;<br><br>/* GPIO 端口初始化 */<br>/*选择要控制的GPIO引脚*/<br>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<br>/*设置引脚模式为输出模式*/<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>/*设置引脚的输出类型为推挽输出*/<br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;|

### 9.3.7. 定义GPIO初始化函数

接着前面的思路，对初始化结构体赋值后，把它输入到GPIO初始化函数，由它来实现寄存器配置。 我们的GPIO初始化函数实现见 [代码清单:构建库-13](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id25) 。

代码清单:构建库-13 GPIO初始化函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id25 "永久链接至代码")

|   |   |
|---|---|
|1<br>  2<br>  3<br>  4<br>  5<br>  6<br>  7<br>  8<br>  9<br> 10<br> 11<br> 12<br> 13<br> 14<br> 15<br> 16<br> 17<br> 18<br> 19<br> 20<br> 21<br> 22<br> 23<br> 24<br> 25<br> 26<br> 27<br> 28<br> 29<br> 30<br> 31<br> 32<br> 33<br> 34<br> 35<br> 36<br> 37<br> 38<br> 39<br> 40<br> 41<br> 42<br> 43<br> 44<br> 45<br> 46<br> 47<br> 48<br> 49<br> 50<br> 51<br> 52<br> 53<br> 54<br> 55<br> 56<br> 57<br> 58<br> 59<br> 60<br> 61<br> 62<br> 63<br> 64<br> 65<br> 66<br> 67<br> 68<br> 69<br> 70<br> 71<br> 72<br> 73<br> 74<br> 75<br> 76<br> 77<br> 78<br> 79<br> 80<br> 81<br> 82<br> 83<br> 84<br> 85<br> 86<br> 87<br> 88<br> 89<br> 90<br> 91<br> 92<br> 93<br> 94<br> 95<br> 96<br> 97<br> 98<br> 99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118|/**<br>*函数功能：初始化引脚模式<br>*参数说明：GPIOx，该参数为GPIO_TypeDef类型的指针，指向GPIO端口的地址<br>*         GPIO_InitTypeDef:GPIO_InitTypeDef结构体指针，指向初始化变量<br>*/<br>void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)<br>{<br>    uint32_t currentmode =0x00,currentpin = 0x00,pinpos = 0x00,pos = 0x00;<br>    uint32_t tmpreg = 0x00, pinmask = 0x00;<br><br>    /*---------------- GPIO 模式配置 -------------------*/<br>    // 把输入参数GPIO_Mode的低四位暂存在currentmode<br>    currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) &<br>                ((uint32_t)0x0F);<br><br>    // bit4是1表示输出，bit4是0则是输入<br>    // 判断bit4是1还是0，即首选判断是输入还是输出模式<br>    if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) &<br>            ((uint32_t)0x10)) != 0x00)<br>    {<br>        // 输出模式则要设置输出速度<br>        currentmode \|= (uint32_t)GPIO_InitStruct->GPIO_Speed;<br>    }<br>    /*-----GPIO CRL 寄存器配置 CRL寄存器控制着低8位IO- ----*/<br>    // 配置端口低8位，即Pin0~Pin7<br>    if (((uint32_t)GPIO_InitStruct->GPIO_Pin &<br>            ((uint32_t)0x00FF)) != 0x00)<br>    {<br>        // 先备份CRL寄存器的值<br>        tmpreg = GPIOx->CRL;<br><br>        // 循环，从Pin0开始配对，找出具体的Pin<br>        for (pinpos = 0x00; pinpos < 0x08; pinpos++)<br>        {<br>            // pos的值为1左移pinpos位<br>            pos = ((uint32_t)0x01) << pinpos;<br><br>            // 令pos与输入参数GPIO_PIN作位与运算<br>            currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;<br><br>            //若currentpin=pos,则找到使用的引脚<br>            if (currentpin == pos)<br>            {<br>                //pinpos的值左移两位(乘以4),因为寄存器中4个位配置一个引脚<br>                pos = pinpos << 2;<br>                //把控制这个引脚的4个寄存器位清零，其它寄存器位不变<br>                pinmask = ((uint32_t)0x0F) << pos;<br>                tmpreg &= ~pinmask;<br><br>                // 向寄存器写入将要配置的引脚的模式<br>                tmpreg \|= (currentmode << pos);<br><br>                // 判断是否为下拉输入模式<br>                if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)<br>                {<br>                    // 下拉输入模式,引脚默认置0,对BRR寄存器写1对引脚置0<br>                    GPIOx->BRR = (((uint32_t)0x01) << pinpos);<br>                }<br>                else<br>                {<br>                    // 判断是否为上拉输入模式<br>                    if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)<br>                    {<br>                        // 上拉输入模式,引脚默认值为1,对BSRR寄存器写1对引脚置1<br>                        GPIOx->BSRR = (((uint32_t)0x01) << pinpos);<br>                    }<br>                }<br>            }<br>        }<br>        // 把前面处理后的暂存值写入到CRL寄存器之中<br>        GPIOx->CRL = tmpreg;<br>    }<br>    /*--------GPIO CRH 寄存器配置 CRH寄存器控制着高8位IO- -----*/<br>    // 配置端口高8位，即Pin8~Pin15<br>    if (GPIO_InitStruct->GPIO_Pin > 0x00FF)<br>    {<br>        // // 先备份CRH寄存器的值<br>        tmpreg = GPIOx->CRH;<br><br>        // 循环，从Pin8开始配对，找出具体的Pin<br>        for (pinpos = 0x00; pinpos < 0x08; pinpos++)<br>        {<br>            pos = (((uint32_t)0x01) << (pinpos + 0x08));<br><br>            // pos与输入参数GPIO_PIN作位与运算<br>            currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);<br><br>            //若currentpin=pos,则找到使用的引脚<br>            if (currentpin == pos)<br>            {<br>                //pinpos的值左移两位(乘以4),因为寄存器中4个位配置一个引脚<br>                pos = pinpos << 2;<br><br>                //把控制这个引脚的4个寄存器位清零，其它寄存器位不变<br>                pinmask = ((uint32_t)0x0F) << pos;<br>                tmpreg &= ~pinmask;<br><br>                // 向寄存器写入将要配置的引脚的模式<br>                tmpreg \|= (currentmode << pos);<br><br>                // 判断是否为下拉输入模式<br>                if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)<br>                {<br>                    // 下拉输入模式,引脚默认置0,对BRR寄存器写1可对引脚置0<br>                    GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));<br>                }<br>                // 判断是否为上拉输入模式<br>                if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)<br>                {<br>                    // 上拉输入模式,引脚默认值为1,对BSRR寄存器写1可对引脚置1<br>                    GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));<br>                }<br>            }<br>        }<br>        // 把前面处理后的暂存值写入到CRH寄存器之中<br>        GPIOx->CRH = tmpreg;<br>    }<br>}|

这个函数有GPIOx和GPIO_InitStruct两个输入参数，分别是GPIO外设指针和GPIO初始化结构体指针。 分别用来指定要初始化的GPIO端口及引脚的工作模式。

要充分理解这个GPIO初始化函数，得配合我们刚刚分析的GPIO 引脚工作模式真值表来看。

![GPIO引脚工作模式真值表](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel006.png)

1. 先取得GPIO_Mode的值，判断bit4是1还是0来判断是输出还是输入。 如果是输出则设置输出速率，即加上GPIO_Speed的值，输入没有速率之说，不用设置。
    
2. 配置CRL寄存器。通过GPIO_Pin的值计算出具体需要初始化哪个引脚，算出后，然后把需要配置的值写入到CRL寄存器中，具体分析见代码注释。 这里有一个比较有趣的是上/下拉输入并不是直接通过配置某一个寄存器来实现的，而是通过写BSRR或者BRR寄存器来实现。 这让很多只看手册没看固件库底层源码的人摸不着头脑，因为手册的寄存器说明中没有明确的指出如何配置上拉/下拉， 具体见图 [上拉_下拉寄存器说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id27) 。
    
3. 配置CRH寄存器过程同CRL。
    

![上拉下拉寄存器说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Writel007.png)

### 9.3.8. 全新面貌，使用函数点亮LED灯

完成以上的准备后，我们就可以用自己定义的函数来点亮LED灯，见

代码清单:构建库-14 使用函数点亮LED[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Write_lib.html#id28 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39|// 使用固件库点亮LED<br>int main(void)<br>{<br>    // 定义一个GPIO_InitTypeDef类型的结构体<br>    GPIO_InitTypeDef GPIO_InitStructure;<br><br>    // 开启GPIO端口时钟<br>    RCC_APB2ENR \|= (1<<3);<br><br>    // 选择要控制的GPIO引脚<br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<br><br>    // 设置引脚模式为通用推挽输出<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br><br>    // 设置引脚速率为50MHz<br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>    // 调用库函数，初始化GPIO引脚<br>    GPIO_Init(GPIOB, &GPIO_InitStructure);<br><br>    // 使引脚输出低电平,点亮LED1<br>    GPIO_ResetBits(GPIOB,GPIO_Pin_0);<br><br>    while (1)<br>    {<br>        // 使引脚输出低电平,点亮LED<br>        GPIO_ResetBits(GPIOB,GPIO_Pin_0);<br><br>        /*延时一段时间*/<br>        Delay(0xFFFF);<br><br>        /*使引脚输出高电平，关闭LED1*/<br>        GPIO_SetBits(GPIOB,GPIO_Pin_0);<br><br>        /*延时一段时间*/<br>        Delay(0xFFFF);<br>    }<br>}|

现在看起来，使用函数来控制LED灯与之前直接控制寄存器已经有了很大的区别：main函数中先定义了一个GPIO初始化结构体变量GPIO_InitStructure， 然后对该变量的各个成员按点亮LED灯所需要的GPIO配置模式进行赋值，赋值后，调用GPIO_Init函数，让它根据结构体成员值对GPIO寄存器写入控制参数， 完成GPIO引脚初始化。控制电平时，直接使用GPIO_SetBits和GPIO_Resetbits函数控制输出。如若对其它引脚进行不同模式的初始化， 只要修改GPIO初始化结构体GPIO_InitStructure的成员值，把新的参数值输入到GPIO_Init函数再调用即可。

代码中新增的Delay函数，主要功能是延时，让我们可以看清楚实验现象(不延时的话指令执行太快，肉眼看不出来)，它的实现原理是让CPU执行无意义的指令， 消耗时间，在此不要纠结它的延时时间，写一个大概输入参数值，下载到实验板实测，觉得太久了就把参数值改小，短了就改大即可。 需要精确延时的时候我们会用STM32的定时器外设进行精确延时的。

### 9.3.9. 下载验证

把编译好的程序下载到开发板并复位，可看到板子上的灯已经被点亮。

### 9.3.10. 总结

什么是ST标准固件库？不懂的时候总觉得莫测高深，懂了之后一切都是纸老虎。

我们从寄存器映射开始，把内存跟寄存器建立起一一对应的关系，然后操作寄存器点亮 LED，再把寄存器操作封装成一个个函数。 一步一步走来，我们实现了库最简单的雏形，如果我们不断地增加操作外设的函数，并且把所有的外设都写完，一个完整的库就实现了。

本章中的GPIO相关库函数及结构体定义，实际上都是从ST标准库搬过来的。这样分析它纯粹是为了满足自己的求知欲，学习其编程的方式、思想， 这对提高我们的编程水平是很有好处的，顺便感受一下ST库设计的严谨性，我认为这样的代码不仅严谨且华丽优美，不知您是否也有这样的感受。

与直接配置寄存器相比，从执行效率上看会有额外的消耗：初始化变量赋值的过程、库函数在被调用的时候要耗费调用时间；在函数内部， 对输入参数转换所需要的额外运算也消耗一些时间(如GPIO中运算求出引脚号时)。而其它的宏、枚举等解释操作是作编译过程完成的， 这部分并不消耗内核的时间。那么函数库的优点呢？是我们可以快速上手STM32控制器；配置外设状态时， 不需要再纠结要向寄存器写入什么数值；交流方便，查错简单。这就是我们选择库的原因。

现在的处理器的主频是越来越高，我们不需要担心CPU耗费那么多时间来干活会不会被累倒，库主要应用是在初始化过程， 而初始化过程一般是芯片刚上电或在核心运算之前的执行的，这段时间的等待是0.02us还是0.01us在很多时候并没有什么区别。 相对来说，我们还是担心一下如果都用寄存器操作，每行代码都要查数据手册的寄存器说明，自己会不会被累倒吧。

在以后开发的工程中，一般不会去分析ST的库函数的实现。因为外设的库函数是很类似的，库外设都包含初始化结构体，以及特定的宏或枚举标识符， 这些封装被库函数这些转化成相应的值，写入到寄存器之中，函数内部的具体实现是十分枯燥和机械的工作。如果您有兴趣， 在您掌握了如何使用外设的库函数之后，可以查看一下它的源码实现。

通常我们只需要通过了解每种外设的“初始化结构体”就能够通过它去了解STM32的外设功能及控制。


# 10. 初识STM32标准库

在上一章中，我们构建了几个控制GPIO外设的函数，算是实现了函数库的雏形，但GPIO还有很多功能函数我们没有实现， 而且STM32芯片不仅仅只有GPIO这一个外设。如果我们想要亲自完成这个函数库，工作量非常巨大。ST公司提供的标准软件库， 包含了STM32芯片所有寄存器的控制操作，我们直接学习如何使用ST标准库，会极大地方便控制STM32芯片。

## 10.1. CMSIS标准及库层次关系

因为基于Cortex系列芯片采用的内核都是相同的，区别主要为核外的片上外设的差异，这些差异却导致软件在同内核，不同外设的芯片上移植困难。 为了解决不同的芯片厂商生产的Cortex微控制器软件 的兼容性问题， ARM与芯片厂商建立了CMSIS标准(Cortex MicroController Software Interface Standard)。

所谓CMSIS标准，实际是新建了一个软件抽象层。见图 [CMSIS架构](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id1) 。

![CMSIS架构](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer009.png)

CMSIS标准中最主要的为CMSIS核心层，它包括了：

> - 内核函数层：其中包含用于访问内核寄存器的名称、地址定义，主要由ARM公司提供。
>     
> - 设备外设访问层：提供了片上的核外外设的地址和中断定义，主要由芯片生产商提供。
>     

可见CMSIS层位于硬件层与操作系统或用户层之间，提供了与芯片生产商无关的硬件抽象层，可以为接口外设、实时操作系统提供简单的处理器软件接口， 屏蔽了硬件差异，这对软件的移植是有极大的好处的。STM32的库，就是按照CMSIS标准建立的。

### 10.1.1. 库目录、文件简介[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id2 "永久链接至标题")

STM32标准库可以从官网获得，也可以直接从本书的配套资料得到。本书讲解的例程全部采用3.5.0库文件。以下内容请大家打开STM32标准库文件配合阅读。

解压库文件后进入其目录：

**STM32F10x_StdPeriph_Lib_V3.5.0**

软件库各文件夹的内容说明见图 [ST标准库](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#st) 。目录：STM32F10x_StdPeriph_Lib_V3.5.0

![ST标准库](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer002.png)

- Libraries：文件夹下是驱动库的源代码及启动文件，这个非常重要，我们要使用的固件库就在这个文件夹里面。。
    
- Project ：文件夹下是用驱动库写的例子和工程模板，其中那些为每个外设写好的例程对我们非常有用， 我们在学习的时候就可以参考这里面的例程，非常全面，简直就是穷尽了外设的所有功能。
    
- Utilities：包含了基于ST官方实验板的例程，不需要用到，略过即可。
    
- stm32f10x_stdperiph_lib_um.chm： 库帮助文档，这个很有用，不喜欢直接看源码的可以在合理查询每个外设的函数说明，非常详细。 这是一个已经编译好的HTML文件，主要讲述如何使用驱动库来编写自己的应用程序。说得形象一点，这个HTML就是告诉我们： ST公司已经为你写好了每个外设的驱动了，想知道如何运用这些例子就来向我求救吧。不幸的是，这个帮助文档是英文的， 这对很多英文不好的朋友来说是一个很大的障碍。但这里要告诉大家，英文仅仅是一种工具，绝对不能让它成为我们学习的障碍。 其实这些英文还是很简单的，我们需要的是拿下它的勇气。
    

在使用库开发时，我们需要把libraries目录下的库函数文件添加到工程中，并查阅库帮助文档来了解ST提供的库函数，这个文档说明了每一个库函数的使用方法。

进入Libraries文件夹看到，关于内核与外设的库文件分别存放在CMSIS和STM32F10x_StdPeriph_Driver文件夹中。

#### 10.1.1.1. CMSIS文件夹

STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSIS\文件夹展开内容见图 [CMSIS文件夹内容](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id4) 。目录：Libraries\CMSIS\

![CMSIS文件夹内容 目录：Libraries\CMSIS\\](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer003.png)

其中黄色框框住的是我们需要用到的内容，下面我们一一讲解下这几个文件的作用。

内核相关文件

在CoreSupport文件夹中有core_cm3.c和core_cm3.h两个文件。Core_cm3.h头文件里面实现了内核的寄存器映射，对应外设头文件stm32f10x.h， 区别就是一个针对内核的外设，一个针对片上（内核之外）的外设。core_cm3.c文件实现了一下操作内核外设寄存器的函数，用的比较少。

我们还需要了解的是core_cm3.h头文件中包含了“stdint.h” 这个头文件，这是一个ANSI C 文件，是独立于处理器之外的， 就像我们熟知的C语言头文件 “stdio.h” 文件一样。位于RVMDK这个软件的安装目录下，主要作用是提供一些类型定义。 见 [代码清单:标准库-1](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id5) 。

代码清单:标准库-1：stdint.h文件中的类型定义[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id5 "永久链接至代码")

```c
/* exact-width signed integer types */
typedef   signed          char int8_t;
typedef   signed short     int int16_t;
typedef   signed           int int32_t;
typedef   signed       __int64 int64_t;

/* exact-width unsigned integer types */
typedef unsigned          char uint8_t;
typedef unsigned short     int uint16_t;
typedef unsigned           int uint32_t;
typedef unsigned       __int64 uint64_t;
```

这些新类型定义屏蔽了在不同芯片平台时，出现的诸如int的大小是16位，还是32位的差异。 所以在我们以后的程序中，都将使用新类型如uint8_t 、uint16_t等。

在稍旧版的程序中还经常会出现如u8、u16、u32这样的类型，分别表示的无符号的8位、16位、32位整型。初学者碰到这样的旧类型感觉一头雾水， 它们定义的位置在STM32f10x.h文件中。建议在以后的新程序中尽量使用uint8_t 、uint16_t类型的定义。

**启动文件**

启动文件放在startup/arm这个文件夹下面，这里面启动文件有很多个，不同型号的单片机用的启动文件不一样，有关每个启动文件的 [详细说明见表](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id6)

![详细说明见表](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer01.png)

我们开发板中用的STM32F103VET6或者STM32F103ZET6的FLASH都是512K，属于基本型的大容量产品，启动文件统一选择startup_stm32f10x_hd.s。

**Stm32f10x.h**

这个头文件实现了片上外设的所有寄存器的映射，是一个非常重要的头文件，在内核中与之想对应的头文件是core_cm3.h。

**system_stm32f10x.c**

system_stm32f10x.c文件实现了STM32的时钟配置，操作的是片上的RCC这个外设。系统在上电之后，首选会执行由汇编编写的启动文件， 启动文件中的复位函数中调用的SystemInit函数就在这个文件里面定义。调用完之后，系统的时钟就被初始化成72M。如果后面我们需要重新配置系统时钟， 我们就可以参考这个函数重写。为了维持库的完整性，我们不会直接在这个文件里面修改时钟配置函数。

#### 10.1.1.2. STM32F10x_StdPeriph_Driver文件夹

文件目录：Libraries\STM32F10x_StdPeriph_Driver

进入libraries目录下的STM32F10x_StdPeriph_Driver文件夹，见图 [外设驱动](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id7) 。

![外设驱动](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer004.png)

STM32F10x_StdPeriph_Driver文件夹下有inc（include的缩写）跟src（source的简写）这两个文件夹，这里的文件属于CMSIS之外的的、 芯片片上外设部分。src里面是每个设备外设的驱动源程序，inc则是相对应的外设头文件。src及inc文件夹是ST标准库的主要内容， 甚至不少人直接认为ST标准库就是指这些文件，可见其重要性。

在src 和inc文件夹里的就是ST公司针对每个STM32外设而编写的库函数文件，每个外设对应一个 .c 和 .h 后缀的文件。 我们把这类外设文件统称为：stm32f10x_ppp.c或stm32f10x_ppp.h文件，PPP表示外设名称。 如在上一章中我们自建的stm32f10x_gpio.c及stm32f10x_gpio.h文件，就属于这一类。

如针对模数转换(ADC)外设，在src文件夹下有一个stm32f10x_adc.c源文件，在inc文件夹下有一个stm32f10x_adc.h头文件， 若我们开发的工程中用到了STM32内部的ADC，则至少要把这两个文件包含到工程里。见图 [驱动的源文件及头文件](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id8) 。

![驱动的源文件及头文件](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer005.png)

这两个文件夹中，还有一个很特别的misc.c文件，这个文件提供了外设对内核中的NVIC(中断向量控制器)的访问函数， 在配置中断时，我们必须把这个文件添加到工程中。

#### 10.1.1.3. stm32f10x_it.c、 stm32f10x_conf.h和system_stm32f10x.c文件

文件目录：STM32F10x_StdPeriph_Lib_V3.5.0\Project\STM32F10x_StdPeriph_Template

在这个文件目录下，存放了官方的一个库工程模板，我们在用库建立一个完整的工程时，还需要添加这个目录下的stm32f10x_it.c、 stm32f10x_it.h、stm32f10x_conf.h和system_stm32f10x.c这四个文件。

**stm32f10x_it.c**：这个文件是专门用来编写中断服务函数的，在我们修改前，这个文件已经定义了一些系统异常(特殊中断)的接口， 其它普通中断服务函数由我们自己添加。但是我们怎么知道这些中断服务函数的接口如何写？是不是可以自定义呢？答案当然不是， 这些都可以在汇编启动文件中找到，在学习中断和启动文件的时候我们会详细介绍

**system_stm32f10x.c**：这个文件包含了STM32芯片上电后初始化系统时钟、扩展外部存储器用的函数， 例如我们前两章提到供启动文件调用的“SystemInit”函数，用于上电后初始化时钟，该函数的定义就存储在system_stm32f10x.c文件。 STM32F103系列的芯片，调用库的这个SystemInit函数后，系统时钟被初始化为72MHz，如有需要可以修改这个文件的内容， 设置成自己所需的时钟频率，但鉴于保持库的完整性，我们在做系统时钟配置的时候会另外重写时钟配置函数。

**stm32f10x_conf.h**：这个文件被包含进stm32f10x.h 文件。当我们使用固件库编程的时候，如果需要某个外设的驱动库， 就需要包含该外设的头文件：stm32f10x_ppp.h，包含一个还好，如果是用了多外设，就需要包含多个头文件，这不仅影响代码美观也不好管理， 现我们用一个头文件stm32f10x_conf.h把这些外设的头文件都包含在里面，让这个配置头文件统一管理这些外设的头文件， 我们在应用程序中只需要包含这个配置头文件即可，我们又知道这个头文件在stm32f10x.h的最后被包含， 所以最终我们只需要包含stm32f10x.h这个头文件即可，非常方便。Stm32f10x_conf.h见 [代码清单:标准库-2](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id9) 。 默认情况下是所以头文件都被包含，没有被注释掉。我们也可以把不要的都注释掉，只留下需要使用的即可。

代码清单:标准库-2 stm32f10x_conf.h文件配置软件库[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id9 "永久链接至代码")

```c
#include "stm32f10x_adc.h"
#include "stm32f10x_bkp.h"
#include "stm32f10x_can.h"
#include "stm32f10x_cec.h"
#include "stm32f10x_crc.h"
#include "stm32f10x_dac.h"
#include "stm32f10x_dbgmcu.h"
#include "stm32f10x_dma.h"
#include "stm32f10x_exti.h"
#include "stm32f10x_flash.h"
#include "stm32f10x_fsmc.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_i2c.h"
#include "stm32f10x_iwdg.h"
#include "stm32f10x_pwr.h"
#include "stm32f10x_rcc.h"
#include "stm32f10x_rtc.h"
#include "stm32f10x_sdio.h"
#include "stm32f10x_spi.h"
#include "stm32f10x_tim.h"
#include "stm32f10x_usart.h"
#include "stm32f10x_wwdg.h"
#include "misc.h"
```



stm32f10x_conf.h这个文件还可配置是否使用“断言”编译选项，见 [代码清单:标准库-3](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id10) 。

代码清单:标准库-3 断言配置[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id10 "永久链接至代码")

```c
#ifdef  USE_FULL_ASSERT

    /**
    * @brief  The assert_param macro is used for  parameters check.
    * @param  expr: If expr is false, it calls assert_failed function
    *   which reports the name of the source file and the source
    *   line number of the call that failed.
    *   If expr is true, it returns no value.
    * @retval None
    */
    #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
    /* Exported functions ---------------------------------- */
    void assert_failed(uint8_t* file, uint32_t line);
    #else
    #define assert_param(expr) ((void)0)
    #endif /* USE_FULL_ASSERT */
```

在ST标准库的函数中，一般会包含输入参数检查，即上述代码中的“assert_param”宏，当参数不符合要求时，会调用“assert_failed”函数，这个函数默认是空的。

实际开发中使用断言时，先通过定义USE_FULL_ASSERT宏来使能断言，然后定义“assert_failed”函数，通常我们会让它调用printf函数输出错误说明。 使能断言后，程序运行时会检查函数的输入参数，当软件经过测试，可发布时，会取消USE_FULL_ASSERT宏来去掉断言功能，使程序全速运行。

### 10.1.2. 库各文件间的关系

前面向大家简单介绍了各个库文件的作用，库文件是直接包含进工程即可，丝毫不用修改，而有的文件就要我们在使用的时候根据具体的需要进行配置。 接下来从整体上把握一下各个文件在库工程中的层次或关系，这些文件对应到CMSIS标准架构上。见图 [库各文件关系](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id12) 。

![库各文件关系](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer008.png)

图 [库各文件关系](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id12) 描述了STM32库各文件之间的调用关系，在实际的使用库开发工程的过程中，我们把位于CMSIS层的文件包含进工程， 除了特殊系统时钟需要修改system_stm32f10x.c，其它文件丝毫不用修改，也不建议修改。

对于位于用户层的几个文件，就是我们在使用库的时候，针对不同的应用对库文件进行增删（用条件编译的方法增删）和改动的文件。

## 10.2. 使帮助文档

我坚信，授之以鱼不如授之以渔。官方资料是所有关于STM32知识的源头，所以在本小节介绍如何使用官方资料。官方的帮助手册， 是最好的教程，几乎包含了所有在开发过程中遇到的问题。这些资料已整理到了本书附录资料中。

### 10.2.1. 常用官方资料

- 《STM32F10X-中文参考手册》
    
    > 这个文件全方位介绍了STM32芯片的各种片上外设，它把STM32的时钟、存储器架构、及各种外设、寄存器都描述得清清楚楚。 当我们对STM32的外设感到困惑时，可查阅这个文档。以直接配置寄存器方式开发的话，查阅这个文档寄存器部分的频率会相当高，但这样效率太低了。
    
- 《STM32规格书》
    
    > 本文档相当于STM32的datasheet，包含了STM32芯片所有的引脚功能说明及存储器架构、芯片外设架构说明。 后面我们使用STM32其它外设时，常常需要查找这个手册，了解外设对应到STM32的哪个GPIO引脚。
    
- 《Cortex™-M3内核编程手册》
    
    > 本文档由ST公司提供，主要讲解STM32内核寄存器相关的说明，例如系统定时器、NVIC等核外设的寄存器。 这部分的内容是《STM32F10X-中文参考手册》没涉及到的内核部分的补充。相对来说，本文档虽然介绍了内核寄存器， 但不如以下两个文档详细，要了解内核时，可作为以下两个手册的配合资料使用。
    
- 《Cortex-M3权威指南》。
    
    > 这个手册是由ARM公司提供的，它详细讲解了Cortex内核的架构和特性，要深入了解Cortex-M内核，这是首选， 经典中的经典。这个手册也被翻译成中文，出版成书，我们配套的资料里面有提供中文版的电子版。
    
- 《stm32f10x_stdperiph_lib_um.chm》
    
    > 这个就是本章提到的库的帮助文档，在使用库函数时，我们最好通过查阅此文件来了解标准库提供了哪些外设、 函数原型或库函数的调用的方法。也可以直接阅读源码里面的函数的函数说明。
    

### 10.2.2. 初识库函数

所谓库函数，就是STM32的库文件中为我们编写好驱动外设的函数接口，我们只要调用这些库函数，就可以对STM32进行配置， 达到控制目的。我们可以不知道库函数是如何实现的，但我们调用函数必须要知道函数的功能、可传入的参数及其意义、和函数的返回值。

于是，有读者就问那么多函数我怎么记呀？我的回答是：会查就行了，哪个人记得了那么多。所以我们学会查阅库帮助文档 是很有必要的。

打开库帮助文档《stm32f10x_stdperiph_lib_um.chm》见图 [库帮助文档](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id16)

![库帮助文档](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer006.png)

层层打开文档的目录标签：

标签目录：Modules\STM32F10x_StdPeriph_Driver\

可看到STM32F10x _StdPeriph_Driver标签下有很多外设驱动文件的名字MISC、ADC、BKP、CAN等标签。

我们试着查看GPIO的“位设置函数GPIO_SetBits”看看，打开标签：

标签目录：Modules\STM32F10x_StdPeriph_Driver\GPIO\Functions\GPIO_SetBits 见图 [库帮助文档的函数说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/StdPeriph_Lib.html#id17) 。

![库帮助文档的函数说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/StdPer007.png)

利用这个文档，我们即使没有去看它的具体源代码，也知道要怎么利用它了。

如GPIO_SetBits， 函数的原型为void GPIO_SetBits(GPIO_TypeDef * GPIOx , uint16_t GPIO_Pin)。 它的功能是：输入一个类型为GPIO_TypeDef的指针GPIOx参数，选定要控制的GPIO端口； 输入GPIO_Pin_x宏，其中x指端口的引脚号，指定要控制的引脚。

其中输入的参数 GPIOx为ST标准库中定义的自定义数据类型，这两个传入参数均为结构体指针。初学时， 我们并不知道如GPIO_TypeDef这样的类型是什么意思，可以点击函数原型中带下划线的 GPIO_TypeDef 就可以查看这个类型的声明了。

就这样初步了解了一下库函数，读者就可以发现STM32的库是写得很优美的。每个函数和数据类型都符合见名知义的原则， 当然，这样的名称写起来特别长，而且对于我们来说要输入这么长的英文，很容易出错，所以在开发软件的时候， 在用到库函数的地方，直接把库帮助文档中的函数名称复制粘贴到工程文件就可以了。而且，配合MDK软件的代码自动补全功能，可以减少输入量。

有的用户觉得使用库文档麻烦，也可以直接查阅STM32标准库的源码，库帮助文档的说明都是根据源码生成的，所以直接看源码也可以了解函数功能。



# 11. 新建工程—库函数版

了解STM32的标准库文件之后，我们就可以使用它来建立工程了，因为用库新建工程的步骤较多，我们一般是使用库建立一个空的工程，作为工程模板。以后直接复制一份工程模板，在它之上进行开发。

本章的“工程模板”范例可在配套资料中找到，自己新建工程模版时可参考该工程。

## 11.1. 新建工程

本章内容所涉及的软件只供教学使用，不得用于商业用途。个人或公司因商业用途导致的法律责任，后果自负。

版本说明：MDK5.15 (MDK即KEIL软件)

版本号可从MDK软件的“Help–>About uVision”选项中查询到。

### 11.1.1. 新建本地工程文件夹

为了工程目录更加清晰，我们在本地电脑上新建一个“工程模板”文件夹，在它之下再新建6个文件夹，具体如下：

![工程目录文件夹清单](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro01.png)![工程文件夹目录](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro002.png)

在本地新建好文件夹后，把准备好的库文件添加到相应的文件夹下：

![工程目录文件夹内容清单](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro02.png)

### 11.1.2. 新建工程

打开KEIL5，新建一个工程，工程名根据喜好命名，我这里取Template（中文是模版的意思），保存在ProjectRVMDK（uv5）文件夹下。

![在KEIL5中新建工程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro003.jpeg)

#### 11.1.2.1. 选择CPU型号
这个根据你开发板使用的CPU具体的型号来选择， M3旗舰版选STM32F103ZE型号。如果这里没有出现你想要的CPU型号，或者一个型号都没有，那么肯定是你的KEIL5没有添加device库， KEIL5不像KEIL4那样自带了很多MCU的型号，KEIL5需要自己添加，关于如何添加请参考《如何安装KEIL5》这一章。

![选择具体的CPU型号](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro004.png)

#### 11.1.2.2. 在线添加库文件

等下我们手动添加库文件，这里我们点击关掉。

![库文件管理](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro005.png)

#### 11.1.2.3. 添加组文件夹

在新建的工程中添加5个组文件夹，用来存放各种不同的文件，文件从本地建好的工程文件夹下获取，双击组文件夹就会出现添加文件的路径，然后选择文件即可。

![工程内组文件夹内容清单](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro03.png)![如何在工程中添加文件夹](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro006.png)

#### 11.1.2.4. 添加文件

先把上面提到的文件从ST标准库中复制到工程模版对应文件夹的目录下，然后在新建的工程中添加这些文件，双击组文件夹就会出现添加文件的路径，然后选择文件即可。

![如何在工程中添加文件](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro007.png)

#### 11.1.2.5. 配置魔术棒选项卡
这一步的配置工作很重要，很多人串口用不了printf函数，编译有问题，下载有问题，都是这个步骤的配置出了错。

1. Target中选中微库“ Use MicroLib”，为的是在日后编写串口驱动的时候可以使用printf函数。
    

![添加微库](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro008.png)

2. 在Output选项卡中把输出文件夹定位到我们工程目录下的“output”文件夹， 如果想在编译的过程中生成hex文件，那么那Create HEX File选项勾上。
    

![配置 Output 选项卡](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro009.png)

3. 在Listing选项卡中把输出文件夹定位到我们工程目录下的“Listing”文件夹。
    

![配置 Listing 选项卡](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro010.png)

4. 在C/C++选项卡中添加处理宏及编译器编译的时候查找的头文件路径。如果头文件路径添加有误，则编译的时候会报错找不到头文件。
    

![配置 C/C++ 选项卡](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro011.png)

在这个选项中添加宏，就相当于我们在文件中使用“#define”语句定义宏一样。在编译器中添加宏的好处就是，只要用了这个模版，就不用源文件中修改代码。

- STM32F10X_HD宏：为了告诉STM32标准库，我们使用的芯片类型是STM32型号是大容量的，使STM32标准库根据我们选定的芯片型号来配置。
    
- USE_STDPERIPH_DRIVER宏：为了让stm32f10x.h包含stm32f10x_conf.h这个头文件。
    

“Include Paths ”这里添加的是头文件的路径，如果编译的时候提示说找不到头文件， 一般就是这里配置出了问题。你把头文件放到了哪个文件夹，就把该文件夹添加到这里即可。(请使用图中的方法用文件浏览器去添加路径，不要直接手打路径，容易出错)

#### 11.1.2.6. 仿真器配置

本书使用的仿真器是Fire-Debugger，可下载和仿真程序。Fire-Debugger支持XP/WIN7/WIN8/WIN10这几个操作系统， 无需安装驱动，免驱，使用非常方便，具体配置见如下图。

Debug中选择 CMSIS-DAP Debugger

![Debug中选择 CMSIS-DAP Debugger](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro012.png)

Utilities选择 Use Debug Driver

![Utilities选择 Use Debug Driver](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro013.png)

Settings选项配置

![Settings选项配置](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro014.png)

#### 11.1.2.7. 选择CPU型号

这一步的配置也不是配置一次之后完事，常常会因为各种原因需要重新选择，当你下载的时候，提示说找不到Device的时候， 请确保该配置是否正确。有时候下载程序之后，不会自动运行，要手动复位的时候，也回来看看这里的“Reset and Run”配置是否失效。 M4至尊版用的STM32的FLASH大小是1M，所以这里选择1M的容量，如果使用的是其他型号的，要根据实际情况选择。

![选择芯片型号](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Newpro015.png)

一个新的工程模版新建完毕。

## 11.2. 补充说明

1.如图在F1标准库工程组织中的CMSIS部分的core_cm3.c实际是不需要的，是否留在工程里面没有任何影响，所有例程中都没有使用到它，此文件为官方库保留，已被其他代替。

![supplementary](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/supplementary_1.png)

---

2.当要使用Keil的AC6编译器时，必须去掉core_cm3.c文件，因为有不兼容的编译器拓展语法，没有去掉时错误如下

![supplementary](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/supplementary_2.png)

---

将core_cm3.c从工程组织去掉即可，其他所有F1标准库例程都可以去掉。

![supplementary](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/supplementary_3.png)

---

切换AC5和AC6的位置如下，最新版本Keil默认会切换到AC6，初学者先简单理解为AC6比AC5编译速度更快，但可能输出比较多因为代码不规范的警告，如果不习惯先按教程例程默认用AC5即可。

![supplementary](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/supplementary_4.png)

---

更多关于编译器方面的说明参考此链接：[https://doc.embedfire.com/stm32_products/must_read/zh/latest/faq/questions.html#keilarm-compiler-v5-v6](https://doc.embedfire.com/stm32_products/must_read/zh/latest/faq/questions.html#keilarm-compiler-v5-v6)



# 12. GPIO输出—使用固件库点亮LED

本章参考资料：《STM32F10X-中文参考手册》GPIO和RCC章节、库帮助文档《stm32f10x_stdperiph_lib_um》。

利用库建立好的工程模板，就可以方便地使用STM32标准库编写应用程序了，可以说从这一章我们真正开始迈入STM32固件库开发的大门。

LED灯的控制使用到GPIO外设的基本输出功能，本章中不再赘述GPIO外设的概念，如您忘记了，可重读前面“使用寄存器点亮LED灯—GPIO框图剖析”小节， STM32标准库中GPIO初始化结构体GPIO_TypeDef的定义与“自己写库—构建库函数雏形的定义引脚模式的枚举类型”小节中讲解的相同。

## 12.1. 硬件设计

在本教程中STM32芯片与LED灯的连接见图 [LED硬件原理图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#led) ，这是一个RGB灯，里面由红蓝绿三个小灯构成， 使用PWM控制时可以混合成256不同的颜色。

![LED硬件原理图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/GPIOou002.png)

这些LED灯的阴极都是连接到STM32的GPIO引脚，只要我们控制GPIO引脚的电平输出状态，即可控制LED灯的亮灭。若您使用的实验板LED灯的连接方式或引脚不一样， 只需根据我们的工程修改引脚即可，程序的控制原理相同。

## 12.2. 软件设计

这里只讲解核心部分的代码，有些变量的设置，头文件的包含等可能不会涉及到，完整的代码请参考本章配套的工程。

为了使工程更加有条理，我们把LED灯控制相关的代码独立分开存储，方便以后移植。在“工程模板”之上新建“bsp_led.c”及“bsp_led.h”文件， 其中的“bsp”即Board Support Packet的缩写(板级支持包)，这些文件也可根据您的喜好命名， 这些文件不属于STM32标准库的内容，是由我们自己根据应用需要编写的。

### 12.2.1. 编程要点

> 1. 使能GPIO端口时钟；
>     
> 2. 初始化GPIO目标引脚为推挽输出模式；
>     
> 3. 编写简单测试程序，控制GPIO引脚输出高、低电平。
>     

### 12.2.2. 代码分析

#### 12.2.2.1. LED灯引脚宏定义

在编写应用程序的过程中，要考虑更改硬件环境的情况，例如LED灯的控制引脚与当前的不一样，我们希望程序只需要做最小的修改即可在新的环境正常运行。 这个时候一般把硬件相关的部分使用宏来封装，若更改了硬件环境，只修改这些硬件相关的宏即可，这些定义一般存储在头文件， 即本例子中的“bsp_led.h”文件中，见 [代码清单:GPIO输出-1](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-1) 。

代码清单:GPIO输出-1 LED控制引脚相关的宏[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-1 "永久链接至代码")

```c
// R-红色
#define LED1_GPIO_PORT      GPIOB
#define LED1_GPIO_CLK       RCC_APB2Periph_GPIOB
#define LED1_GPIO_PIN       GPIO_Pin_5
// G-绿色
#define LED2_GPIO_PORT      GPIOB
#define LED2_GPIO_CLK       RCC_APB2Periph_GPIOB
#define LED2_GPIO_PIN       GPIO_Pin_0
// B-蓝色
#define LED3_GPIO_PORT      GPIOB
#define LED3_GPIO_CLK       RCC_APB2Periph_GPIOB
#define LED3_GPIO_PIN       GPIO_Pin_1
```

以上代码分别把控制LED灯的GPIO端口、GPIO引脚号以及GPIO端口时钟封装起来了。在实际控制的时候我们就直接用这些宏，以达到应用代码硬件无关的效果。

其中的GPIO时钟宏“RCC_APB2Periph_GPIOB”是STM32标准库定义的GPIO端口时钟相关的宏，它的作用与“GPIO_Pin_x”这类宏类似，是用于指示寄存器位的， 方便库函数使用，下面初始化GPIO时钟的时候可以看到它的用法。

#### 12.2.2.2. 控制LED灯亮灭状态的宏定义

为了方便控制LED灯，我们把LED灯常用的亮、灭及状态反转的控制也直接定义成宏，见 [代码清单:GPIO输出-2](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-2) 。

代码清单:GPIO输出-2 控制LED亮灭的宏[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-2 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68|/* 直接操作寄存器的方法控制IO */<br>#define digitalHi(p,i)       {p->BSRR=i;}    //输出为高电平<br>#define digitalLo(p,i)       {p->BRR=i;}     //输出低电平<br>#define digitalToggle(p,i)   {p->ODR ^=i;}   //输出反转状态<br><br>/* 定义控制IO的宏 */<br>#define LED1_TOGGLE       digitalToggle(LED1_GPIO_PORT,LED1_GPIO_PIN)<br>#define LED1_OFF          digitalHi(LED1_GPIO_PORT,LED1_GPIO_PIN)<br>#define LED1_ON           digitalLo(LED1_GPIO_PORT,LED1_GPIO_PIN)<br><br>#define LED2_TOGGLE       digitalToggle(LED2_GPIO_PORT,LED2_GPIO_PIN)<br>#define LED2_OFF          digitalHi(LED2_GPIO_PORT,LED2_GPIO_PIN)<br>#define LED2_ON           digitalLo(LED2_GPIO_PORT,LED2_GPIO_PIN)<br><br>#define LED3_TOGGLE       digitalToggle(LED2_GPIO_PORT,LED3_GPIO_PIN)<br>#define LED3_OFF          digitalHi(LED2_GPIO_PORT,LED3_GPIO_PIN)<br>#define LED3_ON           digitalLo(LED2_GPIO_PORT,LED3_GPIO_PIN)<br><br>/* 基本混色，后面高级用法使用PWM可混出全彩颜色,且效果更好 */<br><br>//红<br>#define LED_RED  \<br>                    LED1_ON;\<br>                    LED2_OFF\<br>                    LED3_OFF<br><br>//绿<br>#define LED_GREEN       \<br>                    LED1_OFF;\<br>                    LED2_ON\<br>                    LED3_OFF<br><br>//蓝<br>#define LED_BLUE    \<br>                    LED1_OFF;\<br>                    LED2_OFF\<br>                    LED3_ON<br><br>//黄(红+绿)<br>#define LED_YELLOW  \<br>                    LED1_ON;\<br>                    LED2_ON\<br>                    LED3_OFF<br>//紫(红+蓝)<br>#define LED_PURPLE  \<br>                    LED1_ON;\<br>                    LED2_OFF\<br>                    LED3_ON<br><br>//青(绿+蓝)<br>#define LED_CYAN \<br>                    LED1_OFF;\<br>                    LED2_ON\<br>                    LED3_ON<br><br>//白(红+绿+蓝)<br>#define LED_WHITE   \<br>                    LED1_ON;\<br>                    LED2_ON\<br>                    LED3_ON<br><br>//黑(全部关闭)<br>#define LED_RGBOFF  \<br>                    LED1_OFF;\<br>                    LED2_OFF\<br>                    LED3_OFF|

这部分宏控制LED亮灭的操作是直接向BSRR、BRR和ODR这三个寄存器写入控制指令来实现的，对BSRR写1输出高电平， 对BRR写1输出低电平，对ODR寄存器某位进行异或操作可反转位的状态。

RGB彩灯可以实现混色，如最后一段代码我们控制红灯和绿灯亮而蓝灯灭，可混出黄色效果。

代码中的“\”是C语言中的续行符语法，表示续行符的下一行与续行符所在的代码是同一行。 代码中因为宏定义关键字“#define”只是对当前行有效，所以我们使用续行符来连接起来， 以下的代码是等效的：

#define LED_YELLOW LED1_ON; LED2_ON; LED3_OFF

应用续行符的时候要注意，在“\”后面不能有任何字符(包括注释、空格)，只能直接回车。

#### 12.2.2.3. LED GPIO初始化函数

利用上面的宏，编写LED灯的初始化函数，见 [代码清单:GPIO输出-3](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-3) 。

代码清单:GPIO输出-3 LED GPIO初始化函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-3 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42|void LED_GPIO_Config(void)<br>{<br>    /*定义一个GPIO_InitTypeDef类型的结构体*/<br>    GPIO_InitTypeDef GPIO_InitStructure;<br><br>    /*开启LED相关的GPIO外设时钟*/<br>    RCC_APB2PeriphClockCmd( LED1_GPIO_CLK\|<br>                            LED2_GPIO_CLK\|<br>                            LED3_GPIO_CLK, ENABLE);<br>    /*选择要控制的GPIO引脚*/<br>    GPIO_InitStructure.GPIO_Pin = LED1_GPIO_PIN;<br><br>    /*设置引脚模式为通用推挽输出*/<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br><br>    /*设置引脚速率为50MHz */<br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>    /*调用库函数，初始化GPIO*/<br>    GPIO_Init(LED1_GPIO_PORT, &GPIO_InitStructure);<br><br>    /*选择要控制的GPIO引脚*/<br>    GPIO_InitStructure.GPIO_Pin = LED2_GPIO_PIN;<br><br>    /*调用库函数，初始化GPIO*/<br>    GPIO_Init(LED2_GPIO_PORT, &GPIO_InitStructure);<br><br>    /*选择要控制的GPIO引脚*/<br>    GPIO_InitStructure.GPIO_Pin = LED3_GPIO_PIN;<br><br>    /*调用库函数，初始化GPIOF*/<br>    GPIO_Init(LED3_GPIO_PORT, &GPIO_InitStructure);<br><br>    /* 关闭所有led灯   */<br>    GPIO_SetBits(LED1_GPIO_PORT, LED1_GPIO_PIN);<br><br>    /* 关闭所有led灯   */<br>    GPIO_SetBits(LED2_GPIO_PORT, LED2_GPIO_PIN);<br><br>    /* 关闭所有led灯   */<br>    GPIO_SetBits(LED3_GPIO_PORT, LED3_GPIO_PIN);<br>}|

整个函数与“构建库函数雏形”章节中的类似，主要区别是硬件相关的部分使用宏来代替，初始化GPIO端口时钟时也采用了STM32库函数，函数执行流程如下：

1. 使用GPIO_InitTypeDef定义GPIO初始化结构体变量，以便下面用于存储GPIO配置。
    
2. 调用库函数RCC_APB2PeriphClockCmd来使能LED灯的GPIO端口时钟，在前面的章节中我们是直接向RCC寄存器赋值来使能时钟的， 不如这样直观。该函数有两个输入参数，第一个参数用于指示要配置的时钟，如本例中的“RCC_APB2Periph_GPIOB”， 应用时我们使用“|”操作同时配置3个LED灯的时钟；函数的第二个参数用于设置状态，可输入“Disable”关闭或“Enable”使能时钟。
    
3. 向GPIO初始化结构体赋值，把引脚初始化成推挽输出模式，其中的GPIO_Pin使用宏“LEDx_GPIO_PIN”来赋值，使函数的实现方便移植。
    
4. 使用以上初始化结构体的配置，调用GPIO_Init函数向寄存器写入参数，完成GPIO的初始化， 这里的GPIO端口使用“LEDx_GPIO_PORT”宏来赋值，也是为了程序移植方便。
    
5. 使用同样的初始化结构体，只修改控制的引脚和端口，初始化其它LED灯使用的GPIO引脚。
    
6. 使用宏控制RGB灯默认关闭。
    

#### 12.2.2.4. 主函数

编写完LED灯的控制函数后，就可以在main函数中测试了，见 [代码清单:GPIO输出-4](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-4) 。

代码清单:GPIO输出-4 控制LED灯 ，main文件[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-4 "永久链接至代码")

```c
#include "stm32f10x.h"
#include "./led/bsp_led.h"

#define SOFT_DELAY Delay(0x0FFFFF);

void Delay(__IO u32 nCount);

/**
* @brief  主函数
* @param  无
* @retval 无
*/
int main(void)
{
    /* LED 端口初始化 */
    LED_GPIO_Config();

    while (1)
    {
        LED1_ON;              // 亮
        SOFT_DELAY;
        LED1_OFF;          // 灭

        LED2_ON;             // 亮
        SOFT_DELAY;
        LED2_OFF;          // 灭

        LED3_ON;             // 亮
        SOFT_DELAY;
        LED3_OFF;          // 灭

        /*轮流显示 红绿蓝黄紫青白 颜色*/
        LED_RED;
        SOFT_DELAY;

        LED_GREEN;
        SOFT_DELAY;

        LED_BLUE;
        SOFT_DELAY;

        LED_YELLOW;
        SOFT_DELAY;

        LED_PURPLE;
        SOFT_DELAY;

        LED_CYAN;
        SOFT_DELAY;

        LED_WHITE;
        SOFT_DELAY;

        LED_RGBOFF;
        SOFT_DELAY;
    }
}

void Delay(__IO uint32_t nCount)     //简单的延时函数
{
    for (; nCount != 0; nCount--);
} 
```

在main函数中，调用我们前面定义的LED_GPIO_Config初始化好LED的控制引脚，然后直接调用各种控制LED灯亮灭的宏来实现LED灯的控制。

以上，就是一个使用STM32标准软件库开发应用的流程。

### 12.2.3. 下载验证

把编译好的程序下载到开发板并复位，可看到RGB彩灯轮流显示不同的颜色。

## 12.3. STM32标准库补充知识

### 12.3.1. SystemInit函数去哪了？

在前面章节中我们自己建工程的时候需要定义一个SystemInit空函数，但是在这个用STM32标准库的工程却没有这样做，SystemInit函数去哪了呢？

这个函数在STM32标准库的“system_stm32f10x.c”文件中定义了，而我们的工程已经包含该文件。标准库中的SystemInit函数把STM32芯片的系统时钟设置成了72MHz， 即此时AHB时钟频率为72MHz，APB2为72MHz，APB1为36MHz。当STM32芯片上电后，执行启动文件中的指令后，会调用该函数，设置系统时钟为以上状态。

### 12.3.2. 断言

细心对比过前几章我们自己定义的GPIO_Init函数与STM32标准库中同名函数的读者，会发现标准库中的函数内容多了一些乱七八糟的东西， 就是断言，具体见 [代码清单:GPIO输出-5](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-5) 。

代码清单:GPIO输出-5 GPIO_Init函数的断言部分[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-5 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10|void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)<br>{<br>    uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;<br><br>    /* Check the parameters */<br>    assert_param(IS_GPIO_ALL_PERIPH(GPIOx));<br>    assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));<br>    assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));<br><br>    /* ------- 以下内容省略，跟前面我们定义的函数内容相同----- */|

基本上每个库函数的开头都会有这样类似的内容，这里的“assert_param”实际是一个宏，在库函数中它用于检查输入参数是否符合要求， 若不符合要求则执行某个函数输出警告，“assert_param”的定义见 [代码清单:GPIO输出-6](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-6) 。

代码清单:GPIO输出-6 stm32f10x_conf.h文件中关于断言的定义[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-6 "永久链接至代码")

```c
#ifdef  USE_FULL_ASSERT
/**
* @brief  assert_param 宏用于函数的输入参数检查
* @param  expr:若expr值为假，则调用assert_failed函数
*             报告文件名及错误行号
*              若expr值为真，则不执行操作
*/
#define assert_param(expr)    ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
/* 错误输出函数 ------------------------------------------------------- */
void assert_failed(uint8_t* file, uint32_t line);
#else
#define assert_param(expr) ((void)0)
#endif 
```

这段代码的意思是，假如我们不定义“USE_FULL_ASSERT”宏，那么“assert_param”就是一个空的宏(#else与#endif之间的语句生效)，没有任何操作。 从而所有库函数中的assert_param实际上都无意义，我们就当看不见好了。

假如我们定义了“USE_FULL_ASSERT”宏，那么“assert_param”就是一个有操作的语句(#if与#else之间的语句生效)， 该宏对参数expr使用C语言中的问号表达式进行判断，若expr值为真，则无操作(void 0)，若表达式的值为假， 则调用“assert_failed”函数，且该函数的输入参数为“__FILE__”及“__LINE__”， 这两个参数分别代表 “assert_param”宏被调用时所在的“文件名”及“行号”。

但库文件只对“assert_failed”写了函数声明，没有写函数定义，实际用时需要用户来定义， 我们一般会用printf函数来输出这些信息，见 [代码清单:GPIO输出-7](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-7) 。

代码清单:GPIO输出-7 assert_failed 输出错误信息[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-7 "永久链接至代码")

|   |   |
|---|---|
|1<br>2<br>3<br>4|void assert_failed(uint8_t * file, uint32_t line)<br>{<br>    printf(“\r\n 输入参数错误，错误文件名=%s,行号=%s”,file,line);<br>}|

注意在我们的这个LED工程中，还不支持printf函数(在USART外设章节会讲解)，想测试assert_failed输出的读者， 可以在这个函数中做点亮红色LED灯的操作，作为警告输出测试。

那么为什么函数输入参数不对的时候，assert_param宏中的expr参数值会是假呢？这要回到GPIO_Init函数，看它对assert_param宏的调用， 它被调用时分别以“IS_GPIO_ALL_PERIPH(GPIOx)”、“IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin)”等作为输入参数，也就是说被调用时， expr实际上是一条针对输入参数的判断表达式。例如“IS_GPIO_PIN”的宏定义：

#define IS_GPIO_PIN(PIN) ((PIN) != (uint32_t)0x00)

若它的输入参数 PIN 值为0，则表达式的值为假，PIN非0时表达式的值为真。 我们知道用于选择GPIO引脚号的宏“GPIO_Pin_x”的值至少有一个数据位为1， 这样的输入参数才有意义，若GPIO_InitStruct->GPIO_Pin的值为0，输入参数就无效了。配合“IS_GPIO_PIN”这句表达式， “assert_param”就实现了检查输入参数的功能。对assert_param宏的其它调用方式类似，大家可以自己看库源码来研究一下。

### 12.3.3. Doxygen注释规范

在STM32标准库以及我们自己编写的“bsp_led.c”文件中，可以看到一些比较特别的注释，类似 [代码清单:GPIO输出-8](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-8) 。

代码清单:GPIO输出-8 Doxygen注释规范[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-8 "永久链接至代码")

|   |   |
|---|---|
|1<br>2<br>3<br>4<br>5|/**<br>* @brief  初始化控制LED的IO<br>* @param  无<br>* @retval 无<br>*/|

这是一种名为“Doxygen”的注释规范，如果在工程文件中按照这种规范去注释，可以使用Doxygen软件自动根据注释生成帮助文档。 我们所说非常重要的库帮助文档《stm32f10x_stdperiph_lib_um.chm》，就是由该软件根据库文件的注释生成的。 关于Doxygen注释规范本教程不作讲解，感兴趣的读者可自行搜索网络上的资料学习。

### 12.3.4. 防止头文件重复包含

在STM32标准库的所有头文件以及我们自己编写的“bsp_led.h”头文件中，可看到类似 [代码清单:GPIO输出-9](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-9) 的宏定义。 它的功能是防止头文件被重复包含，避免引起编译错误。

代码清单:GPIO输出-9 防止头文件重复包含的宏[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_output.html#gpio-9 "永久链接至代码")

```c
#ifndef __LED_H
#define __LED_H

/*此处省略头文件的具体内容*/

#endif /* end of __LED_H */
```

在头文件的开头，使用“#ifndef”关键字，判断标号“__LED_H”是否被定义，若没有被定义，则从“#ifndef”至“#endif”关键字之间的内容都有效， 也就是说，这个头文件若被其它文件“#include”，它就会被包含到其该文件中了，且头文件中紧接着使用“#define”关键字定义上面判断的标号“__LED_H”。 当这个头文件被同一个文件第二次“#include”包含的时候， 由于有了第一次包含中的“#define __LED_H”定义，这时再判断“#ifndef__LED_H”， 判断的结果就是假了，从“#ifndef”至“#endif”之间的内容都无效，从而防止了同一个头文件被包含多次，编译时就不会出现“redefine（重复定义）”的错误了。

一般来说，我们不会直接在C的源文件写两个“#include”来包含同一个头文件，但可能因为头文件内部的包含导致重复，这种代码主要是避免这样的问题。 如“bsp_led.h”文件中使用了“#include “stm32f10x.h””语句，按习惯， 可能我们写主程序的时候会在main文件写“#include “bsp_led.h” 及#include “stm32f10x.h””， 这个时候“stm32f10x.h”文件就被包含两次了，如果没有这种机制，就会出错。

至于为什么要用两个下划线来定义“__LED_H”标号，其实这只是防止它与其它普通宏定义重复了， 如我们用“GPIO_PIN_0”来代替这个判断标号，就会因为stm32f10x.h已经定义了GPIO_PIN_0，结果导致“bsp_led.h”文件无效了，“bsp_led.h”文件一次都没被包含。


# 13. GPIO输入—按键检测

本章参考资料：《STM32F10X-中文参考手册》、库帮助文档《stm32f10x_stdperiph_lib_um》。

按键检测使用到GPIO外设的基本输入功能，本章中不再赘述GPIO外设的概念，如您忘记了，可重读前面“使用寄存器点亮LED灯—GPIO框图剖析”小节， STM32标准库中GPIO初始化结构体GPIO_TypeDef的定义与“自己写库—构建库函数雏形的定义引脚模式的枚举类型”小节中讲解的相同。

## 13.1. 硬件设计

按键机械触点断开、闭合时，由于触点的弹性作用，按键开关不会马上稳定接通或一下子断开， 使用按键时会产生图 [按键抖动说明图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_input.html#id2) 中的带波纹信号，需要用软件消抖处理滤波，不方便输入检测。本实验板连接的按键带硬件消抖功能， 见图 [按键原理图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_input.html#id3) ，它利用电容充放电的延时，消除了波纹，从而简化软件的处理，软件只需要直接检测引脚的电平即可。

![按键抖动说明图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/GPIOin002.jpg)![按键原理图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/GPIOin003.png)

从按键的原理图可知，这些按键在没有被按下的时候，GPIO引脚的输入状态为低电平(按键所在的电路不通，引脚接地)，当按键按下时， GPIO引脚的输入状态为高电平(按键所在的电路导通，引脚接到电源)。只要我们检测引脚的输入电平，即可判断按键是否被按下。

若您使用的实验板按键的连接方式或引脚不一样，只需根据我们的工程修改引脚即可，程序的控制原理相同。

## 13.2. 软件设计

同LED的工程，为了使工程更加有条理，我们把按键相关的代码独立分开存储，方便以后移植。在“工程模板”之上新建“bsp_key.c”及“bsp_key.h”文件， 这些文件也可根据您的喜好命名，这些文件不属于STM32标准库的内容，是由我们自己根据应用需要编写的。

### 13.2.1. 编程要点

> 1. 使能GPIO端口时钟；
>     
> 2. 初始化GPIO目标引脚为输入模式(浮空输入)；
>     
> 3. 编写简单测试程序，检测按键的状态，实现按键控制LED灯。
>     

### 13.2.2. 代码分析

#### 13.2.2.1. 按键引脚宏定义

同样，在编写按键驱动时，也要考虑更改硬件环境的情况。我们把按键检测引脚相关的宏定义到 “bsp_key.h”文件中， 见 [代码清单:GPIO输入-1](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_input.html#gpio-1) 。

代码清单:GPIO输入-1 按键检测引脚相关的宏[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_input.html#gpio-1 "永久链接至代码")

```c
//  引脚定义
#define    KEY1_GPIO_CLK     RCC_APB2Periph_GPIOA
#define    KEY1_GPIO_PORT    GPIOA
#define    KEY1_GPIO_PIN     GPIO_Pin_0

#define    KEY2_GPIO_CLK     RCC_APB2Periph_GPIOC
#define    KEY2_GPIO_PORT    GPIOC
#define    KEY2_GPIO_PIN     GPIO_Pin_13
```

以上代码根据按键的硬件连接，把检测按键输入的GPIO端口、GPIO引脚号以及GPIO端口时钟封装起来了。

#### 13.2.2.2. 按键 GPIO初始化函数
利用上面的宏，编写按键的初始化函数，见 [代码清单:GPIO输入-2](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_input.html#gpio-2) 。

代码清单:GPIO输入-2 按键GPIO初始化函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_input.html#gpio-2 "永久链接至代码")

```c
void Key_GPIO_Config(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    /*开启按键端口的时钟*/
    RCC_APB2PeriphClockCmd(KEY1_GPIO_CLK|KEY2_GPIO_CLK,ENABLE);

    //选择按键的引脚
    GPIO_InitStructure.GPIO_Pin = KEY1_GPIO_PIN;
    // 设置按键的引脚为浮空输入
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    //使用结构体初始化按键
    GPIO_Init(KEY1_GPIO_PORT, &GPIO_InitStructure);

    //选择按键的引脚
    GPIO_InitStructure.GPIO_Pin = KEY2_GPIO_PIN;
    //设置按键的引脚为浮空输入
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    //使用结构体初始化按键
    GPIO_Init(KEY2_GPIO_PORT, &GPIO_InitStructure);
}
```

同为GPIO的初始化函数，初始化的流程与“LED GPIO初始化函数”章节中的类似，主要区别是引脚的模式。函数执行流程如下：

1. 使用GPIO_InitTypeDef定义GPIO初始化结构体变量，以便下面用于存储GPIO配置。
    
2. 调用库函数RCC_APB2PeriphClockCmd来使能按键的GPIO端口时钟，调用时我们使用“|”操作同时配置两个按键的时钟。
    
3. 向GPIO初始化结构体赋值，把引脚初始化成浮空输入模式，其中的GPIO_Pin使用宏“KEYx_GPIO_PIN”来赋值，使函数的实现方便移植。 由于引脚的默认电平受按键电路影响，所以设置成浮空输入。
    
4. 使用以上初始化结构体的配置，调用GPIO_Init函数向寄存器写入参数，完成GPIO的初始化， 这里的GPIO端口使用“KEYx_GPIO_PORT”宏来赋值，也是为了程序移植方便。
    
5. 使用同样的初始化结构体，只修改控制的引脚和端口，初始化其它按键检测时使用的GPIO引脚。
    

#### 13.2.2.3. 检测按键的状态

初始化按键后，就可以通过检测对应引脚的电平来判断按键状态了，见 [代码清单:GPIO输入-3](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_input.html#gpio-3) 。

代码清单:GPIO输入-3 检测按键的状态[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_input.html#gpio-3 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25|/** 按键按下标置宏<br>* 按键按下为高电平，设置 KEY_ON=1， KEY_OFF=0<br>* 若按键按下为低电平，把宏设置成KEY_ON=0 ，KEY_OFF=1 即可<br>*/<br>#define KEY_ON  1<br>#define KEY_OFF 0<br><br>/**<br>* @brief   检测是否有按键按下<br>* @param  GPIOx:具体的端口, x可以是（A...G）<br>* @param  GPIO_PIN:具体的端口位， 可以是GPIO_PIN_x（x可以是0...15）<br>* @retval  按键的状态<br>*     @arg KEY_ON:按键按下<br>*     @arg KEY_OFF:按键没按下<br>*/<br>uint8_t Key_Scan(GPIO_TypeDef* GPIOx,uint16_t GPIO_Pin)<br>{<br>    /*检测是否有按键按下 */<br>    if (GPIO_ReadInputDataBit(GPIOx,GPIO_Pin) == KEY_ON ) {<br>        /*等待按键释放 */<br>        while (GPIO_ReadInputDataBit(GPIOx,GPIO_Pin) == KEY_ON);<br>        return  KEY_ON;<br>    } else<br>        return KEY_OFF;<br>}|

在这里我们定义了一个Key_Scan函数用于扫描按键状态。GPIO引脚的输入电平可通过读取IDR寄存器对应的数据位来感知， 而STM32标准库提供了库函数GPIO_ReadInputDataBit来获取位状态，该函数输入GPIO端口及引脚号，函数返回该引脚的电平状态，高电平返回1， 低电平返回0。Key_Scan函数中以GPIO_ReadInputDataBit的返回值与自定义的宏“KEY_ON”对比，若检测到按键按下，则使用while循环持续检测按键状态， 直到按键释放，按键释放后Key_Scan函数返回一个“KEY_ON”值；若没有检测到按键按下，则函数直接返回“KEY_OFF”。 若按键的硬件没有做消抖处理，需要在这个Key_Scan函数中做软件滤波，防止波纹抖动引起误触发。

#### 13.2.2.4. 主函数

接下来我们使用主函数编写按键检测流程，见 [代码清单:GPIO输入-4](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_input.html#gpio-4) 。

代码清单:GPIO输入-4 按键检测主函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_input.html#gpio-4 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26|/**<br>* @brief  主函数<br>* @param  无<br>* @retval 无<br>*/<br>int main(void)<br>{<br>    /* LED 端口初始化 */<br>    LED_GPIO_Config();<br><br>    /*初始化按键*/<br>    Key_GPIO_Config();<br><br>    /* 轮询按键状态，若按键按下则反转LED */<br>    while (1) {<br>        if ( Key_Scan(KEY1_GPIO_PORT,KEY1_PIN) == KEY_ON  ) {<br>            /*LED1反转*/<br>            LED1_TOGGLE;<br>        }<br><br>        if ( Key_Scan(KEY2_GPIO_PORT,KEY2_PIN) == KEY_ON  ) {<br>            /*LED2反转*/<br>            LED2_TOGGLE;<br>        }<br>    }<br>}|

代码中初始化LED灯及按键后，在while函数里不断调用Key_Scan函数，并判断其返回值，若返回值表示按键按下，则反转LED灯的状态。

### 13.2.3. 下载验证

把编译好的程序下载到开发板并复位，按下按键可以控制LED灯亮、灭状态。


# 14. GPIO—位带操作

本章参考资料：《STM32F10X-中文参考手册》存储器和总线构架章节、GPIO章节， 《CM3权威指南CnR2》存储器系统章节。学习本章时，配套这些参考资料学习效果会更佳。

## 14.1. 位带简介

位操作就是可以单独的对一个比特位读和写，这个在51单片机中非常常见。51单片机中通过关键字sbit来实现位定义， STM32没有这样的关键字，而是通过访问位带别名区来实现。

在STM32中，有两个地方实现了位带，一个是SRAM区的最低1MB空间，另一个是外设区最低1MB空间。 这两个1MB的空间除了可以像正常的RAM一样操作外，他们还有自己的位带别名区，位带别名区把这1MB的空间的每一个位膨胀成一个32位的字， 当访问位带别名区的这些字时，就可以达到访问位带区某个比特位的目的。

![STM32位带示意图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/GPIObi002.png)

### 14.1.1. 外设位带区

外设外带区的地址为：0X40000000~0X40100000，大小为1MB，这1MB的大小在103系列大/中/小容量型号的单片机中包含了片上外设的全部寄存器， 这些寄存器的地址为：0X40000000~0X40029FFF。外设位带区经过膨胀后的位带别名区地址为：0X42000000~0X43FFFFFF， 这个地址仍然在CM3 片上外设的地址空间中。在103系列大/中小容量型号的单片机里面，0X40030000~0X4FFFFFFF属于保留地址， 膨胀后的32MB位带别名区刚好就落到这个地址范围内，不会跟片上外设的其他寄存器地址重合。

STM32的全部寄存器都可以通过访问位带别名区的方式来达到访问原始寄存器比特位的效果，这比51单片机强大很多。 因为51单片机里面并不是所有的寄存器都是可以比特位操作，有些寄存器还是得字节操作，比如SBUF。

虽然说全部寄存器都可以实现比特操作，但我们在实际项目中并不会这么做，甚至不会这么做。有时候为了特定的项目需要， 比如需要频繁的操作很多IO口，这个时候我们可以考虑把IO相关的寄存器实现比特操作。

### 14.1.2. SRAM位带区

SRAM的位带区的地址为：0X2000 0000~X2010 0000，大小为1MB，经过膨胀后的位带别名区地址为：0X2200 0000~0X23FF FFFF， 大小为32MB。操作SRAM的比特位这个用得很少。

### 14.1.3. 位带区和位带别名区地址转换

位带区的一个比特位经过膨胀之后，虽然变大到4个字节，但是还是LSB才有效。有人会问这不是浪费空间吗， 要知道STM32的系统总线是32位的，按照4个字节访问的时候是最快的，所以膨胀成4个字节来访问是最高效的。

我们可以通过指针的形式访问位带别名区地址从而达到操作位带区比特位的效果。那这两个地址直接如何转换，我们简单介绍一下。

#### 14.1.3.1. 外设位带别名区地址

对于片上外设位带区的某个比特，记它所在字节的地址为 A,位序号为 n(0<=n<=31)(n的范围根据具体寄存器能控制的位决定)，则该比特在别名区的地址为：

AliasAddr= =0x42000000+ (A-0x40000000)*8*4 +n*4

0X42000000是外设位带别名区的起始地址，0x40000000是外设位带区的起始地址，（A-0x40000000）表示该比特前面有多少个字节， 一个字节有8位，所以*8，一个位膨胀后是4个字节，所以*4，n表示该比特在A地址的序号，因为一个位经过膨胀后是四个字节，所以也*4。

#### 14.1.3.2. SRAM位带别名区地址

对于SRAM位带区的某个比特，记它所在字节的地址为 A,位序号为 n(0<=n<=31)(n的范围根据具体寄存器能控制的位决定)，则该比特在别名区的地址为：

AliasAddr= =0x22000000+ (A-0x20000000)*8*4 +n*4

公式分析同上。

#### 14.1.3.3. 统一公式

为了方便操作，我们可以把这两个公式合并成一个公式，把“位带地址+位序号”转换成别名区地址统一成一个宏。

```
// 把“位带地址+位序号”转换成别名地址的宏
#define BITBAND(addr, bitnum) ((addr & 0xF0000000)+0x02000000+((addr & 0x00FFFFFF)<<5)+(bitnum<<2))
```

addr & 0xF0000000是为了区别SRAM还是外设，实际效果就是取出4或者2，如果是外设， 则取出的是4，+0X02000000之后就等于0X42000000，0X42000000是外设别名区的起始地址。 如果是SRAM，则取出的是2，+0X02000000之后就等于0X22000000，0X22000000是SRAM别名区的起始地址。

addr & 0x00FFFFFF 屏蔽了高三位，相当于减去0X20000000或者0X40000000，但是为什么是屏蔽高三位？ 因为外设的最高地址是：0X20100000，跟起始地址0X20000000相减的时候，总是低5位才有效， 所以干脆就把高三位屏蔽掉来达到减去起始地址的效果，具体屏蔽掉多少位跟最高地址有关。SRAM同理分析即可。 <<5相当于*8*4，<<2相当于*4，这两个我们在上面分析过。

最后我们就可以通过指针的形式操作这些位带别名区地址，最终实现位带区的比特位操作。
```
// 把一个地址转换成一个指针
#define MEM_ADDR(addr)  *((volatile unsigned long  *)(addr))

// 把位带别名区地址转换成指针
#define BIT_ADDR(addr, bitnum)   MEM_ADDR(BITBAND(addr, bitnum))
```
## 14.2. GPIO位带操作

外设的位带区，覆盖了全部的片上外设的寄存器，我们可以通过宏为每个寄存器的位都定义一个位带别名地址，从而实现位操作。 但这个在实际项目中不是很现实，也很少人会这么做，我们在这里仅仅演示下GPIO中ODR和IDR这两个寄存器的位操作。

从手册中我们可以知道ODR和IDR这两个寄存器对应GPIO基址的偏移是12和8，我们先实现这两个寄存器的地址映射，其中GPIOx_BASE在库函数里面有定义。

### 14.2.1. GPIO 寄存器映射

代码清单:位带操作-1 GPIO ODR 和 IDR 寄存器映射[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_bit.html#id9 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16|// GPIO ODR 和 IDR 寄存器地址映射<br>#define GPIOA_ODR_Addr    (GPIOA_BASE+12) //0x4001080C<br>#define GPIOB_ODR_Addr    (GPIOB_BASE+12) //0x40010C0C<br>#define GPIOC_ODR_Addr    (GPIOC_BASE+12) //0x4001100C<br>#define GPIOD_ODR_Addr    (GPIOD_BASE+12) //0x4001140C<br>#define GPIOE_ODR_Addr    (GPIOE_BASE+12) //0x4001180C<br>#define GPIOF_ODR_Addr    (GPIOF_BASE+12) //0x40011A0C<br>#define GPIOG_ODR_Addr    (GPIOG_BASE+12) //0x40011E0C<br><br>#define GPIOA_IDR_Addr    (GPIOA_BASE+8)  //0x40010808<br>#define GPIOB_IDR_Addr    (GPIOB_BASE+8)  //0x40010C08<br>#define GPIOC_IDR_Addr    (GPIOC_BASE+8)  //0x40011008<br>#define GPIOD_IDR_Addr    (GPIOD_BASE+8)  //0x40011408<br>#define GPIOE_IDR_Addr    (GPIOE_BASE+8)  //0x40011808<br>#define GPIOF_IDR_Addr    (GPIOF_BASE+8)  //0x40011A08<br>#define GPIOG_IDR_Addr    (GPIOG_BASE+8)  //0x40011E08|

现在我们就可以用位操作的方法来控制GPIO的输入和输出了，其中宏参数n表示具体是哪一个IO口，n(0,1,2…15)。 这里面包含了端口A~G ，并不是每个单片机型号都有这么多端口，使用这部分代码时，要查看你的单片机型号，如果是64pin的则最多只能使用到C端口。

### 14.2.2. GPIO位操作

代码清单:位带操作-2 GPIO 输入输出位操作[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_bit.html#id11 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21|// 单独操作 GPIO的某一个IO口，n(0,1,2...15),n表示具体是哪一个IO口<br>#define PAout(n)   BIT_ADDR(GPIOA_ODR_Addr,n)  //输出<br>#define PAin(n)    BIT_ADDR(GPIOA_IDR_Addr,n)  //输入<br><br>#define PBout(n)   BIT_ADDR(GPIOB_ODR_Addr,n)  //输出<br>#define PBin(n)    BIT_ADDR(GPIOB_IDR_Addr,n)  //输入<br><br>#define PCout(n)   BIT_ADDR(GPIOC_ODR_Addr,n)  //输出<br>#define PCin(n)    BIT_ADDR(GPIOC_IDR_Addr,n)  //输入<br><br>#define PDout(n)   BIT_ADDR(GPIOD_ODR_Addr,n)  //输出<br>#define PDin(n)    BIT_ADDR(GPIOD_IDR_Addr,n)  //输入<br><br>#define PEout(n)   BIT_ADDR(GPIOE_ODR_Addr,n)  //输出<br>#define PEin(n)    BIT_ADDR(GPIOE_IDR_Addr,n)  //输入<br><br>#define PFout(n)   BIT_ADDR(GPIOF_ODR_Addr,n)  //输出<br>#define PFin(n)    BIT_ADDR(GPIOF_IDR_Addr,n)  //输入<br><br>#define PGout(n)   BIT_ADDR(GPIOG_ODR_Addr,n)  //输出<br>#define PGin(n)    BIT_ADDR(GPIOG_IDR_Addr,n)  //输入|

### 14.2.3. 主函数

该工程我们直接从LED-库函数 操作移植过来，有关LED GPIO 初始化和软件延时等函数我们直接用， 修改的是控制GPIO输出的部分改成了位操作。该实验我们让IO口输出高低电平来控制LED的亮灭，负逻辑点亮。具体使用哪一个IO和点亮方式由硬件平台决定。

代码清单:位带操作-3 main 函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/GPIO_bit.html#id13 "永久链接至代码")

|                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                      |
| ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------- |
| 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19 | int main(void)<br>{<br>    // 程序来到main函数之前，启动文件：statup_stm32f10x_hd.s已经调用<br>    // SystemInit()函数把系统时钟初始化成72MHZ<br>    // SystemInit()在system_stm32f10x.c中定义<br>    // 如果用户想修改系统时钟，可自行编写程序修改<br><br>    LED_GPIO_Config();<br><br>    while ( 1 ) {<br>        // PB0 = 0,点亮LED<br>        PBout(0)= 0;<br>        SOFT_Delay(0x0FFFFF);<br><br>        // PB1 = 1,熄灭LED<br>        PBout(0)= 1;<br>        SOFT_Delay(0x0FFFFF);<br>    }<br>} | # 15. 启动文件详解[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Startup_file.html#id1 "永久链接至标题") |

本章参考资料《STM32F10X-中文参考手册》第九章-中断和事件：表 55其他STM32F10xxx产品（小容量、中容量和大容量）的向量表； MDK中的帮助手册—ARM Development Tools：用来查询ARM的汇编指令和编译器相关的指令。

## 15.1. 启动文件简介

启动文件由汇编编写，是系统上电复位后第一个执行的程序。主要做了以下工作：

> 1. 初始化堆栈指针SP=_initial_sp
>     
> 2. 初始化PC指针=Reset_Handler
>     
> 3. 初始化中断向量表
>     
> 4. 配置系统时钟
>     
> 5. 调用C库函数_main初始化用户堆栈，从而最终调用main函数去到C的世界
>     

## 15.2. 查找ARM汇编指令

在讲解启动代码的时候，会涉及到ARM的汇编指令和Cortex内核的指令，有关Cortex内核的指令我们可以参考《CM3权威指南CnR2》第四章：指令集。 剩下的ARM的汇编指令我们可以在MDK->Help->Uvision Help中搜索到，以EQU为例，检索如下：

![ARM汇编指令索引](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu002.png)

检索出来的结果会有很多，我们只需要看Assembler User Guide 这部分即可。下面列出了启动文件中使用到的ARM汇编指令， 该列表的指令全部从ARM Development Tools这个帮助文档里面检索而来。其中编译器相关的指令WEAK和ALIGN为了方便也放在同一个表格了。

![启动文件使用的ARM汇编指令汇总](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu01.png)

## 15.3. 启动文件代码讲解

### 15.3.1. Stack—栈

```s
Stack_Size      EQU     0x00000400

                AREA    STACK, NOINIT, READWRITE, ALIGN=3
Stack_Mem       SPACE   Stack_Size
__initial_sp
```

开辟栈的大小为0X00000400（1KB），名字为STACK，NOINIT即不初始化，可读可写，8（2^3）字节对齐。

栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部SRAM的大小。如果编写的程序比较大， 定义的局部变量很多，那么就需要修改栈的大小。如果某一天，你写的程序出现了莫名奇怪的错误，并进入了硬fault的时候，这时你就要考虑下是不是栈不够大，溢出了。

**EQU**：宏定义的伪指令，相当于等于，类似与C中的define。

**AREA**：告诉汇编器汇编一个新的代码段或者数据段。STACK表示段名，这个可以任意命名；NOINIT表示不初始化； READWRITE表示可读可写，ALIGN=3，表示按照2^3对齐，即8字节对齐。

**SPACE**：用于分配一定大小的内存空间，单位为字节。这里指定大小等于Stack_Size。

标号**__initial_sp**紧挨着SPACE语句放置，表示栈的结束地址，即栈顶地址，栈是由高向低生长的。

### 15.3.2. Heap堆
```s
Heap_Size     EQU     0x00000200

            AREA    HEAP, NOINIT, READWRITE, ALIGN=3
__heap_base
Heap_Mem      SPACE   Heap_Size
__heap_limit
```

开辟堆的大小为0X00000200（512字节），名字为HEAP，NOINIT即不初始化，可读可写，8（2^3）字节对齐。__heap_base表示对的起始地址， __heap_limit表示堆的结束地址。堆是由低向高生长的，跟栈的生长方向相反。

堆主要用来动态内存的分配，像malloc()函数申请的内存就在堆上面。这个在STM32里面用的比较少。

```s
PRESERVE8
THUMB
```

**PRESERVE8：**指定当前文件的堆栈按照8字节对齐。

**THUMB：**表示后面指令兼容THUMB指令。THUBM是ARM以前的指令集，16bit，现在Cortex-M系列的都使用THUMB-2指令集， THUMB-2是32位的，兼容16位和32位的指令，是THUMB的超集。

### 15.3.3. 向量表

```s
AREA    RESET, DATA, READONLY
EXPORT  __Vectors
EXPORT  __Vectors_End
EXPORT  __Vectors_Size
```

定义一个数据段，名字为RESET，可读。 并声明 __Vectors、__Vectors_End和__Vectors_Size这三个标号具有全局属性，可供外部的文件调用。

**EXPORT：**声明一个标号可被外部的文件使用，使标号具有全局属性。如果是IAR编译器，则使用的是GLOBAL这个指令。

当内核响应了一个发生的异常后，对应的异常服务例程(ESR)就会执行。为了决定 ESR 的入口地址， 内核使用了“向量表查表机制”。 这里使用一张向量表。向量表其实是一个 WORD（ 32 位整数）数组，每个下标对应一种异常，该下标元素的值则是该 ESR的入口地址。 向量表在地址空间中的位置是可以设置的，通过 NVIC 中的一个重定位寄存器来指出向量表的地址。在复位后，该寄存器的值为 0。因此， 在地址 0 （即FLASH 地址0）处必须包含一张向量表，用于初始时的异常分配。要注意的是这里有个另类： 0 号类型并不是什么入口地址， 而是给出了复位后 MSP 的初值。

![F103向量表](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu02.png)

代码 15‑1 向量表[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Startup_file.html#id7 "永久链接至代码")

|   |   |
|---|---|
|1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29|__Vectors  DCD   __initial_sp        ;栈顶地址<br>        DCD   Reset_Handler       ;复位程序地址<br>        DCD   NMI_Handler<br>        DCD   HardFault_Handler<br>        DCD   MemManage_Handler<br>        DCD   BusFault_Handler<br>        DCD   UsageFault_Handler<br>        DCD   0                    ; 0 表示保留<br>        DCD   0<br>        DCD   0<br>        DCD   0<br>        DCD   SVC_Handler<br>        DCD   DebugMon_Handler<br>        DCD   0<br>        DCD   PendSV_Handler<br>        DCD   SysTick_Handler<br><br><br>;外部中断开始<br>        DCD   WWDG_IRQHandler<br>        DCD   PVD_IRQHandler<br>        DCD   TAMPER_IRQHandler<br><br>;限于篇幅，中间代码省略<br>        DCD   DMA2_Channel2_IRQHandler<br>        DCD   DMA2_Channel3_IRQHandler<br>        DCD   DMA2_Channel4_5_IRQHandler<br>__Vectors_End<br>__Vectors_Size EQU __Vectors_End - __Vectors|

__Vectors为向量表起始地址，__Vectors_End 为向量表结束地址，两个相减即可算出向量表大小。

向量表从FLASH的0地址开始放置，以4个字节为一个单位，地址0存放的是栈顶地址，0X04存放的是复位程序的地址，以此类推。 从代码上看，向量表中存放的都是中断服务函数的函数名，可我们知道C语言中的函数名就是一个地址。

**DCD**：分配一个或者多个以字为单位的内存，以四字节对齐，并要求初始化这些内存。在向量表中，DCD分配了一堆内存，并且以ESR的入口地址初始化它们。

### 15.3.4. 复位程序

```
AREA |.text|, CODE, READONLY
```

定义一个名称为.text的代码段，可读。

```s
Reset_Handler PROC
            EXPORT  Reset_Handler    [WEAK]
            IMPORT  SystemInit
            IMPORT  __main

            LDR     R0, =SystemInit
            BLX     R0
            LDR     R0, =__main
            BX      R0
            ENDP
```

复位子程序是系统上电后第一个执行的程序，调用SystemInit函数初始化系统时钟，然后调用C库函数_mian，最终调用main函数去到C的世界。

**WEAK**：表示弱定义，如果外部文件优先定义了该标号则首先引用该标号，如果外部文件没有声明也不会出错。 这里表示复位子程序可以由用户在其他文件重新实现，这里并不是唯一的。

**IMPORT**：表示该标号来自外部文件，跟C语言中的EXTERN关键字类似。这里表示SystemInit和__main这两个函数均来自外部的文件。

SystemInit()是一个标准的库函数，在system_stm32f10x.c这个库文件总定义。主要作用是配置系统时钟，这里调用这个函数之后，单片机的系统时钟配被配置为72M。

__main是一个标准的C库函数，主要作用是初始化用户堆栈，并在函数的最后调用main函数去到C的世界。这就是为什么我们写的程序都有一个main函数的原因。

LDR、BLX、BX是CM4内核的指令，可在《CM3权威指南CnR2》第四章-指令集里面查询到，具体作用见下表：

![CM4内核的指令](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu03.png)

### 15.3.5. 中断服务程序

在启动文件里面已经帮我们写好所有中断的中断服务函数，跟我们平时写的中断服务函数不一样的就是这些函数都是空的， 真正的中断复服务程序需要我们在外部的C文件里面重新实现，这里只是提前占了一个位置而已。

如果我们在使用某个外设的时候，开启了某个中断，但是又忘记编写配套的中断服务程序或者函数名写错，那当中断来临的时， 程序就会跳转到启动文件预先写好的空的中断服务程序中，并且在这个空函数中无线循环，即程序就死在这里。

```
NMI_Handler     PROC    ;系统异常
                EXPORT  NMI_Handler           [WEAK]
                B       .
                ENDP

;限于篇幅，中间代码省略
SysTick_Handler PROC
                EXPORT  SysTick_Handler       [WEAK]
                B       .
                ENDP

Default_Handler PROC    ;外部中断
                EXPORT  WWDG_IRQHandler       [WEAK]
                EXPORT  PVD_IRQHandler        [WEAK]
                EXPORT  TAMP_STAMP_IRQHandler [WEAK]

;限于篇幅，中间代码省略
LTDC_IRQHandler
LTDC_ER_IRQHandler
DMA2D_IRQHandler
                B       .
                ENDP
```
**B**：跳转到一个标号。这里跳转到一个‘.’，即表示无线循环。

### 15.3.6. 用户堆栈初始化

1 ALIGN
ALIGN：对指令或者数据存放的地址进行对齐，后面会跟一个立即数。缺省表示4字节对齐。
```


;用户栈和堆初始化,由C库函数_main来完成
IF      :DEF:__MICROLIB  ;这个宏在KEIL里面开启

EXPORT  __initial_sp
EXPORT  __heap_base
EXPORT  __heap_limit

ELSE

IMPORT  __use_two_region_memory ; 这个函数由用户自己实现
EXPORT  __user_initial_stackheap

__user_initial_stackheap

LDR     R0, =  Heap_Mem
LDR     R1, =(Stack_Mem + Stack_Size)
LDR     R2, = (Heap_Mem +  Heap_Size)
LDR     R3, = Stack_Mem
BX      LR

ALIGN

ENDIF
```

首先判断是否定义了__MICROLIB ，如果定义了这个宏则赋予标号__initial_sp（栈顶地址）、 __heap_base（堆起始地址）、__heap_limit（堆结束地址）全局属性，可供外部文件调用。 有关这个宏我们在KEIL里面配置，具体见图 [使用微库](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Startup_file.html#id11) 。然后堆栈的初始化就由C库函数_main来完成。

![使用微库](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/Startu003.png)

如果没有定义__MICROLIB，则才用双段存储器模式，且声明标号__user_initial_stackheap具有全局属性，让用户自己来初始化堆栈。

**IF,ELSE,ENDIF**：汇编的条件分支语句，跟C语言的if ,else类似

**END**：文件结束


# 16. RCC—使用HSE/HSI配置时钟

本章参考资料：《STM32F10X-中文参考手册》RCC章节。

学习本章时，配合《STM32F10X-中文参考手册》RCC章节一起阅读，效果会更佳，特别是涉及到寄存器说明的部分。

RCC ：reset clock control  复位和时钟控制器。本章我们主要讲解时钟部分， 特别是要着重理解时钟树，理解了时钟树，STM32的一切时钟的来龙去脉都会了如指掌。

## 16.1. RCC主要作用—时钟部分
设置系统时钟SYSCLK、设置AHB分频因子（决定HCLK等于多少）、设置APB2分频因子（决定PCLK2等于多少）、 设置APB1分频因子（决定PCLK1等于多少）、设置各个外设的分频因子；控制AHB、APB2和APB1这三条总线时钟的开启、 控制每个外设的时钟的开启。对于SYSCLK、HCLK、PCLK2、PCLK1这四个时钟的配置一般是： PCLK2 = HCLK = SYSCLK=PLLCLK = 72M， PCLK1=HCLK/2 = 36M。这个时钟配置也是库函数的标准配置，我们用的最多的就是这个。

## 16.2. RCC框图剖析—时钟部分

时钟树单纯讲理论的话会比较枯燥，如果选取一条主线，并辅以代码，先主后次讲解的话会很容易，而且记忆还更深刻。 我们这里选取库函数时钟系统时钟函数：**SetSysClockTo72();** 以这个函数的编写流程来讲解时钟树， 这个函数也是我们用库的时候默认的系统时钟设置函数。 该函数的功能是利用HSE把时钟设置为：PCLK2 = HCLK = SYSCLK = 72M，PCLK1=HCLK/2 = 36M。 下面我们就以这个代码的流程为主线，来分析时钟树，对应的是图中的黄色部分，代码流程在时钟树中以数字的大小顺序标识。

![STM32时钟树](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/RCC002.png)
>**思考**：
- 字母部分是实现某一功能的硬件群拓补，而数字部分是一个最小的功能组件部分
- E部分的主时钟输出的源头是另外一个MCU的外部时钟信号，或者该MCU内置的时钟源，输出到这个MCU时钟树上上，1、D、E三种时钟源只能选取一种
- 时钟源比作树根、时钟传输流比作树干、时钟调节装置比作分支、需要用到时钟的外设比作分支末梢。**这才是一个完整的时钟树，但是我们大部分只关注到最后一个**

```ad-note
title:解释

## 字母区块
### A: 外设时钟（Peripherals Clocks）

- 该部分负责分发外设所需的时钟信号，例如 USB、I2S、SDIO 等外设。
- 它们可能会通过分频器进一步调整时钟频率，以满足外设的工作需求。

### B: APB1 和 APB2 时钟（Advanced Peripheral Bus Clocks）

- APB1 和 APB2 是高级外设总线，分别连接不同的外设模块。
- **APB1（低速外设总线）**：通常连接慢速外设，例如 UART、I2C、SPI 等，最大频率为 36MHz。
- **APB2（高速外设总线）**：连接高速外设，例如 GPIO、ADC、USART、SPI 等，最大频率为 72MHz。

### C: ADC 时钟（Analog-to-Digital Converter Clock）

- 该部分提供给 ADC 模块的时钟源。ADC 通常需要更低频率的时钟（最大 14MHz），通过分频器从系统时钟中生成。

### D: 实时时钟（RTC Clock）

- 提供给 RTC 的时钟信号，通常源自 LSE（低速外部时钟）或 LSI（低速内部时钟）。
- RTC 用于时间管理功能（如定时器、日历等），一般使用较低频率的 32.768kHz 信号。

### E: 主时钟输出（MCO - Microcontroller Clock Output）

- 该部分用于将主时钟（系统时钟或其某些源）通过 MCO 引脚输出，用于外部模块的时钟需求。
- 可以选择多种时钟源（HSI、HSE、PLLCLK、SYSCLK 等）并通过分频器调整频率。

## 数字区块
### 1. **HSE 振荡器输入部分**

- 这是外部高速时钟（HSE）的输入模块，通常连接外部晶振或时钟源。
- **HSE（High-Speed External Clock）**可以是一个 4~16MHz 的外部晶振。
- 在经过倍频或分频后，HSE 可以用作系统时钟源，也可以作为 PLL 的输入。

---

### 2. **PLL 时钟源选择器（PLLSRC）**

- 决定 PLL 的时钟输入来源，可能是：
    - 内部高速时钟 HSI/2。
    - 外部高速时钟 HSE 或 HSE/2。
- PLL 的输入时钟通过此模块配置，进入后进行倍频或其他调整。

---

### 3. **PLL 倍频因子（PLLMUL）**

- 配置 PLL 的倍频系数，从而产生更高频率的时钟信号。
- 倍频范围通常为 2 到 16，具体倍频因子由寄存器 `PLLMUL` 配置。
- 倍频后的输出信号用于系统时钟（SYSCLK）或其他外设模块。

---

### 4. **系统时钟源选择（SW 和 SYSCLK）**

- 这是系统时钟（SYSCLK）的选择点，可以选择时钟源：
    - HSI（内部高速时钟）。
    - HSE（外部高速时钟）。
    - PLL 输出（推荐）。
- **SW（System Clock Switch）** 位决定 SYSCLK 的来源，且 SYSCLK 是整个芯片时钟树的核心信号。

---

### 5. **AHB 时钟分频器（HCLK）**

- **AHB**（Advanced High-performance Bus）是用于连接 Cortex-M 核心和主要外设（如内存和 DMA）的总线。
- AHB 时钟频率可以通过分频器（1、2、4、8 等）调整，具体分频系数由 `HPRE` 寄存器配置。

---

### 6. **APB1 时钟分频器（PCLK1）**

- **APB1** 是低速外设总线，连接慢速外设（如 I2C、UART、SPI）。
- PCLK1 的最大频率为 36MHz，通常通过分频器从 HCLK 派生，分频系数由 `PPRE1` 配置。

---

### 7. **APB2 时钟分频器（PCLK2）**

- **APB2** 是高速外设总线，连接高速外设（如 GPIO、USART、ADC）。
- PCLK2 的最大频率为 72MHz，同样通过分频器从 HCLK 派生，分频系数由 `PPRE2` 配置。

```


```ad-note
title:区分

## MCO的HSE与外部时钟输出的区别

你的问题很有道理，看起来主时钟输出（**MCO**）部分和**数字 1（HSE 振荡器）**部分似乎存在功能上的重叠，但实际上它们的功能和用途有所不同。我们需要从**时钟源**和**时钟输出**两个角度来理解：

---

### **数字 1 部分（HSE 振荡器的输入功能）**

- **主要作用**：  
    数字 1 部分表示 **外部高速时钟（HSE）** 的输入模块。
    
    - HSE（High-Speed External Clock）是一个 4-16 MHz 的外部时钟源，通常由外部晶振或其他时钟发生器提供。
    - 它的功能是**提供稳定的时钟源**，作为系统时钟或其他时钟模块（例如 PLL）的输入时钟源。
- **用法**：
    
    - HSE 可作为系统时钟（SYSCLK）的输入源，通过 PLL 进行倍频以提供更高的频率时钟。
    - HSE 还可以直接作为一些外设（如 USB、I2S 等）的时钟输入。

**总结**：数字 1 部分是 HSE 的输入功能，它为芯片内部各模块提供稳定的外部时钟源，是所有时钟派生的**基础输入**。

---

### **主时钟输出（MCO - Microcontroller Clock Output）**

- **主要作用**：  
    MCO 部分负责将芯片内部的一些时钟源**输出到外部**，供外部模块或其他芯片使用。
    
    - MCO 可以选择不同的时钟源输出，比如：
        1. **HSI（内部高速时钟）**
        2. **HSE（外部高速时钟）**
        3. **PLLCLK（PLL 倍频输出时钟）**
        4. **SYSCLK（系统时钟）**
- **用法**：
    
    - MCO 通过一个引脚（如 `PA8` 引脚）将时钟信号输出到外部系统，可以作为外部电路的时钟源。
    - 外部设备可以共享 MCU 内部的时钟，从而实现时钟同步等功能。

**总结**：MCO 的功能是将已经存在的内部时钟源（包括 HSE、HSI、PLLCLK 等）输出到外部，供外部设备使用。

---

### 为什么看起来像重叠？

看似**HSE 振荡器** 和 **MCO 输出** 都与 HSE 相关，实际上它们的功能不同：

1. **数字 1（HSE）是时钟输入**：HSE 提供稳定的外部高速时钟信号，作为 MCU 内部时钟树的基础时钟源。
2. **MCO 是时钟输出**：MCO 只是将内部时钟源（包括 HSE）通过特定引脚输出到外部设备。

- **关系**：HSE 可以作为 MCO 的时钟源之一，但 MCO 只负责“输出”，不影响 HSE 的输入功能。

---

### 图示中的关联

1. **HSE 在数字 1 处进入系统**，它可以用于：
    - 直接作为系统时钟。
    - 输入到 PLL 进行倍频后用于系统时钟或外设时钟。
2. **MCO 可以选择输出 HSE**：如果用户需要将外部时钟通过 HSE 输入，再通过 MCO 输出给其他外设或芯片，就可以在 MCO 选择 HSE 作为输出时钟。

---

### 举例说明

假设你有一个 **STM32** MCU 和另一个芯片需要同步时钟：

- **HSE 输入**：你给 STM32 的 HSE 引脚接入了 8 MHz 的外部晶振。
- **系统时钟配置**：STM32 使用 HSE 作为系统时钟源。
- **MCO 输出**：你通过 MCO 将 8 MHz HSE 输出给其他芯片，其他芯片就可以共享这个 8 MHz 的时钟。

在这个例子中：

- **HSE 作为时钟输入**（数字 1）。
- **MCO 作为时钟输出**，选择了 HSE 作为输出源。

---

### 结论

- **数字 1**：HSE 是外部时钟的输入，供芯片内部使用。
- **MCO**：MCO 将 HSE（或其他时钟源）输出到外部设备。

两者功能不同，一个是**输入时钟**，一个是**输出时钟**，不存在冲突或矛盾。
```


### 16.2.1. 系统时钟
#### 16.2.1.1. HSE高速外部时钟信号

HSE是高速的外部时钟信号，可以由**有源晶振**或者**无源晶振**提供，频率从4-16MHZ不等。当**使用有源晶振时， 时钟从OSC_IN引脚进入，OSC_OUT引脚悬空**，当选用无源晶振时，时钟从OSC_IN和OSC_OUT进入，并且要配谐振电容。

HSE最常使用的就是8M的无源晶振。当确定PLL时钟来源的时候，HSE可以不分频或者2分频， 这个由时钟配置寄存器CFGR的位17：PLLXTPRE设置，我们设置为HSE不分频。

**PLL时钟源(PLLXTPRE)**

> PLL时钟来源可以有两个，一个来自HSE，另外一个是HSI/2，具体用哪个由时钟配置寄存器CFGR的位16：PLLSRC设置。 HSI是内部高速的时钟信号，频率为8M，根据温度和环境的情况频率会有漂移，一般不作为PLL的时钟来源。这里我们选HSE作为PLL的时钟来源。

**PLL时钟PLLCLK**

> 通过设置PLL的倍频因子，可以对PLL的时钟来源进行倍频，倍频因子可以是:[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]， 具体设置成多少，由时钟配置寄存器CFGR的位21-18：PLLMUL[3:0]设置。我们这里设置为9倍频， 因为上一步我们设置PLL的时钟来源为HSE=8M，所以经过PLL倍频之后的PLL时钟：PLLCLK = 8M *9 = 72M。 72M是ST官方推荐的稳定运行时钟，如果你想超频的话，增大倍频因子即可，最高为128M。 我们这里设置PLL时钟：PLLCLK = 8M *9 = 72M。

**系统时钟SYSCLK**

> 系统时钟来源可以是：HSI、PLLCLK、HSE，具体的时钟配置寄存器CFGR的位1-0：SW[1:0]设置。 我们这里设置系统时钟：SYSCLK = PLLCLK = 72M。

**AHB总线时钟HCLK**

> 系统时钟SYSCLK经过AHB预分频器分频之后得到时钟叫APB总线时钟，即HCLK，分频因子可以是:[1,2,4，8，16，64，128，256，512]， 具体的由时钟配置寄存器CFGR的位7-4  ：HPRE[3:0]设置。片上大部分外设的时钟都是经过HCLK分频得到， 至于AHB总线上的外设的时钟设置为多少，得等到我们使用该外设的时候才设置， 我们这里只需粗线条的设置好APB的时钟即可。我们这里设置为1分频，即HCLK=SYSCLK=72M。

**APB2总线时钟PCLK2**

> APB2总线时钟PCLK2由HCLK经过高速APB2预分频器得到，分频因子可以是:[1,2,4，8，16]，具体由时钟配置寄存器CFGR的位13-11：PPRE2[2:0]决定。 PCLK2属于高速的总线时钟，片上高速的外设就挂载到这条总线上，比如全部的GPIO、USART1、SPI1等。至于APB2总线上的外设的时钟设置为多少， 得等到我们使用该外设的时候才设置，我们这里只需粗线条的设置好APB2的时钟即可。我们这里设置为1分频，即PCLK2 = HCLK = 72M。

**APB1总线时钟PCLK1**

> APB1总线时钟PCLK1由HCLK经过低速APB预分频器得到，分频因子可以是:[1,2,4，8，16]，具体的由时钟配置寄存器CFGR的位10-8：PRRE1[2:0]决定。 PCLK1属于低速的总线时钟，最高为36M，片上低速的外设就挂载到这条总线上，比如USART2/3/4/5、SPI2/3，I2C1/2等。 至于APB1总线上的外设的时钟设置为多少，得等到我们使用该外设的时候才设置，我们这里只需粗线条的设置好APB1的时钟即可。 我们这里设置为2分频，即PCLK1 = HCLK/2 = 36M。

#### 16.2.1.2. 设置系统时钟库函数

上面的7个步骤对应的设置系统时钟库函数如下，该函数截取自固件库文件system_stm32f10x.c。为了方便阅读， 我已把互联型相关的代码删掉，把英文注释翻译成了中文，并把代码标上了序号，总共七个步骤。该函数是直接操作寄存器的， 有关寄存器部分请参考数据手册的RCC的寄存器描述部分。

代码清单:RCC-1 设置系统时钟库函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/RCC.html#rcc-1 "永久链接至代码")

```c
static void SetSysClockTo72(void)
{
    __IO uint32_t StartUpCounter = 0, HSEStatus = 0;

    // ① 使能HSE，并等待HSE稳定
    RCC->CR |= ((uint32_t)RCC_CR_HSEON);

    // 等待HSE启动稳定，并做超时处理
    do {
        HSEStatus = RCC->CR & RCC_CR_HSERDY;
        StartUpCounter++;
    } while ((HSEStatus == 0)
        &&(StartUpCounter !=HSE_STARTUP_TIMEOUT));

    if ((RCC->CR & RCC_CR_HSERDY) != RESET) {
        HSEStatus = (uint32_t)0x01;
    } else {
        HSEStatus = (uint32_t)0x00;
    }
    // HSE启动成功，则继续往下处理
    if (HSEStatus == (uint32_t)0x01) {

        //-----------------------------------------------------------
        // 使能FLASH 预存取缓冲区 */
        FLASH->ACR |= FLASH_ACR_PRFTBE;

        // SYSCLK周期与闪存访问时间的比例设置，这里统一设置成2
        // 设置成2的时候，SYSCLK低于48M也可以工作，如果设置成0或者1的时候，
        // 如果配置的SYSCLK超出了范围的话，则会进入硬件错误，程序就死了
        // 0：0 < SYSCLK <= 24M
        // 1：24< SYSCLK <= 48M
        // 2：48< SYSCLK <= 72M */
        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
        FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;
        //------------------------------------------------------------

        // ② 设置AHB、APB2、APB1预分频因子
        // HCLK = SYSCLK
        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
        //PCLK2 = HCLK
        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
        //PCLK1 = HCLK/2
        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;

        // ③ 设置PLL时钟来源，设置PLL倍频因子，PLLCLK = HSE * 9 = 72 MHz
        RCC->CFGR &= (uint32_t)((uint32_t)
                                ~(RCC_CFGR_PLLSRC
                                | RCC_CFGR_PLLXTPRE
                                | RCC_CFGR_PLLMULL));
        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE
                                | RCC_CFGR_PLLMULL9);

        // ④ 使能 PLL
        RCC->CR |= RCC_CR_PLLON;

        // ⑤ 等待PLL稳定
        while ((RCC->CR & RCC_CR_PLLRDY) == 0) {
        }

        // ⑥ 选择PLL作为系统时钟来源
        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
        RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;

        // ⑦ 读取时钟切换状态位，确保PLLCLK被选为系统时钟
        while ((RCC->CFGR&(uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08){
        }
    } else {// 如果HSE启动失败，用户可以在这里添加错误代码出来
    }
}
```
### 16.2.2. 其他时钟[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/RCC.html#id4 "永久链接至标题")

通过对系统时钟设置的讲解，整个时钟树我们已经把握的有六七成，剩下的时钟部分我们讲解几个重要的。

**A、USB时钟**

> USB时钟是由PLLCLK经过USB预分频器得到，分频因子可以是：[1,1.5]，具体的由时钟配置寄存器CFGR的位22：USBPRE配置。 USB的时钟最高是48M，根据分频因子反推过来算，PLLCLK只能是48M或者是72M。一般我们设置PLLCLK=72M，USBCLK=48M。 USB对时钟要求比较高，所以PLLCLK只能是由HSE倍频得到，不能使用HSI倍频。

**B、Cortex系统时钟**

> Cortex系统时钟由HCLK 8分频得到，等于9M， Cortex系统时钟用来驱动内核的系统定时器SysTick，SysTick一般用于操作系统的时钟节拍，也可以用做普通的定时。

**C、ADC时钟**

> ADC时钟由PCLK2经过ADC预分频器得到，分频因子可以是[2,4,6,8]，具体的由时钟配置寄存器CFGR的位15-14：ADCPRE[1:0]决定。 很奇怪的是怎么没有1分频。ADC时钟最高只能是14M，如果采样周期设置成最短的1.5个周期的话，ADC的转换时间可以达到最短的1us。 如果真要达到最短的转换时间1us的话，那ADC的时钟就得是14M，反推PCLK2的时钟只能是：28M、56M、84M、112M， 鉴于PCLK2最高是72M，所以只能取28M和56M。

**D、RTC时钟、独立看门狗时钟**

> RTC时钟可由HSE/128分频得到，也可由低速外部时钟信号LSE提供，频率为32.768KHZ，也可由低速内部时钟信号LSI提供， 具体选用哪个时钟由备份域控制寄存器BDCR的位9-8：RTCSEL[1:0]配置。独立看门狗的时钟由LSI提供， 且只能是由LSI提供，LSI是低速的内部时钟信号，频率为30~60KHZ直接不等，一般取40KHZ。

**E、MCO时钟输出**

> MCO是microcontroller clock output的缩写，是微控制器时钟输出引脚，在STM32 F1系列中 由 PA8复用所得， 主要作用是可以对外提供时钟，相当于一个有源晶振。MCO的时钟来源可以是：PLLCLK/2、HSI、HSE、SYSCLK， 具体选哪个由时钟配置寄存器CFGR的位26-24：MCO[2:0]决定。除了对外提供时钟这个作用之外， 我们还可以通过示波器监控MCO引脚的时钟输出来验证我们的系统时钟配置是否正确。

## 16.3. 配置系统时钟实验

### 16.3.1. 使用HSE

一般情况下，我们都是使用HSE，然后HSE经过PLL倍频之后作为系统时钟。通常的配置是：HSE=8M，PLL的倍频因子为：9， 系统时钟就设置成:SYSCLK = 8M * 9 = 72M。使用HSE，系统时钟SYSCLK最高是128M。我们使用的库函数就是这么干的， 当程序来到main函数之前，启动文件：statup_stm32f10x_hd.s已经调用SystemInit()函数把系统时钟初始化成72MHZ， SystemInit()在库文件：system_stm32f10x.c中定义。如果我们想把系统时钟设置低一点或者超频的话，可以修改底层的库文件， 但是为了维持库的完整性，我们可以根据时钟树的流程自行写一个。

### 16.3.2. 使用HSI

当HSE故障的时候，如果PLL的时钟来源是HSE，那么当HSE故障的时候，不仅HSE不能使用，连PLL也会被关闭，这个时候系统会自动切换HSI作为系统时钟， 此时SYSCLK=HSI=8M，如果没有开启CSS和CSS中断的话，那么整个系统就只能在低速率运行，这是系统跟瘫痪没什么两样。如果开启了CSS功能的话， 那么可以当HSE故障时，在CSS中断里面采取补救措施，使用HSI，并把系统时钟设置为更高的频率，最高是64M，64M的频率足够一般的外设使用， 如：ADC、SPI、I2C等。但是这里就又有一个问题了，原来SYSCLK=72M，现在因为故障改成64M，那么那些外设的时钟肯定被改变了， 那么外设工作就会被打乱，那我们是不是在设置HSI时钟的时候，也重新调整外设总线的分频因子，即AHB，APB2和APB1的分频因子， 使外设的时钟达到跟HSE没有故障之前一样。但是这个也不是最保障的办法，毕竟不能一直使用HSI，所以当HSE故障时还是要采取报警措施。

还有一种情况是，有些用户不想用HSE，想用HSI，但是又不知道怎么用HSI来设置系统时钟，因为调用库函数都是使用HSE， 下面我们给出个使用HSI配置系统时钟例子，起个抛砖引玉的作用。

### 16.3.3. 硬件设计

> 1. RCC
>     
> 2. LED一个
>     

RCC是单片机内部资源，不需要外部电路。通过LED闪烁的频率来直观的判断不同系统时钟频率对软件延时的效果。

### 16.3.4. 软件设计

我们编写两个RCC驱动文件，bsp_clkconfig.h和bsp_clkconfig.c，用来存放RCC系统时钟配置函数。

#### 16.3.4.1. 编程要点

编程要点对应着时钟树图中的序号。

> 1、开启HSE/HSI ，并等待 HSE/HSI 稳定
> 
> 2、设置 AHB、APB2、APB1的预分频因子
> 
> 3、设置PLL的时钟来源，和PLL的倍频因子，设置各种频率主要就是在这里设置
> 
> 4、开启PLL，并等待PLL稳定
> 
> 5、把PLLCK切换为系统时钟SYSCLK
> 
> 6、读取时钟切换状态位，确保PLLCLK被选为系统时钟

#### 16.3.4.2. 代码分析
这里只讲解核心的部分代码，有些变量的设置，头文件的包含等并没有涉及到，完整的代码请参考本章配套的工程。

使用HSE配置系统时钟

代码清单:RCC-2 HSE作为系统时钟来源[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/RCC.html#rcc-2 "永久链接至代码")

```c
void HSE_SetSysClock(uint32_t pllmul)
{
    __IO uint32_t StartUpCounter = 0, HSEStartUpStatus = 0;

    // 把RCC外设初始化成复位状态
    RCC_DeInit();

    //使能HSE，开启外部晶振，野火STM32F103系列开发板用的是8M
    RCC_HSEConfig(RCC_HSE_ON);

    // 等待 HSE 启动稳定
    HSEStartUpStatus = RCC_WaitForHSEStartUp();

    // 只有 HSE 稳定之后则继续往下执行
    if (HSEStartUpStatus == SUCCESS) {
//-----------------------------------------------------------------//
        // 这两句是操作FLASH闪存用到的，如果不操作FLASH，这两个注释掉也没影响
        // 使能FLASH 预存取缓冲区
        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);

        // SYSCLK周期与闪存访问时间的比例设置，这里统一设置成2
        // 设置成2的时候，SYSCLK低于48M也可以工作，如果设置成0或者1的时候，
        // 如果配置的SYSCLK超出了范围的话，则会进入硬件错误，程序就死了
        // 0：0 < SYSCLK <= 24M
        // 1：24< SYSCLK <= 48M
        // 2：48< SYSCLK <= 72M
        FLASH_SetLatency(FLASH_Latency_2);
//-----------------------------------------------------------------//

        // AHB预分频因子设置为1分频，HCLK = SYSCLK
        RCC_HCLKConfig(RCC_SYSCLK_Div1);

        // APB2预分频因子设置为1分频，PCLK2 = HCLK
        RCC_PCLK2Config(RCC_HCLK_Div1);

        // APB1预分频因子设置为1分频，PCLK1 = HCLK/2
        RCC_PCLK1Config(RCC_HCLK_Div2);

//-----------------设置各种频率主要就是在这里设置-------------------//
        // 设置PLL时钟来源为HSE，设置PLL倍频因子
        // PLLCLK = 8MHz * pllmul
        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, pllmul);
//-------------------------------------------------------------//

        // 开启PLL
        RCC_PLLCmd(ENABLE);

        // 等待 PLL稳定
        while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) {
        }

        // 当PLL稳定之后，把PLL时钟切换为系统时钟SYSCLK
        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);

        // 读取时钟切换状态位，确保PLLCLK被选为系统时钟
        while (RCC_GetSYSCLKSource() != 0x08) {
        }
    } else {
        // 如果HSE开启失败，那么程序就会来到这里，用户可在这里添加出错的代码处理
        // 当HSE开启失败或者故障的时候，单片机会自动把HSI设置为系统时钟，
        // HSI是内部的高速时钟，8MHZ
        while (1) {
        }
    }
}
```
这个函数采用库函数编写， 函数有个形参pllmul，pllmul用来设置PLL的倍频因子， 在调用的时候形参可以是：RCC_PLLMul_x , x:[2,3,…16]， 这些宏来源于库函数的定义，宏展开是一些32位的十六进制数，具体功能是配置了时钟配置寄存器CFGR的位21-18PLLMUL[3:0]，预先定义好倍频因子，方便调用。

函数调用举例：HSE_SetSysClock(RCC_PLLMul_9); 则设置系统时钟为：8MHZ * 9 = 72MHZ。 HSE_SetSysClock(RCC_PLLMul_16);则设置系统时钟为：8MHZ * 16 = 128MHZ超频慎用。

代码清单:RCC-3使用HSI配置系统时钟[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/RCC.html#rcc-3 "永久链接至代码")

```c
void HSI_SetSysClock(uint32_t pllmul)
{
    __IO uint32_t HSIStartUpStatus = 0;

    // 把RCC外设初始化成复位状态
    RCC_DeInit();

    //使能HSI
    RCC_HSICmd(ENABLE);

    // 等待 HSI 就绪
    HSIStartUpStatus = RCC->CR & RCC_CR_HSIRDY;

    // 只有 HSI就绪之后则继续往下执行
    if (HSIStartUpStatus == RCC_CR_HSIRDY) {
    //-------------------------------------------------------------//
        // 这两句是操作FLASH闪存用到的，如果不操作FLASH，这两个注释掉也没影响
        // 使能FLASH 预存取缓冲区
        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);

        // SYSCLK周期与闪存访问时间的比例设置，这里统一设置成2
        // 设置成2的时候，SYSCLK低于48M也可以工作，如果设置成0或者1的时候，
        // 如果配置的SYSCLK超出了范围的话，则会进入硬件错误，程序就死了
        // 0：0 < SYSCLK <= 24M
        // 1：24< SYSCLK <= 48M
        // 2：48< SYSCLK <= 72M
        FLASH_SetLatency(FLASH_Latency_2);
    //------------------------------------------------------------//

        // AHB预分频因子设置为1分频，HCLK = SYSCLK
        RCC_HCLKConfig(RCC_SYSCLK_Div1);

        // APB2预分频因子设置为1分频，PCLK2 = HCLK
        RCC_PCLK2Config(RCC_HCLK_Div1);

        // APB1预分频因子设置为1分频，PCLK1 = HCLK/2
        RCC_PCLK1Config(RCC_HCLK_Div2);

        //-----------设置各种频率主要就是在这里设置-------------------//
        // 设置PLL时钟来源为HSI，设置PLL倍频因子
        // PLLCLK = 4MHz * pllmul
        RCC_PLLConfig(RCC_PLLSource_HSI_Div2, pllmul);
    //-- -----------------------------------------------------//

        // 开启PLL
        RCC_PLLCmd(ENABLE);

        // 等待 PLL稳定
        while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) {
        }

        // 当PLL稳定之后，把PLL时钟切换为系统时钟SYSCLK
        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);

        // 读取时钟切换状态位，确保PLLCLK被选为系统时钟
        while (RCC_GetSYSCLKSource() != 0x08) {
        }
    } else {
        // 如果HSI开启失败，那么程序就会来到这里，用户可在这里添加出错的代码处理
        // 当HSE开启失败或者故障的时候，单片机会自动把HSI设置为系统时钟，
        // HSI是内部的高速时钟，8MHZ
        while (1) {
        }
    }
}
```
HSI设置系统时钟函数跟HSE设置系统时钟函数在原理上是一样的，有一个区别的地方就是，HSI必须2分频之后才能作为PLL的时钟来源， 所以使用HSI时，最大的系统时钟SYSCLK只能是HSI/2*16=4*16=64MHZ。

函数调用举例：HSI_SetSysClock(RCC_PLLMul_9); 则设置系统时钟为：4MHZ * 9 = 36MHZ。

代码清单:RCC-4软件延时[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/RCC.html#rcc-4 "永久链接至代码")

```c
void Delay(__IO uint32_t nCount)
{
    for (; nCount != 0; nCount--);
}
```
软件延时函数，使用不同的系统时钟，延时时间不一样，可以通过LED闪烁的频率来判断。

MCO输出

在STM32F103系列中，PA8可以复用为MCO引脚，对外提供时钟输出，我们也可以用示波器监控该引脚的输出来判断我们的系统时钟是否设置正确。

代码清单:RCC-5 MCO GPIO初始化[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/RCC.html#rcc-5 "永久链接至代码")

```c
/*
* 初始化MCO引脚PA8
* 在F103系列中MCO引脚只有一个，即PA8，在F4系列中，MCO引脚有两个
*/
void MCO_GPIO_Config(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    // 开启GPIOA的时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

    // 选择GPIO8引脚
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;

    //设置为复用功能推挽输出
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;

    //设置IO的翻转速率为50M
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

    // 初始化GPIOA8
    GPIO_Init(GPIOA, &GPIO_InitStructure);
}
```
代码清单:RCC-6 MCO输出时钟选择[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/RCC.html#rcc-6 "永久链接至代码")

```c
// 设置MCO引脚输出时钟，用示波器即可在PA8测量到输出的时钟信号，
// 我们可以把PLLCLK/2作为MCO引脚的时钟来检测系统时钟是否配置准确
// MCO引脚输出可以是HSE,HSI,PLLCLK/2,SYSCLK
//RCC_MCOConfig(RCC_MCO_HSE);
//RCC_MCOConfig(RCC_MCO_HSI);
//RCC_MCOConfig(RCC_MCO_PLLCLK_Div2);
RCC_MCOConfig(RCC_MCO_SYSCLK);
```
我们初始化MCO引脚之后，可以直接调用库函数RCC_MCOConfig()来选择MCO时钟来源。

代码清单:RCC-7主函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/RCC.html#rcc-7 "永久链接至代码")

```c
int main(void)
{
    // 程序来到main函数之前，启动文件：statup_stm32f10x_hd.s已经调用
    // SystemInit()函数把系统时钟初始化成72MHZ
    // SystemInit()在system_stm32f10x.c中定义
    // 如果用户想修改系统时钟，可自行编写程序修改

    // 重新设置系统时钟，这时候可以选择使用HSE还是HSI

    // 使用HSE时，SYSCLK = 8M * RCC_PLLMul_x, x:[2,3,...16],最高是128M
    HSE_SetSysClock(RCC_PLLMul_9);

    // 使用HSI时，SYSCLK = 4M * RCC_PLLMul_x, x:[2,3,...16],最高是64MH
    //HSI_SetSysClock(RCC_PLLMul_16);

    // MCO 引脚初始化
    MCO_GPIO_Config();

    // 设置MCO引脚输出时钟，用示波器即可在PA8测量到输出的时钟信号，
    // 我们可以把PLLCLK/2作为MCO引脚的时钟来检测系统时钟是否配置准确
    // MCO引脚输出可以是HSE,HSI,PLLCLK/2,SYSCLK
    //RCC_MCOConfig(RCC_MCO_HSE);
    //RCC_MCOConfig(RCC_MCO_HSI);
    //RCC_MCOConfig(RCC_MCO_PLLCLK_Div2);
    RCC_MCOConfig(RCC_MCO_SYSCLK);

    // LED 端口初始化
    LED_GPIO_Config();
    while (1) {
        LED1( ON );       // 亮
        Delay(0x0FFFFF);
        LED1( OFF );      // 灭
        Delay(0x0FFFFF);
    }
}
```
在主函数中，可以调用HSE_SetSysClock()或者HSI_SetSysClock()这两个函数把系统时钟设置成各种常用的时钟，然后通过MCO引脚监控， 或者通过LED闪烁的快慢体验不同的系统时钟对同一个软件延时函数的影响。

### 16.3.5. 下载验证

把编译好的程序下载到开发板，可以看到设置不同的系统时钟时，LED闪烁的快慢不一样。更精确的数据我们可以用示波器监控MCO引脚看到。

MCO=SYSCLK=72M

![MCO=SYSCLK=72M](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/RCC003.png)

MCO=HSI=8M

![MCO=HSI=8M](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/RCC004.png)


# 17. STM32中断应用概览

本章参考资料《STM32F10X-中文参考手册》、《 Cortex-M3内核编程手册》-4.3 章节：NVIC和4.4章节：SCB—4.4.5的AIRCR。

STM32中断非常强大，每个外设都可以产生中断，所以中断的讲解放在哪一个外设里面去讲都不合适，这里单独抽出一章来做一个总结性的介绍，这样在其他章节涉及到中断部分的知识我们就不用费很大的篇幅去讲解，只要示意性带过即可。

本章如无特别说明，异常就是中断，中断就是异常，请不要刻意钻牛角尖较劲。

## 17.1. 异常类型

F103在内核水平上搭载了一个异常响应系统， 支持为数众多的系统异常和外部中断。 其中系统异常有8个（如果把Reset和HardFault也算上的话就是10个）， 外部中断有60个。除了个别异常的优先级被定死外，其它异常的优先级都是可编程的。 有关具体的系统异常和外部中断可在标准库文件stm32f10x.h这个头文件查询到，在IRQn_Type这个结构体里面包含了F103系列全部的异常声明。

**F103系统异常清单**

![F103系统异常清单](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr01.png)

**F103外部中断清单**

![F103外部中断清单](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr02.png)

## 17.2. NVIC简介

在讲如何配置中断优先级之前，我们需要先了解下NVIC。NVIC是嵌套向量中断控制器，控制着整个芯片中断相关的功能，它跟内核紧密耦合，是内核里面的一个外设。但是各个芯片厂商在设计芯片的时候会对Cortex-M3内核里面的NVIC进行裁剪，把不需要的部分去掉，所以说STM32的NVIC是Cortex-M 3的NVIC的一个子集。

### 17.2.1. NVIC寄存器简介

在固件库中，NVIC的结构体定义可谓是颇有远虑，给每个寄存器都预留了很多位，恐怕为的是日后扩展功能。 不过STM32F103可用不了这么多，只是用了部分而已，具体使用了多少可参考《 Cortex-M3 内核编程手册》-4.3.11:NVIC寄存器映射。

代码清单:中断-1 NVIC结构体定义，来自固件库头文件：core_cm3.h[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Interrupt_application.html#id4 "永久链接至代码")

```c
typedef struct {
    __IO uint32_t ISER[8];       // 中断使能寄存器
    uint32_t RESERVED0[24];
    __IO uint32_t ICER[8];       // 中断清除寄存器
    uint32_t RSERVED1[24];
    __IO uint32_t ISPR[8];       // 中断使能悬起寄存器
    uint32_t RESERVED2[24];
    __IO uint32_t ICPR[8];       // 中断清除悬起寄存器
    uint32_t RESERVED3[24];
    __IO uint32_t IABR[8];       // 中断有效位寄存器
    uint32_t RESERVED4[56];
    __IO uint8_t  IP[240];       // 中断优先级寄存器(8Bit wide)
    uint32_t RESERVED5[644];
    __O  uint32_t STIR;          // 软件触发中断寄存器
}  NVIC_Type;
```
在配置中断的时候我们一般只用ISER、ICER和IP这三个寄存器，ISER用来使能中断，ICER用来失能中断，IP用来设置中断优先级。

### 17.2.2. NVIC 中断配置固件库

固件库文件core_cm3.h的最后，还提供了NVIC的一些函数，这些函数遵循CMSIS规则，只要是Cortex-M3 的处理器都可以使用，具体如下：

![符合CMSIS标准的NVIC库函数](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr03.png)

这些库函数我们在编程的时候用的都比较少，甚至基本都不用。在配置中断的时候我们还有更简洁的方法，请看中断编程小节。

## 17.3. 优先级的定义

### 17.3.1. 优先级定义

在NVIC 有一个专门的寄存器：**中断优先级寄存器NVIC_IPRx**，用来配置外部中断的优先级，IPR宽度为8bit， 原则上每个外部中断可配置的优先级为0~255，数值越小，优先级越高。但是绝大多数CM3芯片都会精简设计， 以致实际上支持的优先级数减少，在F103中，只使用了高4bit，如下所示：

![使用4bit表达优先级](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr04.png)

用于表达优先级的这**4bit**，又被分组成**抢占优先级**和**子优先级**。

>**抢占原则**：如果有多个中断同时响应，抢占优先级高的就会抢占抢占优先级低的优先得到执行， 如果抢占优先级相同，就比较子优先级。如果抢占优先级和子优先级都相同的话，就比较他们的硬件中断编号，编号越小，优先级越高。

### 17.3.2. 优先级分组

优先级的分组由内核外设SCB的应用程序中断及复位控制寄存器AIRCR的PRIGROUP[10:8]位决定，F103分为了5组，具体如下：主优先级=抢占优先级

![](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr045.png)

设置优先级分组可调用库函数NVIC_PriorityGroupConfig()实现，有关NVIC中断相关的库函数都在库文件misc.c和misc.h中。

代码清单:中断-2 中断优先级分组库函数NVIC_PriorityGroupConfig()[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Interrupt_application.html#id10 "永久链接至代码")

```c
/**
* 配置中断优先级分组：抢占优先级和子优先级
* 形参如下：
* @arg NVIC_PriorityGroup_0: 0bit for抢占优先级
*                            4 bits for 子优先级
* @arg NVIC_PriorityGroup_1: 1 bit for抢占优先级
*                            3 bits for 子优先级
* @arg NVIC_PriorityGroup_2: 2 bit for抢占优先级
*                            2 bits for 子优先级
* @arg NVIC_PriorityGroup_3: 3 bit for抢占优先级
*                            1 bits for 子优先级
* @arg NVIC_PriorityGroup_4: 4 bit for抢占优先级
*                            0 bits for 子优先级
* @注意 如果优先级分组为0，则抢占优先级就不存在，优先级就全部由子优先级控制
*/
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
    // 设置优先级分组
    SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
}
```

![优先级分组真值表](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/interr05.png)

>**计算优先级等级数**：以NVIC_PriorityGroup_0为例，主0-bit，子4-bit，那么四位二进位的状态一共有2^4=16种(包含0000)




## 17.4. 中断编程
在配置每个中断的时候一般有3个编程要点：

1. 使能外设某个中断，这个具体由每个外设的相关中断使能位控制。比如串口有发送完成中断，接收完成中断，这两个中断都由串口控制寄存器的相关中断使能位控制。
    
2. 初始化NVIC_InitTypeDef结构体，配置中断优先级分组，设置抢占优先级和子优先级， 使能中断请求。NVIC_InitTypeDef结构体在固件库头文件misc.h中定义。
    

代码清单:中断-3 NVIC初始化结构体[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Interrupt_application.html#id13 "永久链接至代码")

```c
typedef struct {
    uint8_t NVIC_IRQChannel;                    // 中断源
    uint8_t NVIC_IRQChannelPreemptionPriority;  // 抢占优先级
    uint8_t NVIC_IRQChannelSubPriority;         // 子优先级
    FunctionalState NVIC_IRQChannelCmd;         // 中断使能或者失能
} NVIC_InitTypeDef;
```
有关NVIC初始化结构体的成员我们一一解释下：

a. NVIC_IROChannel：用来设置中断源，不同的中断中断源不一样，且不可写错，即使写错了程序也不会报错，只会导致不响应中断。 具体的成员配置可参考stm32f10x.h头文件里面的IRQn_Type结构体定义，这个结构体包含了所有的中断源。

代码清单:中断-4 IRQn_Type中断源结构体[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Interrupt_application.html#id14 "永久链接至代码")

```c
typedef enum IRQn {
    //Cortex-M3 处理器异常编号
    NonMaskableInt_IRQn      = -14,
    MemoryManagement_IRQn    = -12,
    BusFault_IRQn            = -11,
    UsageFault_IRQn          = -10,
    SVCall_IRQn              = -5,
    DebugMonitor_IRQn        = -4,
    PendSV_IRQn              = -2,
    SysTick_IRQn             = -1,
    //STM32 外部中断编号
    WWDG_IRQn                = 0,
    PVD_IRQn                 = 1,
    TAMP_STAMP_IRQn          = 2,

    // 限于篇幅，中间部分代码省略，具体的可查看库文件stm32f10x.h

    DMA2_Channel2_IRQn       = 57,
    DMA2_Channel3_IRQn       = 58,
    DMA2_Channel4_5_IRQn     = 59
} IRQn_Type;
```
b. NVIC_IRQChannelPreemptionPriority：抢占优先级，具体的值要根据优先级分组来确定， 具体参考表格 [优先级分组真值表](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Interrupt_application.html#id11) 优先级分组真值表 。

c. NVIC_IRQChannelSubPriority：子优先级，具体的值要根据优先级分组来确定， 具体参考表格 [优先级分组真值表](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/Interrupt_application.html#id11) 优先级分组真值表 。

d. NVIC_IRQChannelCmd：中断使能（ENABLE）或者失能（DISABLE）。 操作的是NVIC_ISER和NVIC_ICER这两个寄存器。

3. 编写中断服务函数
    

在启动文件startup_stm32f10x_hd.s中我们预先为每个中断都写了一个中断服务函数，只是这些中断函数都是为空，为的只是初始化中断向量表。 实际的中断服务函数都需要我们重新编写，为了方便管理我们把中断服务函数统一写在stm32f10x_it.c这个库文件中。

关于中断服务函数的函数名必须跟启动文件里面预先设置的一样，如果写错，系统就在中断向量表中找不到中断服务函数的入口， 直接跳转到启动文件里面预先写好的空函数，并且在里面无限循环，实现不了中断。


## 17.5. 调试中断

Q:我发现一个有意思的现象,调试模式进入USART1接收中断后接收一帧的一个字节就离开了中断,但是我没有开调试时候发现可以接收一帧的所有字节

A:你遇到的这个现象可能与 **调试器的干预** 有关，尤其是调试模式下，代码执行速度较慢，可能会导致一些中断处理异常或提前退出。具体来说，在调试模式下，以下几个因素可能会导致你的 USART1 接收中断行为异常：

 1. **调试模式下中断响应延迟**

- 在调试模式下，调试器会暂停执行程序（例如使用单步执行），这可能会导致中断服务程序执行的时机被延迟，从而使 USART1 的接收中断服务函数（ISR）在接收完一个字节后就提前返回。
- 如果你在中断服务程序内有耗时操作（例如使用 `printf` 等调试输出），也可能导致中断处理逻辑变慢，从而导致只处理部分字节。

 2. **中断优先级设置**

- 如果中断优先级设置不当，可能会导致中断在调试模式下被抢占或错过。尤其是如果你在调试时使用了较高的中断优先级（例如 USART 或其他外部中断），可能会造成某些字节未能被及时接收。

 3. **调试器对中断的暂停影响**

- 调试器在进入中断时可能暂停或干扰中断的执行。这意味着，如果你在进入中断后进入单步调试，可能会打断中断的正常流程。
- 此外，某些调试器在触发中断时可能会有“暂停”策略，例如停在中断点或进入单步模式，这会导致某些中断处理程序在调试模式下表现异常。

 4. **USART接收缓存溢出**

- 如果你在调试时通过中断接收数据，并且调试器导致的延迟使得中断服务程序无法快速处理字节（特别是在接收到多个字节的情况下），则可能会发生缓冲区溢出，导致未接收所有数据。
- 你可以检查 USART 的接收缓存是否溢出，通常会有溢出标志位，例如 `USART_FLAG_ORE`（溢出错误）。


---

 **解决方案：**

 1. **增加中断优先级**

- 确保你的 USART 中断具有合适的优先级。中断优先级较低可能会导致被其他中断抢占，影响中断服务的正常执行。可以适当增加 USART 中断的优先级，减少调试模式下的影响。

```c
`NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;  // 设置优先级为0 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;          // 设置子优先级 NVIC_Init(&NVIC_InitStructure);`
```

 2. **避免在中断中使用耗时操作**

- 避免在中断服务程序中使用 `printf` 或其他耗时操作，因为它们会增加中断响应时间，可能导致只接收一个字节。
- 如果需要调试信息，考虑将调试信息放在主循环中，而不是中断处理程序内。

 3. **检查接收缓冲区**

- 确保你检查了 USART 接收缓冲区是否已满或者是否有溢出错误。例如，你可以通过检查 `USART_FLAG_ORE` 来确认是否有溢出错误。


`if (USART_GetFlagStatus(USART1, USART_FLAG_ORE) != RESET) {     // 溢出处理     USART_ClearFlag(USART1, USART_FLAG_ORE); }`

 4. **优化调试器设置**

- 在调试模式下，可以通过调整调试器的设置来减少调试器对中断的干预。例如，可以禁用断点或避免单步执行中断。
- 如果可能，避免在调试模式下使用单步调试，可以尝试使用“运行到光标”或者“停止时断点”等方式来检查问题。

 5. **使用 DMA（如果适用）**

- 如果你希望在接收多个字节时不中断，可以考虑使用 DMA（Direct Memory Access）模式来处理 USART 接收，这样可以在接收完一帧数据后通过 DMA 中断或标志来处理数据，而不是每接收到一个字节就进入中断。这样可以减少 CPU 的干预，提高接收效率。


----

 总结：

- **调试模式下中断行为异常** 是常见的问题，主要是由于调试器的干预导致的执行延迟或中断优先级问题。通过优化中断优先级、避免在中断中执行耗时操作、增加接收缓冲区的处理效率，通常可以解决这个问题。
- 如果需要处理大量数据并避免中断干预，建议使用 DMA 模式，这样可以在后台处理数据，不依赖于中断。

## 17.6. 补充说明

后续其他例程的某个外设配置过程的自定义函数如NVIC_Configuration()分别执行了 NVIC_PriorityGroupConfig() 配置中断优先级分组，NVIC_Init(&NVIC_InitStructure) 配置结构体赋值的将要设置的中断向量和其优先级， 注意这里的 **NVIC_PriorityGroupConfig是整个程序中只需要设置一次** 。

当设置好了中断优先级分组，其他各种外设对应的中断向量的中断优先级既是基于目前设置分组来解读， 假设配置为NVIC_PriorityGroup_0或者NVIC_PriorityGroup_4，那么给多个外设分别填充NVIC_InitStructure的子优先级或主优先级是无效的，所以说如果工程里面有用到许多的外设中断，那么在确定了想用哪一种优先级分组后再给每个外设对应的中断向量配置优先级。

在其他例程中很多将NVIC_PriorityGroupConfig写在了每个外设自己的中断配置函数里面，有些可能多个外设配置函数下重复了NVIC_PriorityGroupConfig()这句， 这里提醒用户后续编写自己程序时只需要调用一次即可，若重复调用相当于对中断相关寄存器重复赋值多次取最后一次赋值，并且从代码布局逻辑来说,NVIC_PriorityGroupConfig适合放在main()函数中。

# 18. EXTI—外部中断/事件控制器

本章参考资料：《STM32F10X-中文参考手册》中断和事件章节和8.4章节AFIO寄存器描述。

上一章节我们已经详细介绍了NVIC，对STM32F10x系列中断管理系统有个全局的了解，我们这章的内容是NVIC的实例应用， 也是STM32F10x控制器非常重要的一个资源。学习本章时，配合《STM32F10X-中文参考手册》中断和事件章节一起阅读，效果会更佳，特别是涉及到寄存器说明的部分。

特别说明，本书内容是以STM32F10X系列控制器资源讲解。

## 18.1. EXTI简介

EXTI（External interrupt/event controller）—外部中断/事件控制器，管理了控制器的20个中断/事件线。 每个中断/事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。EXTI可以实现对每个中断/事件线进行单独配置， 可以单独配置为中断或者事件，以及触发事件的属性。

## 18.2. EXTI功能框图

EXTI的功能框图包含了EXTI最核心内容，掌握了功能框图，对EXTI就有一个整体的把握，在编程时思路就非常清晰。EXTI功能框图见图 [EXTI功能框图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#id3) 。

在图 [EXTI功能框图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#id3) 可以看到很多在信号线上打一个斜杠并标注“20”字样，这个表示在控制器内部类似的信号线路有20个， 这与EXTI总共有20个中断/事件线是吻合的。所以我们只要明白其中一个的原理，那其他19个线路原理也就知道了。

![EXTI功能框图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/EXTI002.png)

EXTI可分为两大部分功能，一个是产生中断，另一个是产生事件，这两个功能从硬件上就有所不同。

首先我们来看图 [EXTI功能框图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#id3) 中红色虚线指示的电路流程。它是一个产生中断的线路，最终信号流入到NVIC控制器内。

编号1是输入线，EXTI控制器有19个中断/事件输入线，这些输入线可以通过寄存器设置为任意一个GPIO，也可以是一些外设的事件， 这部分内容我们将在后面专门讲解。输入线一般是存在电平变化的信号。

编号2是一个边沿检测电路，它会根据上升沿触发选择寄存器(EXTI_RTSR)和下降沿触发选择寄存器(EXTI_FTSR)对应位的设置来控制信号触发。 边沿检测电路以输入线作为信号输入端，如果检测到有边沿跳变就输出有效信号1给编号3电路，否则输出无效信号0。 而EXTI_RTSR和EXTI_FTSR两个寄存器可以控制需要检测哪些类型的电平跳变过程，可以是只有上升沿触发、只有下降沿触发或者上升沿和下降沿都触发。

编号3电路实际就是一个或门电路，它的一个输入来自编号2电路，另外一个输入来自软件中断事件寄存器(EXTI_SWIER)。EXTI_SWIER允许我们通过程序控制就可以启动中断/事件线， 这在某些地方非常有用。我们知道或门的作用就是有1就为1，所以这两个输入随便一个有有效信号1就可以输出1给编号4和编号6电路。

编号4电路是一个与门电路，它的一个输入是编号3电路，另外一个输入来自中断屏蔽寄存器(EXTI_IMR)。与门电路要求输入都为1才输出1， 导致的结果是如果EXTI_IMR设置为0时，那不管编号3电路的输出信号是1还是0，最终编号4电路输出的信号都为0；如果EXTI_IMR设置为1时， 最终编号4电路输出的信号才由编号3电路的输出信号决定，这样我们可以简单的控制EXTI_IMR来实现是否产生中断的目的。 编号4电路输出的信号会被保存到挂起寄存器(EXTI_PR)内，如果确定编号4电路输出为1就会把EXTI_PR对应位置1。

编号5是将EXTI_PR寄存器内容输出到NVIC内，从而实现系统中断事件控制。

接下来我们来看看绿色虚线指示的电路流程。它是一个产生事件的线路，最终输出一个脉冲信号。

产生事件线路是在编号3电路之后与中断线路有所不同，之前电路都是共用的。编号6电路是一个与门，它的一个输入来自编号3电路， 另外一个输入来自事件屏蔽寄存器(EXTI_EMR)。如果EXTI_EMR设置为0时，那不管编号3电路的输出信号是1还是0，最终编号6电路输出的信号都为0； 如果EXTI_EMR设置为1时，最终编号6电路输出的信号才由编号3电路的输出信号决定，这样我们可以简单的控制EXTI_EMR来实现是否产生事件的目的。

编号7是一个脉冲发生器电路，当它的输入端，即编号6电路的输出端，是一个有效信号1时就会产生一个脉冲；如果输入端是无效信号就不会输出脉冲。

编号8是一个脉冲信号，就是产生事件的线路最终的产物，这个脉冲信号可以给其他外设电路使用，比如定时器TIM、模拟数字转换器ADC等等，这样的脉冲信号一般用来触发TIM或者ADC开始转换。

产生中断线路目的是把输入信号输入到NVIC，进一步会运行中断服务函数，实现功能，这样是软件级的。而产生事件线路目的就是传输一个脉冲信号给其他外设使用， 并且是电路级别的信号传输，属于硬件级的。

另外，EXTI是在APB2总线上的，在编程时候需要注意到这点。

## 18.3. 中断/事件线

EXTI有20个中断/事件线，每个GPIO都可以被设置为输入线，占用EXTI0至EXTI15， 还有另外七根用于特定的外设事件，见表 [EXTI中断_事件线](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#id5) 。

4根特定外设中断/事件线由外设触发，具体用法参考《STM32F10X-中文参考手册》中对外设的具体说明。

![EXTI中断/事件线](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/EXTI01.png)

EXTI0至EXTI15用于GPIO，通过编程控制可以实现任意一个GPIO作为EXTI的输入源。由表 [EXTI中断_事件线](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#id5) 可知， EXTI0可以通过AFIO的外部中断配置寄存器1(AFIO_EXTICR1)的EXTI0[3:0]位选择配置为PA0、 PB0、PC0、PD0、PE0、PF0、PG0、PH0或者PI0，见图 [EXTI0输入源选择](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#exti0) 。其他EXTI线(EXTI中断/事件线)使用配置都是类似的。

![EXTI0输入源选择](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/EXTI003.png)

## 18.4. EXTI初始化结构体详解

标准库函数对每个外设都建立了一个初始化结构体，比如EXTI_InitTypeDef，结构体成员用于设置外设工作参数，并由外设初始化配置函数， 比如EXTI_Init()调用，这些设定参数将会设置外设相应的寄存器，达到配置外设工作环境的目的。

初始化结构体和初始化库函数配合使用是标准库精髓所在，理解了初始化结构体每个成员意义基本上就可以对该外设运用自如了。 初始化结构体定义在stm32f10x_exti.h文件中，初始化库函数定义在stm32f10x_exti.c文件中，编程时我们可以结合这两个文件内注释使用。

代码清单:EXTI-1 EXTI初始化结构体[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#exti-1 "永久链接至代码")

```c
typedef struct {
    uint32_t EXTI_Line;                 // 中断/事件线
    EXTIMode_TypeDef EXTI_Mode;         // EXTI模式
    EXTITrigger_TypeDef EXTI_Trigger;   // 触发类型
    FunctionalState EXTI_LineCmd;       // EXTI使能
} EXTI_InitTypeDef;
```
1. EXTI_Line：EXTI中断/事件线选择，可选EXTI0至EXTI19，可参考表 [EXTI中断_事件线](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#id5) 选择。
    
2. EXTI_Mode：EXTI模式选择，可选为产生中断(EXTI_Mode_Interrupt)或者产生事件(EXTI_Mode_Event)。
    
3. EXTI_Trigger：EXTI边沿触发事件，可选上升沿触发(EXTI_Trigger_Rising)、 下降沿触发( EXTI_Trigger_Falling)或者上升沿和下降沿都触发( EXTI_Trigger_Rising_Falling)。
    
4. EXTI_LineCmd：控制是否使能EXTI线，可选使能EXTI线(ENABLE)或禁用(DISABLE)。
    

## 18.5. 外部中断控制实验

中断在嵌入式应用中占有非常重要的地位，几乎每个控制器都有中断功能。中断对保证紧急事件得到第一时间处理是非常重要的。

我们设计使用外接的按键来作为触发源，使得控制器产生中断，并在中断服务函数中实现控制RGB彩灯的任务。

### 18.5.1. 硬件设计

轻触按键在按下时会使得引脚接通，通过电路设计可以使得按下时产生电平变化，见图 [按键电路设计](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#id9) 。

![按键电路设计](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/EXTI004.png)

### 18.5.2. 软件设计

这里只讲解核心的部分代码，有些变量的设置，头文件的包含等并没有涉及到，完整的代码请参考本章配套的工程。 我们创建了两个文件：bsp_exti.c和bsp_exti.h文件用来存放EXTI驱动程序及相关宏定义，中断服务函数放在stm32f10x_it.h文件中。

#### 18.5.2.1. 编程要点

> 1. 初始化用来产生中断的GPIO；
>     
> 2. 初始化EXTI；
>     
> 3. 配置NVIC；
>     
> 4. 编写中断服务函数；
>     

#### 18.5.2.2. 软件分析

**按键和EXTI宏定义**

代码清单:EXTI-2 按键和EXTI 宏定义[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#exti-2 "永久链接至代码")

```c
//引脚定义
#define KEY1_INT_GPIO_PORT         GPIOA
#define KEY1_INT_GPIO_CLK          (RCC_APB2Periph_GPIOA\
                                    |RCC_APB2Periph_AFIO)
#define KEY1_INT_GPIO_PIN          GPIO_Pin_0
#define KEY1_INT_EXTI_PORTSOURCE   GPIO_PortSourceGPIOA
#define KEY1_INT_EXTI_PINSOURCE    GPIO_PinSource0
#define KEY1_INT_EXTI_LINE         EXTI_Line0
#define KEY1_INT_EXTI_IRQ          EXTI0_IRQn // 将前者中断函数名与后者关联

#define KEY1_IRQHandler            EXTI0_IRQHandler

#define KEY2_INT_GPIO_PORT         GPIOC
#define KEY2_INT_GPIO_CLK          (RCC_APB2Periph_GPIOC\
                                    |RCC_APB2Periph_AFIO)
#define KEY2_INT_GPIO_PIN          GPIO_Pin_13
#define KEY2_INT_EXTI_PORTSOURCE   GPIO_PortSourceGPIOC
#define KEY2_INT_EXTI_PINSOURCE    GPIO_PinSource13
#define KEY2_INT_EXTI_LINE         EXTI_Line13
#define KEY2_INT_EXTI_IRQ          EXTI15_10_IRQn // 将前者中断函数名与后者关联
```


使用宏定义方法指定与硬件电路设计相关配置，这对于程序移植或升级非常有用的。

在上面的宏定义中，我们除了开GPIO的端口时钟外，我们还打开了AFIO的时钟， 这是因为等下配置EXTI信号源的时候需要用到AFIO的外部中断控制寄存器AFIO_EXTICRx， 具体见《STM32F10X-中文参考手册》8.4章节AFIO寄存器描述。

**嵌套向量中断控制器NVIC配置**

代码清单:EXTI-3 NVIC配置[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#exti-3 "永久链接至代码")

```c
static void NVIC_Configuration(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;

    /* 配置NVIC为优先级组1 */
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);

    /* 配置中断源：按键1 */
    NVIC_InitStructure.NVIC_IRQChannel = KEY1_INT_EXTI_IRQ;
    /* 配置抢占优先级：1 */
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    /* 配置子优先级：1 */
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    /* 使能中断通道 */
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);

    /* 配置中断源：按键2，其他使用上面相关配置 */
    NVIC_InitStructure.NVIC_IRQChannel = KEY2_INT_EXTI_IRQ;
    NVIC_Init(&NVIC_InitStructure);
}
```
有关NVIC配置问题可参考《STM32中断应用概览》章节内容，这里不做过多解释。

这里我们配置两个的中断软件优先级一样，如果出现了两个按键同时按下的情况，那怎么办，到底该执行哪一个中断？当两个中断的软件优先级一样的时候， 中断来临时，具体先执行哪个中断服务函数由硬件的中断编号决定，编号越小，优先级越高。 有关外设的硬件编号可查询《STM32F10X-中文参考手册》的中断和事件章节中的向量表，表中的位置编号即是每个外设的硬件中断优先级。 当然，我们也可以把抢占优先级设置成一样，**子优先级设置成不一样**，这样就可以区别两个按键同时按下的情况，而不用硬件去对比硬件编号。

**EXTI中断配置**

代码清单:EXTI-4 EXTI中断配置[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#exti-4 "永久链接至代码")

```c
void EXTI_Key_Config(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    EXTI_InitTypeDef EXTI_InitStructure;

    /*开启按键GPIO口的时钟*/
    RCC_APB2PeriphClockCmd(KEY1_INT_GPIO_CLK,ENABLE);

    /* 配置 NVIC 中断*/
    NVIC_Configuration();

    /*--------------------------KEY1配置---------------------*/
    /* 选择按键用到的GPIO */
    GPIO_InitStructure.GPIO_Pin = KEY1_INT_GPIO_PIN;
    /* 配置为浮空输入 */
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(KEY1_INT_GPIO_PORT, &GPIO_InitStructure);

    /* 选择EXTI的信号源 */
    GPIO_EXTILineConfig(KEY1_INT_EXTI_PORTSOURCE, \
                        KEY1_INT_EXTI_PINSOURCE);
    EXTI_InitStructure.EXTI_Line = KEY1_INT_EXTI_LINE;

    /* EXTI为中断模式 */
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    /* 上升沿中断 */
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
    /* 使能中断 */
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStructure);

    /*--------------------------KEY2配置------------------*/
    /* 选择按键用到的GPIO */
    GPIO_InitStructure.GPIO_Pin = KEY2_INT_GPIO_PIN;
    /* 配置为浮空输入 */
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(KEY2_INT_GPIO_PORT, &GPIO_InitStructure);

    /* 选择EXTI的信号源 */
    GPIO_EXTILineConfig(KEY2_INT_EXTI_PORTSOURCE, \
                        KEY2_INT_EXTI_PINSOURCE);
    EXTI_InitStructure.EXTI_Line = KEY2_INT_EXTI_LINE;

    /* EXTI为中断模式 */
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    /* 下降沿中断 */
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
    /* 使能中断 */
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStructure);
}
```
首先，使用GPIO_InitTypeDef和EXTI_InitTypeDef结构体定义两个用于GPIO和EXTI初始化配置的变量，关于这两个结构体前面都已经做了详细的讲解。

使用GPIO之前必须开启GPIO端口的时钟；用到EXTI必须开启AFIO时钟。

调用NVIC_Configuration函数完成对按键1、按键2优先级配置并使能中断通道。

作为中断/事件输入线时需把GPIO配置为输入模式，具体为浮空输入，由外部电路完全决定引脚的状态。

GPIO_EXTILineConfig函数用来指定中断/事件线的输入源，它实际是设定外部中断配置寄存器的AFIO_EXTICRx值，该函数接收两个参数， 第一个参数指定GPIO端口源，第二个参数为选择对应GPIO引脚源编号。

我们的目的是产生中断，执行中断服务函数，EXTI选择中断模式，按键1使用上升沿触发方式，并使能EXTI线。

按键2基本上采用与按键1相关参数配置，只是改为下降沿触发方式。

两个按键的电路是一样的，可代码中我们设置按键1是上升沿中断，按键2是下降沿中断，有人就会问这是不是设置错了？实际上可以这么理解， 按键1检测的是按键按下的状态，按键2检测的是按键弹开的状态，那这样就解释的通了。

**EXTI中断服务函数**

代码清单:EXTI-5 EXTI中断服务函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#exti-5 "永久链接至代码")

```c
void KEY1_IRQHandler(void)
{
    //确保是否产生了EXTI Line中断
    if (EXTI_GetITStatus(KEY1_INT_EXTI_LINE) != RESET) {
        // LED1 取反
        LED1_TOGGLE;
        //清除中断标志位
        EXTI_ClearITPendingBit(KEY1_INT_EXTI_LINE);
    }
}

void KEY2_IRQHandler(void)
{
    //确保是否产生了EXTI Line中断
    if (EXTI_GetITStatus(KEY2_INT_EXTI_LINE) != RESET) {
        // LED2 取反
        LED2_TOGGLE;
        //清除中断标志位
        EXTI_ClearITPendingBit(KEY2_INT_EXTI_LINE);
    }
}
```
当中断发生时，对应的中断服务函数就会被执行，我们可以在中断服务函数实现一些控制。

一般为确保中断确实发生，我们会在中断服务函数中调用中断标志位状态读取函数读取外设中断标志位并判断标志位状态。

EXTI_GetITStatus函数用来获取EXTI的中断标志位状态，如果EXTI线有中断发生函数返回“SET”否则返回“RESET”。 实际上，EXTI_GetITStatus函数是通过读取EXTI_PR寄存器值来判断EXTI线状态的。

按键1的中断服务函数我们让LED1翻转其状态，按键2的中断服务函数我们让LED2翻转其状态。**执行任务后需要调用EXTI_ClearITPendingBit函数清除EXTI线的中断标志位**。

**主函数**

代码清单:EXTI-6 主函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/EXTI.html#exti-6 "永久链接至代码")

```c
int main(void)
{
    /* LED 端口初始化 */
    LED_GPIO_Config();

    /* 初始化EXTI中断，按下按键会触发中断，
    *  触发中断会进入stm32f10x_it.c文件中的函数
    *  KEY1_IRQHandler和KEY2_IRQHandler，处理中断，反转LED灯。
    */
    EXTI_Key_Config();

    /* 等待中断，由于使用中断方式，CPU不用轮询按键 */
    while (1) {
    }
}
```
主函数非常简单，只有两个任务函数。LED_GPIO_Config函数定义在bsp_led.c文件内，完成RGB彩灯的GPIO初始化配置。EXTI_Key_Config函数完成两个按键的GPIO和EXTI配置。

### 18.5.3. 下载验证

保证开发板相关硬件连接正确，把编译好的程序下载到开发板。此时RGB彩色灯是暗的，如果我们按下开发板上的按键1，RGB彩灯变亮， 再按下按键1，RGB彩灯又变暗；如果我们按下开发板上的按键2并弹开，RGB彩灯变亮，再按下开发板上的KEY2并弹开，RGB彩灯又变暗。 按键按下表示上升沿，按键弹开表示下降沿，这跟我们软件设置是一样的。

## 18.6. 补充说明

关于使用外部按键中断的理解补充，按教程与参考手册的中断/事件线与输入源的表格看，可以使用EXTI0至15线路对应到使用16个GPIO做外部中断， 需要注意的是这16个线路并非都有单独的中断源，从stm32f10x.h查看对应芯片型号有EXTI0_IRQn、EXTI1_IRQn、EXTI2_IRQn、EXTI3_IRQn、EXTI4_IRQn、EXTI9_5_IRQn、EXTI15_10_IRQn， 再查看启动文件那边定义的中断函数同样也是EXTI0_IRQHandler、EXTI1_IRQHandler、EXTI2_IRQHandler、EXTI3_IRQHandler、EXTI4_IRQHandler、EXTI9_5_IRQHandler、EXTI15_10_IRQHandler。

除了前面4个线路有单独的中断函数，后面5至9和10至15线路使用 **复用** 的思想思考，区分出什么是可以唯一标识的，什么是复用的，EXTI_Lines在寄存器中都是一一对应状态标位,中断函数复用， 因此在EXTI9_5_IRQHandler和EXTI15_10_IRQHandler的中断函数里面使用多次EXTI_GetITStatus函数来判断出线路。

这里再次强调一下关于STM32中断应用概览章节的补充说明内容， **NVIC_PriorityGroupConfig是整个程序中只需要设置一次** ，当设置好了中断优先级分组，其他各种外设对应的中断向量的中断优先级既是基于目前设置分组来解读。

在其他例程中很多将NVIC_PriorityGroupConfig写在了每个外设自己的中断配置函数里面，有些可能多个外设配置函数下重复了NVIC_PriorityGroupConfig()这句， 这里提醒用户后续编写自己程序时只需要调用一次即可，并且从代码布局逻辑来说适合放在main()函数中。




# 19. SysTick—系统定时器

本章参考资料《Cortex-M3内核编程手册》-4.5 章节SysTick Timer(STK)，和4.48章节SHPRx， 其中STK这个章节有SysTick的简介和寄存器的详细描述。因为SysTick是属于CM3内核的外设， 有关寄存器的定义和部分库函数都在core_CM3.h这个头文件中实现。所以学习SysTick的时候可以参考这两个资料，一个是文档，一个是源码。

## 19.1. SysTick简介

SysTick—系统定时器是属于CM3内核中的一个外设，内嵌在NVIC中。系统定时器是一个24bit的向下递减的计数器， 计数器每计数一次的时间为1/SYSCLK，一般我们设置系统时钟SYSCLK等于72M。当重装载数值寄存器的值递减到0的时候，系统定时器就产生一次中断，以此循环往复。

因为SysTick是属于CM3内核的外设，所以所有基于CM3内核的单片机都具有这个系统定时器，使得软件在CM3单片机中可以很容易的移植。 系统定时器一般用于操作系统，用于产生时基，维持操作系统的心跳。

## 19.2. SysTick寄存器介绍

SysTick—系统定时器有4个寄存器，简要介绍如下。在使用SysTick产生定时的时候，只需要配置前三个寄存器，最后一个校准寄存器不需要使用。

![SysTick寄存器汇总](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic01.png)![SysTick控制及状态寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic02.png)![SysTick重装载数值寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic03.png)![SysTick当前数值寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic04.png)![SysTick校准数值寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic05.png)

系统定时器的校准数值寄存器在定时实验中不需要用到。有关各个位的描述这里引用手册里面的英文版本，比较晦涩难懂， 暂时不知道这个寄存器用来干什么。有研究过的朋友可以交流，起个抛砖引玉的作用。

## 19.3. SysTick定时实验

利用SysTick产生1s的时基，LED以1s的频率闪烁。

### 19.3.1. 硬件设计

SysTick属于单片机内部的外设，不需要额外的硬件电路，剩下的只需一个LED灯即可。

### 19.3.2. 软件设计

这里只讲解核心的部分代码，有些变量的设置，头文件的包含等并没有涉及到，完整的代码请参考本章配套的工程。 我们创建了两个文件：bsp_SysTick.c和bsp_ SysTick.h文件用来存放SysTick驱动程序及相关宏定义， 中断服务函数放在stm32f10x_it.c文件中。

#### 19.3.2.1. 编程要点

1、设置重装载寄存器的值

2、清除当前数值寄存器的值

3、配置控制与状态寄存器

#### 19.3.2.2. 代码分析

SysTick 属于内核的外设，有关的寄存器定义和库函数都在内核相关的库文件core_cm3.h中。

**SysTick配置库函数**

代码清单:SysTick-1SysTick配置库函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SysTick.html#systick-1 "永久链接至代码")

```c
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
    // 不可能的重装载值，超出范围
    if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) {
        return (1UL);
    }

    // 设置重装载寄存器
    SysTick->LOAD  = (uint32_t)(ticks - 1UL);

    // 设置中断优先级
    NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL);

    // 设置当前数值寄存器
    SysTick->VAL   = 0UL;

    // 设置系统定时器的时钟源为AHBCLK=72M
    // 使能系统定时器中断
    // 使能定时器
    SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
                    SysTick_CTRL_TICKINT_Msk   |
                    SysTick_CTRL_ENABLE_Msk;
    return (0UL);
}
```
用固件库编程的时候我们只需要调用库函数SysTick_Config()即可，形参ticks用来设置重装载寄存器的值， 最大不能超过重装载寄存器的值224，当重装载寄存器的值递减到0的时候产生中断，然后重装载寄存器的值又重新装载往下递减计数， 以此循环往复。紧随其后设置好中断优先级，最后配置系统定时器的时钟等于AHBCLK=72M，使能定时器和定时器中断，这样系统定时器就配置好了，一个库函数搞定。

SysTick_Config()库函数主要配置了SysTick中的三个寄存器：LOAD、VAL和CTRL，有关具体的部分看代码注释即可。

**配置SysTick中断优先级**

在SysTick_Config()库函数还调用了固件库函数NVIC_SetPriority()来配置系统定时器的中断优先级，该库函数也在core_m3.h中定义，原型如下：

```c
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
    if ((int32_t)IRQn < 0) {
        SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] =
        (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    } else {
        NVIC->IP[((uint32_t)(int32_t)IRQn)] =
        (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    }
}
```

函数首先先判断形参IRQn的大小，如果是小于0，则表示这个是系统异常，系统异常的优先级由内核外设SCB的寄存器SHPRx控制， 如果大于0则是外部中断，外部中断的优先级由内核外设NVIC中的IPx寄存器控制。

因为SysTick属于内核外设，跟普通外设的中断优先级有些区别，并没有抢占优先级和子优先级的说法。在STM32F103中， 内核外设的中断优先级由内核SCB这个外设的寄存器：SHPRx（x=1.2.3）来配置。有关SHPRx寄存器的详细描述可参考《Cortex-M3内核编程手册》4.4.8章节。 下面我们简单介绍下这个寄存器。

SPRH1-SPRH3是一个32位的寄存器，但是只能通过字节访问，每8个字段控制着一个内核外设的中断优先级的配置。在STM32F103中， 只有位7:4这高四位有效，低四位没有用到，所以内核外设的中断优先级可编程为：0~15，只有16个可编程优先级，数值越小，优先级越高。 如果软件优先级配置相同，那就根据他们在中断向量表里面的位置编号来决定优先级大小，编号越小，优先级越高。

![系统异常优先级字段](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic06.png)

如果要修改内核外设的优先级，只需要修改下面三个寄存器对应的某个字段即可。

![SHPR1寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic002.png)![SHPR2寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic003.jpeg)![SHPR3寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SysTic004.png)

在系统定时器中，配置优先级为(1UL << __NVIC_PRIO_BITS) - 1UL)， 其中宏__NVIC_PRIO_BITS为4，那计算结果就等于15， 可以看出系统定时器此时设置的优先级在内核外设中是最低的，如果要修改优先级则修改这个值即可，范围为：0~15。

```c
// 设置系统定时器中断优先级
NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL);
```

但是，问题来了，刚刚我们只是学习了内核的外设的优先级配置。如果我同时使用了systick和片上外设呢？而且片上外设也刚好需要使用中断， 那systick的中断优先级跟外设的中断优先级怎么设置？会不会因为systick是内核里面的外设，所以它的中断优先级就一定比内核之外的外设的优先级高？

从《STM32中断应用概览》这章我们知道，外设在设置中断优先级的时候，首先要分组，然后设置抢占优先级和子优先级。 而systick这类内核的外设在配置的时候，只需要配置一个寄存器即可，取值范围为0~15。既然配置方法不同，那如何区分两者的优先级？下面举例说明。

比如配置一个外设的中断优先级分组为2，抢占优先级为1，子优先级也为1，systick的优先级为固件库默认配置的15。 当我们比较内核外设和片上外设的中断优先级的时候，我们只需要抓住NVIC的中断优先级分组不仅对片上外设有效，同样对内核的外设也有效。 我们把systick的优先级15转换成二进制值就是1111(0b)，又因为NVIC的优先级分组2，那么前两位的11(0b)就是3，后两位的11(0b)也是3。 无论从抢占还是子优先级都比我们设定的外设的优先级低。如果当两个的软件优先级都配置成一样，那么就比较他们在中断向量表中的硬件编号，编号越小，优先级越高。

**SysTick初始化函数**

代码清单:SysTick-2 SysTick初始化函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SysTick.html#systick-2 "永久链接至代码")

```c
/**
* @brief  启动系统滴答定时器 SysTick
* @param  无
* @retval 无
*/
void SysTick_Init(void)
{
    /* SystemFrequency / 1000    1ms中断一次
    * SystemFrequency / 100000  10us中断一次
    * SystemFrequency / 1000000 1us中断一次
    */
    if (SysTick_Config(SystemCoreClock / 100000)) {
        /* Capture error */
        while (1);
    }
}
```
SysTick初始化函数由用户编写，里面调用了SysTick_Config()这个固件库函数， 通过设置该固件库函数的形参，就决定了系统定时器经过多少时间就产生一次中断。

**SysTick中断时间的计算**

SysTick定时器的计数器是向下递减计数的，计数一次的时间TDEC=1/CLKAHB， 当重装载寄存器中的值VALUELOAD减到0的时候，产生中断， 可知中断一次的时间TINT=VALUELOAD * TDEC= VALUELOAD/CLKAHB， 其中CLKAHB =72MHZ。如果设置VALUELOAD为72， 那中断一次的时间TINT=72/72M=1us。 不过1us的中断没啥意义，整个程序的重心都花在进出中断上了，根本没有时间处理其他的任务。

SysTick_Config(SystemCoreClock / 100000)

SysTick_Config（）的形我们配置为SystemCoreClock / 100000=72M/100000=720， 从刚刚分析我们知道这个形参的值最终是写到重装载寄存器LOAD中的， 从而可知我们现在把SysTick定时器中断一次的时间TINT=720/72M=10us。

**SysTick定时时间的计算**

当设置好中断时间TINT后，我们可以设置一个变量t，用来记录进入中断的次数， 那么变量t乘以中断的时间TINT就可以计算出需要定时的时间。

**SysTick定时函数**

现在我们定义一个微秒级别的延时函数，形参为nTime，当用这个形参乘以中断时间TINT就得出我们需要的延时时间， 其中TINT我们已经设置好为10us。关于这个函数的具体调用看注释即可。

```c
/**
* @brief   us延时程序,10us为一个单位
* @param
*   @arg nTime: Delay_us( 1 ) 则实现的延时为 1 * 10us = 10us
* @retval  无
*/
void Delay_us(__IO u32 nTime)
{
    TimingDelay = nTime;

    while (TimingDelay != 0);
}
```
函数Delay_us()中我们等待TimingDelay为0，当TimingDelay为0的时候表示延时时间到。变量TimingDelay在中断函数中递减， 即SysTick每进一次中断即10us的时间TimingDelay递减一次。

**SysTick中断服务函数**

```c
void SysTick_Handler(void)
{
    TimingDelay_Decrement();
}

中断复位函数调用了另外一个函数TimingDelay_Decrement()，原型如下：

/**
* @brief  获取节拍程序
* @param  无
* @retval 无
* @attention  在 SysTick 中断函数 SysTick_Handler()调用
*/
void TimingDelay_Decrement(void)
{
    if (TimingDelay != 0x00) {
        TimingDelay--;
    }
}
```

TimingDelay的值等于延时函数中传进去的nTime的值，比如nTime=100000，则延时的时间等于100000*10us=1s。

**主函数**

```c
int main(void)
{
    /* LED 端口初始化 */
    LED_GPIO_Config();

    /* 配置SysTick 为10us中断一次,时间到后触发定时中断，
    *进入stm32fxx_it.c文件的SysTick_Handler处理，通过数中断次数计时
    */
    SysTick_Init();

    while (1) {

        LED_ON;
        Delay_us(100000);   // 10000 * 10us = 1000ms

        LED2_ON;
        Delay_us(100000);   // 10000 * 10us = 1000ms

        LED3_ON;
        Delay_us(100000);   // 10000 * 10us = 1000ms
    }
}
```
主函数中初始化了LED和SysTick，然后在一个while循环中以1s的频率让LED闪烁。

另外一种更简洁的定时编程

上面的实验，我们是使用了中断，而且经过多个函数的调用，还使用了全局变量，理解起来挺费劲的，其实还有另外一种更简洁的写法。 我们知道，systick的counter从reload值往下递减到0的时候，CTRL寄存器的位16:countflag会置1，且读取该位的值可清0， 所有我们可以使用软件查询的方法来实现延时。具体代码见 [代码清单:SysTick-3](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SysTick.html#systick-3) 和 [代码清单:SysTick-4](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SysTick.html#systick-4) ，我敢肯定这样的写法， 初学者肯定会更喜欢，因为它直接，套路浅。

代码清单:SysTick-3 systick 微秒级延时[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SysTick.html#systick-3 "永久链接至代码")

```c
void SysTick_Delay_Us( __IO uint32_t us)
{
    uint32_t i;
    SysTick_Config(SystemCoreClock/1000000);

    for (i=0; i<us; i++) {
        // 当计数器的值减小到0的时候，CRTL寄存器的位16会置1
        while ( !((SysTick->CTRL)&(1<<16)) );
    }
    // 关闭SysTick定时器
    SysTick->CTRL &=~SysTick_CTRL_ENABLE_Msk;
}
```
代码清单:SysTick-4 systick 毫秒级延时[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SysTick.html#systick-4 "永久链接至代码")

```c
void SysTick_Delay_Ms( __IO uint32_t ms)
{
    uint32_t i;
    SysTick_Config(SystemCoreClock/1000);

    for (i=0; i<ms; i++) {
        // 当计数器的值减小到0的时候，CRTL寄存器的位16会置1
        // 当置1时，读取该位会清0
        while ( !((SysTick->CTRL)&(1<<16)) );
    }
    // 关闭SysTick定时器
    SysTick->CTRL &=~ SysTick_CTRL_ENABLE_Msk;
}
```
在这两个微秒和毫秒级别的延时函数中，我们还是调用了SysTick_Config这个固件库函数，有关这个函数的说明具体见 [代码清单:SysTick-5](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SysTick.html#systick-5) 。 配套代码注释理解即可。其中SystemCoreClock是一个宏，大小为72000000，如果不想使用这个宏，也可以直接改成数字。

代码清单:SysTick-5 systick 配置函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SysTick.html#systick-5 "永久链接至代码")

```c
// 这个 固件库函数 在 core_cm3.h中
static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{
    // reload 寄存器为24bit，最大值为2^24
    if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);

    // 配置 reload 寄存器的初始值
    SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;

    // 配置中断优先级为 1<<4 -1 = 15，优先级为最低
    NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);

    // 配置 counter 计数器的值
    SysTick->VAL   = 0;

    // 配置systick 的时钟为 72M
    // 使能中断
    // 使能systick
    SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
                    SysTick_CTRL_TICKINT_Msk   |
                    SysTick_CTRL_ENABLE_Msk;
    return (0);
}
```

# 20. 通讯的基本概念

在计算机设备与设备之间或集成电路之间常常需要进行数据传输，在本书后面的章节中我们会学习到各种各样的通讯方式， 所以在本章中我们先统一介绍这些通讯的基本概念。

## 20.1. 串行通讯与并行通讯

按数据传送的方式，通讯可分为串行通讯与并行通讯，串行通讯是指设备之间通过少量数据信号线(一般是8根以下)， 地线以及控制信号线，按数据位形式一位一位地传输数据的通讯方式。而并行通讯一般是指使用8、16、32及64根或更多的数据线进行传输的通讯方式， 它们的通讯传输对比说明见图 [并行通讯与串行通讯的对比图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/communication.html#id3) ，并行通讯就像多个车道的公路， 可以同时传输多个数据位的数据，而串行通讯，而串行通讯就像单个车道的公路，同一时刻只能传输一个数据位的数据。

![并行通讯与串行通讯的对比图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/commun002.jpg)

很明显，因为一次可传输多个数据位的数据 ，在数据传输速率相同的情况下，并行通讯传输的数据量要大得多， 而串行通讯则可以节省数据线的硬件成本(特别是远距离时)以及PCB的布线面积， 串行通讯与并行通讯的特性对比见表 [串行通讯与并行通讯的特性对比](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/communication.html#id4) 。

![串行通讯与并行通讯的特性对比](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/commun01.png)

不过由于并行传输对同步要求较高，且随着通讯速率的提高，信号干扰的问题会显著影响通讯性能，现在随着技术的发展，越来越多的应用场合采用高速率的串行差分传输。

## 20.2. 全双工、半双工及单工通讯

根据数据通讯的方向，通讯又分为全双工、半双工及单工通讯，它们主要以信道的方向来区分，见图 [全双工-半双工及单工通讯](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/communication.html#id7) 及表 [通讯方式说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/communication.html#id6)。

![通讯方式说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/commun02.png)

仍以公路来类比，全双工的通讯就是一个双向车道，两个方向上的车流互不相干；半双工则像乡间小道那样，同一时刻只能让一辆小车通过， 另一方向的来车只能等待道路空出来时才能经过；而单工则像单行道，另一方向的车辆完全禁止通行。

![全双工、半双工及单工通讯](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/commun003.jpg)

## 20.3. 同步通讯与异步通讯

根据通讯的数据同步方式，又分为同步和异步两种，可以根据通讯过程中是否有使用到时钟信号进行简单的区分。

在同步通讯中，收发设备双方会使用一根信号线表示时钟信号，在时钟信号的驱动下双方进行协调， 同步数据，见图 [同步通讯](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/communication.html#id9) 。 通讯中通常双方会统一规定在时钟信号的上升沿或下降沿对数据线进行采样。

![同步通讯](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/commun004.jpg)

在异步通讯中不使用时钟信号进行数据同步，它们直接在数据信号中穿插一些同步用的信号位，或者把主体数据进行打包， 以数据帧的格式传输数据，见图 [某种异步通讯](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/communication.html#id10) ，某些通讯中还需要双方约定数据的传输速率，以便更好地同步。

![某种异步通讯](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/commun005.jpg)

在同步通讯中，数据信号所传输的内容绝大部分就是有效数据，而异步通讯中会包含有帧的各种标识符，所以同步通讯的效率更高， 但是同步通讯双方的时钟允许误差较小，而异步通讯双方的时钟允许误差较大。

## 20.4. 通讯速率

衡量通讯性能的一个非常重要的参数就是通讯速率，通常以比特率(Bitrate)来表示，即每秒钟传输的二进制位数， 单位为比特每秒(bit/s)。容易与比特率混淆的概念是“波特率”(Baudrate)，它表示每秒钟传输了多少个码元。 而码元是通讯信号调制的概念，通讯中常用时间间隔相同的符号来表示一个二进制数字，这样的信号称为码元。 

如常见的通讯传输中，用0V表示数字0，5V表示数字1，那么一个码元可以表示两种状态0和1，所以一个码元等于一个二进制比特位， 此时波特率的大小与比特率一致

如果在通讯传输中，有0V、2V、4V以及6V分别表示二进制数00、01、10、11， 那么每个码元可以表示四种状态，即两个二进制比特位，所以码元数是二进制比特位数的一半，这个时候的波特率为比特率的一半。 

因为很多常见的通讯中一个码元都是表示两种状态，人们常常直接以波特率来表示比特率，虽然严格来说没什么错误，但希望您能了解它们的区别。




# 21. USART—串口通讯

本章参考资料：《STM32F10X-中文参考手册》USART章节。学习本章时，配合《STM32F10X-中文参考手册》USART章节一起阅读， 效果会更佳，特别是涉及到寄存器说明的部分。特别说明，本书内容是以STM32F103系列控制器资源讲解。

## 21.1. 串口通讯协议简介

串口通讯(Serial Communication)是一种设备间非常常用的串行通讯方式，因为它简单便捷，因此大部分电子设备都支持该通讯方式， 电子工程师在调试设备时也经常使用该通讯方式输出调试信息。

在计算机科学里，大部分复杂的问题都可以通过分层来简化。如芯片被分为内核层和片上外设；STM32标准库则是在寄存器与用户代码之间的软件层。 对于通讯协议，我们也以分层的方式来理解，最基本的是把它分为物理层和协议层。物理层规定通讯系统中具有机械、电子功能部分的特性， 确保原始数据在物理媒体的传输。协议层主要规定通讯逻辑，统一收发双方的数据打包、解包标准。 简单来说物理层规定我们用嘴巴还是用肢体来交流，协议层则规定我们用中文还是英文来交流。

下面我们分别对串口通讯协议的物理层及协议层进行讲解。

### 21.1.1. 物理层

串口通讯的物理层有很多标准及变种，我们主要讲解RS-232标准 ，RS-232标准主要规定了信号的用途、通讯接口以及信号的电平标准。

使用RS-232标准的串口设备间常见的通讯结构见图 [串口通讯结构图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#id3) 。

![串口通讯结构图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART002.jpg)

在上面的通讯方式中，两个通讯设备的“DB9接口”之间通过串口信号线建立起连接，串口信号线中使用“RS-232标准”传输数据信号。 由于RS-232电平标准的信号不能直接被控制器直接识别，所以这些信号会经过一个“电平转换芯片”转换成控制器能识别的“TTL标准”的电平信号，才能实现通讯。

#### 21.1.1.1. 电平标准

根据通讯使用的电平标准不同，串口通讯可分为TTL标准及RS-232标准，见表 [TTL电平标准与RS232电平标准](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#ttlrs232) 。

![TTL电平标准与RS232电平标准](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART01.png)

我们知道常见的电子电路中常使用TTL的电平标准，理想状态下，使用5V表示二进制逻辑1，使用0V表示逻辑0； 而为了增加串口通讯的远距离传输及抗干扰能力，它使用-15V表示逻辑1，+15V表示逻辑0。 使用RS232与TTL电平校准表示同一个信号时的对比见图 [RS-232与TTL电平标准下表示同一个信号](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#rs-232ttl) 。

![RS-232与TTL电平标准下表示同一个信号](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART003.jpg)

因为控制器一般使用TTL电平标准，所以常常会使用MAX3232芯片对TTL及RS-232电平的信号进行互相转换。

#### 21.1.1.2. RS-232信号线

在最初的应用中，RS-232串口标准常用于计算机、路由与调制调解器(MODEN，俗称“猫”)之间的通讯 ，在这种通讯系统中， 设备被分为数据终端设备DTE(计算机、路由)和数据通讯设备DCE(调制调解器)。我们以这种通讯模型讲解它们的信号线连接方式及各个信号线的作用。

在旧式的台式计算机中一般会有RS-232标准的COM口(也称DB9接口)，见图 [电脑主板上的COM口及串口线](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#com) 。

![电脑主板上的COM口及串口线](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART004.jpg)

其中接线口以针式引出信号线的称为公头，以孔式引出信号线的称为母头。在计算机中一般引出公头接口，而在调制调解器设备中引出的一般为母头，使用上图中的串口线即可把它与计算机连接起来。通讯时，串口线中传输的信号就是使用前面讲解的RS-232标准调制的。

在这种应用场合下，DB9接口中的公头及母头的各个引脚的标准信号线接法见图 [DB9标准的公头及母头接法](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#db9) 及表 [DB9信号线说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#id5) 。

![DB9标准的公头及母头接法](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART005.jpg)![DB9信号线说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART02.png)

上表中的是计算机端的DB9公头标准接法，由于两个通讯设备之间的收发信号(RXD与TXD)应交叉相连， 所以调制调解器端的DB9母头的收发信号接法一般与公头的相反，两个设备之间连接时，只要使用“直通型”的串口线连接起来即可， 见图 [计算机与调制调解器的信号线连接](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#id6) 。

![计算机与调制调解器的信号线连接](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART006.jpg)

串口线中的RTS、CTS、DSR、DTR及DCD信号，使用逻辑 1表示信号有效，逻辑0表示信号无效。 例如，当计算机端控制DTR信号线表示为逻辑1时，它是为了告知远端的调制调解器，本机已准备好接收数据，0则表示还没准备就绪。

在目前的其它工业控制使用的串口通讯中，一般只使用RXD、TXD以及GND三条信号线， 直接传输数据信号，而RTS、CTS、DSR、DTR及DCD信号都被裁剪掉了。

### 21.1.2. 协议层

串口通讯的数据包由发送设备通过自身的TXD接口传输到接收设备的RXD接口。在串口通讯的协议层中， 规定了数据包的内容，它由启始位、主体数据、校验位以及停止位组成，通讯双方的数据包格式要约定一致才能正常收发数据， 其组成见图 [串口数据包的基本组成](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#id8) 。

![串口数据包的基本组成](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART007.jpg)

#### 21.1.2.1. 波特率
本章中主要讲解的是串口异步通讯，异步通讯中由于没有时钟信号(如前面讲解的DB9接口中是没有时钟信号的)， 所以两个通讯设备之间需要约定好波特率，即每个码元的长度，以便对信号进行解码， 图 [串口数据包的基本组成](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#id8) 中用虚线分开的每一格就是代表一个码元。常见的波特率为4800、9600、115200等。

#### 21.1.2.2. 通讯的起始和停止信号

串口通讯的一个数据包从起始信号开始，直到停止信号结束。数据包的起始信号由一个逻辑0的数据位表示， 而数据包的停止信号可由0.5、1、1.5或2个逻辑1的数据位表示，**只要双方约定一致即可**。

#### 21.1.2.3. 有效数据

在数据包的起始位之后紧接着的就是要传输的主体数据内容，也称为有效数据，有效数据的长度常被约定为5、6、7或8位长。

#### 21.1.2.4. 数据校验

在有效数据之后，有一个可选的数据校验位。由于数据通信相对更容易受到外部干扰导致传输数据出现偏差， 可以在传输过程加上校验位来解决这个问题。校验方法有奇校验(odd)、偶校验(even)、0校验(space)、1校验(mark)以及无校验(noparity)。

奇校验要求有效数据和校验位中“1”的个数为奇数，比如一个8位长的有效数据为：01101001，此时总共有4个“1”， 为达到奇校验效果，校验位为“1”，最后传输的数据将是8位的有效数据加上1位的校验位总共9位。

偶校验与奇校验要求刚好相反，要求帧数据和校验位中“1”的个数为偶数， 比如数据帧：11001010，此时数据帧“1”的个数为4个，所以偶校验位为“0”。

0校验是不管有效数据中的内容是什么，校验位总为“0”，1校验是校验位总为“1”。

## 21.2. STM32的USART简介

通用同步异步收发器(Universal Synchronous Asynchronous Receiver and Transmitter)是一个串行通信设备， 可以灵活地与外部设备进行全双工数据交换。 有别于USART还有一个UART(Universal Asynchronous Receiver and Transmitter)， 它是在USART基础上裁剪掉了同步通信功能，只有异步通信。 简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是UART。

串行通信一般是以帧格式传输数据，即是一帧一帧的传输，每帧包含有起始信号、数据信息、停止信息， 可能还有校验信息。USART就是对这些传输参数有具体规定，当然也不是只有唯一一个参数值，很多参数值都可以自定义设置，只是增强它的兼容性。

USART满足外部设备对工业标准NRZ异步串行数据格式的要求，并且使用了小数波特率发生器， 可以提供多种波特率，使得它的应用更加广泛。USART支持同步单向通信和半双工单线通信；还支持局域互连网络LIN、 智能卡(SmartCard)协议与lrDA(红外线数据协会) SIR ENDEC规范。

USART支持使用DMA，可实现高速数据通信，有关DMA具体应用将在DMA章节作具体讲解。

USART在STM32应用最多莫过于“打印”程序信息，一般在硬件设计时都会预留一个USART通信接口连接电脑， 用于在调试程序是可以把一些调试信息“打印”在电脑端的串口调试助手工具上，从而了解程序运行是否正确、如果出错哪具体哪里出错等等。

## 21.3. USART功能框图

USART的功能框图包含了USART最核心内容，掌握了功能框图，对USART就有一个整体的把握， 在编程时就思路就非常清晰。USART功能框图见图 [USART功能框图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#id14) 。

![USART功能框图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART008.png)

**功能引脚**

TX： 发送数据输出引脚。

RX： 接收数据输入引脚。

SW_RX： 数据接收引脚，只用于单线和智能卡模式，属于内部引脚，没有具体外部引脚。

nRTS： 请求以发送(Request To Send)，n表示低电平有效。如果使能RTS流控制，当USART接收器准备好接收新数据时就会将nRTS变成低电平； 当接收寄存器已满时，nRTS将被设置为高电平。该引脚只适用于硬件流控制。

nCTS： 清除以发送(Clear To Send)，n表示低电平有效。如果使能CTS流控制，发送器在发送下一帧数据之前会检测nCTS引脚， 如果为低电平，表示可以发送数据，如果为高电平则在发送完当前数据帧之后停止发送。该引脚只适用于硬件流控制。

SCLK： 发送器时钟输出引脚。这个引脚仅适用于同步模式。

USART引脚在STM32F103VET6芯片具体分布见表 [STM32F103VET6芯片的USART引脚](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#stm32f103vet6usart) 。

![STM32F103VET6芯片的USART引脚](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART03.png)

STM32F103VET6系统控制器有三个USART和两个UART，其中USART1和时钟来源于APB2总线时钟，其最大频率为72MHz， 其他四个的时钟来源于APB1总线时钟，其最大频率为36MHz。UART只是异步传输功能，所以没有SCLK、nCTS和nRTS功能引脚。
![USART功能框图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART008.png)


- **数据寄存器**

USART数据寄存器(USART_DR)只有低9位有效，并且第9位数据是否有效要取决于USART控制寄存器1(USART_CR1)的M位设置， 当M位为0时表示8位数据字长，当M位为1表示9位数据字长，我们一般使用8位数据字长。

>**注意**：完整的一个USART通讯字节包括1bit 起始位、８bit数据位（1bit校验位）、1bit停止位总共11位（9bit数据帧：8bit数据位+1bit校验位），如果不开校验位那一共就10位
（8bit 数据帧）
USART_DR包含了已发送的数据或者接收到的数据。
**USART_DR实际是包含了两个寄存器，一个专门用于发送的可写TDR， 一个专门用于接收的可读RDR**。

**当进行发送操作时，往USART_DR写入数据会自动存储在TDR内；当进行读取操作时，向USART_DR读取数据会自动提取RDR数据。**

TDR和RDR都是介于系统总线和移位寄存器之间。串行通信是一个位一个位传输的，**发送时把TDR内容转移到发送移位寄存器， 然后把移位寄存器数据每一位发送出去，接收时把接收到的每一位顺序保存在接收移位寄存器内然后才转移到RDR**。

USART支持DMA传输，可以实现高速数据传输，具体DMA使用将在DMA章节讲解。










**控制器**

USART有专门控制发送的发送器、控制接收的接收器，还有唤醒单元、中断控制等等。 使用USART之前需要向USART_CR1寄存器的UE位置1使能USART，UE位用来开启供给给串口的时钟。

发送或者接收数据字长可选8位或9位，由USART_CR1的M位控制。






**发送器**

当USART_CR1寄存器的发送使能位TE置1时，启动数据发送，发送移位寄存器的数据会在TX引脚输出， 低位在前，高位在后。如果是同步模式SCLK也输出时钟信号。

一个字符帧发送需要三个部分：**起始位+数据帧+停止位**。起始位是一个位周期的低电平，位周期就是每一位占用的时间； 数据帧就是我们要发送的8位或9位数据，数据是从最低位开始传输的；停止位是一定时间周期的高电平。

停止位时间长短是可以通过USART控制寄存器2(USART_CR2)的STOP[1:0]位控制，可选0.5个、1个、1.5个和2个停止位。 默认使用1个停止位。2个停止位适用于正常USART模式、单线模式和调制解调器模式。0.5个和1.5个停止位用于智能卡模式。

当选择8位字长，使用1个停止位时，具体发送字符时序图见图 [字符发送时序图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#id15) 。

![字符发送时序图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART009.png)

当发送使能位TE置1之后，发送器开始会先发送一个空闲帧(一个数据帧长度的高电平)，接下来就可以往USART_DR寄存器写入要发送的数据。 在写入最后一个数据后，需要等待USART状态寄存器(USART_SR)的TC位为1，表示数据传输完成，如果USART_CR1寄存器的TCIE位置1，将产生中断。

在发送数据时，编程的时候有几个比较重要的标志位我们来总结下。

![](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART04.png)









**接收器**

如果将USART_CR1寄存器的RE位置1，使能USART接收，使得接收器在RX线开始搜索起始位。 在确定到起始位后就根据RX线电平状态把数据存放在接收移位寄存器内。接收完成后就把接收移位寄存器数据移到RDR内， 并把USART_SR寄存器的RXNE位置1，同时如果USART_CR2寄存器的RXNEIE置1的话可以产生中断。

在接收数据时，编程的时候有几个比较重要的标志位我们来总结下。

|   |   |
|---|---|
|名称|描述|
|RE|接收使能|
|RXNE|读数据寄存器非空|
|RXNEIE|接收完成中断使能|

**小数波特率生成**

波特率指数据信号对载波的调制速率，它用单位时间内载波调制状态改变次数来表示，单位为波特。 比特率指单位时间内传输的比特数，单位bit/s(bps)。对于USART波特率与比特率相等，以后不区分这两个概念。波特率越大，传输速率越快。

USART的发送器和接收器使用相同的波特率。计算公式如下：

![波特率计算](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART010.png)

其中，$f_{PLCK}$为USART时钟， $USARTDIV$是一个存放在波特率寄存器(USART_BRR)的一个无符号定点数。 其中$DIV_{Mantissa}[11:0]$位定义USARTDIV的整数部分，$DIV_{Fraction}[3:0]$位定义USARTDIV的小数部分。

例如：DIV_Mantissa=24(0x18)，DIV_Fraction=10(0x0A)，此时USART_BRR值为0x18A； 那么USARTDIV的小数位10/16=0.625；整数位24，最终USARTDIV的值为24.625。

如果知道USARTDIV值为27.68，那么DIV_Fraction=16*0.68=10.88，最接近的正整数为11， 所以DIV_Fraction[3:0]为0xB；DIV_Mantissa=整数(27.68)=27，即为0x1B。

波特率的常用值有2400、9600、19200、115200。下面以实例讲解如何设定寄存器值得到波特率的值。

我们知道USART1使用APB2总线时钟，最高可达72MHz，其他USART的最高频率为36MHz。 我们选取USART1作为实例讲解，即$f_{PLCK}=72MHz$。为得到115200bps的波特率，此时：
$$
115200=7200000016∗USARTDIV115200=7200000016∗USARTDIV$$

解得$USARTDIV=39.0625$，可算得$DIV_{Fraction}=0.0625*16=1=0x01$，$DIV_{Mantissa}=39=0x27$，即应该设置USART_BRR的值为0x271。

### 21.3.1. 校验控制

STM32F103系列控制器USART支持奇偶校验。当使用校验位时，串口传输的长度将是8位的数据帧加上1位的校验位总共9位， 此时USART_CR1寄存器的M位需要设置为1，即9数据位。将USART_CR1寄存器的PCE位置1就可以启动奇偶校验控制， 奇偶校验由硬件自动完成。启动了奇偶校验控制之后，在发送数据帧时会自动添加校验位，接收数据时自动验证校验位。 接收数据时如果出现奇偶校验位验证失败，会见USART_SR寄存器的PE位置1，并可以产生奇偶校验中断。

使能了奇偶校验控制后，每个字符帧的格式将变成：起始位+数据帧+校验位+停止位。

### 21.3.2. 中断控制

USART有多个中断请求事件，具体见表 [USART中断请求](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#id20) 。

![USART中断请求](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART06.png)

## 21.4. USART初始化结构体详解

标准库函数对每个外设都建立了一个初始化结构体，比如USART_InitTypeDef，结构体成员用于设置外设工作参数， 并由外设初始化配置函数，比如USART_Init()调用，这些设定参数将会设置外设相应的寄存器，达到配置外设工作环境的目的。

初始化结构体和初始化库函数配合使用是标准库精髓所在，理解了初始化结构体每个成员意义基本上就可以对该外设运用自如了。 初始化结构体定义在stm32f10x_usart.h文件中，初始化库函数定义在stm32f10x_usart.c文件中，编程时我们可以结合这两个文件内注释使用。

**USART初始化结构体**

```c
typedef struct {
    uint32_t USART_BaudRate;            // 波特率
    uint16_t USART_WordLength;          // 字长
    uint16_t USART_StopBits;            // 停止位
    uint16_t USART_Parity;              // 校验位
    uint16_t USART_Mode;                // USART模式
    uint16_t USART_HardwareFlowControl; // 硬件流控制
} USART_InitTypeDef;
```

1) USART_BaudRate： 波特率设置。一般设置为2400、9600、19200、115200。标准库函数会根据设定值计算得到USARTDIV值，从而设置USART_BRR寄存器值。

2) USART_WordLength： 数据帧字长，可选8位或9位。它设定USART_CR1寄存器的M位的值。如果没有使能奇偶校验控制，一般使用8数据位；如果使能了奇偶校验则一般设置为9数据位。

3) USART_StopBits： 停止位设置，可选0.5个、1个、1.5个和2个停止位，它设定USART_CR2寄存器的STOP[1:0]位的值，一般我们选择1个停止位。

4) USART_Parity： 奇偶校验控制选择，可选USART_Parity_No(无校验)、USART_Parity_Even(偶校验)以及USART_Parity_Odd(奇校验)，它设定USART_CR1寄存器的PCE位和PS位的值。

5) USART_Mode： USART模式选择，有USART_Mode_Rx和USART_Mode_Tx，允许使用逻辑或运算选择两个，它设定USART_CR1寄存器的RE位和TE位。

6) USART_HardwareFlowControl： 硬件流控制选择，只有在硬件流控制模式才有效，可选有使能RTS、使能CTS、同时使能RTS和CTS、不使能硬件流。

当使用同步模式时需要配置SCLK引脚输出脉冲的属性，标准库使用一个时钟初始化结构体USART_ClockInitTypeDef来设置，该结构体内容也只有在同步模式才需要设置。

**USART时钟初始化结构体**

```c
typedef struct {
    uint16_t USART_Clock;    // 时钟使能控制
    uint16_t USART_CPOL;     // 时钟极性
    uint16_t USART_CPHA;     // 时钟相位
    uint16_t USART_LastBit;  // 最尾位时钟脉冲
} USART_ClockInitTypeDef;
```

1) USART_Clock： 同步模式下SCLK引脚上时钟输出使能控制，可选禁止时钟输出(USART_Clock_Disable)或开启时钟输出(USART_Clock_Enable)；如果使用同步模式发送，一般都需要开启时钟。它设定USART_CR2寄存器的CLKEN位的值。

2) USART_CPOL： 同步模式下SCLK引脚上输出时钟极性设置，可设置在空闲时SCLK引脚为低电平(USART_CPOL_Low)或高电平(USART_CPOL_High)。它设定USART_CR2寄存器的CPOL位的值。

3) USART_CPHA： 同步模式下SCLK引脚上输出时钟相位设置，可设置在时钟第一个变化沿捕获数据(USART_CPHA_1Edge)或在时钟第二个变化沿捕获数据。它设定USART_CR2寄存器的CPHA位的值。USART_CPHA与USART_CPOL配合使用可以获得多种模式时钟关系。

4) USART_LastBit： 选择在发送最后一个数据位的时候时钟脉冲是否在SCLK引脚输出，可以是不输出脉冲(USART_LastBit_Disable)、输出脉冲(USART_LastBit_Enable)。它设定USART_CR2寄存器的LBCL位的值。

## 21.5. USART1接发通信实验

USART只需两根信号线即可完成双向通信，对硬件要求低，使得很多模块都预留USART接口来实现与其他模块或者控制器进行数据传输， 比如GSM模块，WIFI模块、蓝牙模块等等。在硬件设计时，注意还需要一根“共地线”。

我们经常使用USART来实现控制器与电脑之间的数据传输。这使得我们调试程序非常方便，比如我们可以把一些变量的值、函数的返回值、 寄存器标志位等等通过USART发送到串口调试助手，这样我们可以非常清楚程序的运行状态，当我们正式发布程序时再把这些调试信息去除即可。

我们不仅仅可以将数据发送到串口调试助手，我们还可以在串口调试助手发送数据给控制器，控制器程序根据接收到的数据进行下一步工作。

首先，我们来编写一个程序实现开发板与电脑通信，在开发板上电时通过USART发送一串字符串给电脑，然后开发板进入中断接收等待状态， 如果电脑有发送数据过来，开发板就会产生中断，我们在中断服务函数接收数据，并马上把数据返回发送给电脑。

### 21.5.1. 硬件设计

为利用USART实现开发板与电脑通信，需要用到一个USB转USART的IC，我们选择CH340G芯片来实现这个功能，CH340G是一个USB总线的转接芯片， 实现USB转USART、USB转lrDA红外或者USB转打印机接口，我们使用其USB转USART功能。具体电路设计见图 [USB转串口硬件设计](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#usb) 。

我们将CH340G的TXD引脚与USART1的RX引脚连接，CH340G的RXD引脚与USART1的TX引脚连接。CH340G芯片集成在开发板上，其地线(GND)已与控制器的GND连通。

![USB转串口硬件设计](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART011.png)

### 21.5.2. 软件设计

这里只讲解核心的部分代码，有些变量的设置，头文件的包含等并没有涉及到，完整的代码请参考本章配套的工程。 我们创建了两个文件：bsp_usart.c和bsp _usart.h文件用来存放USART驱动程序及相关宏定义。

#### 21.5.2.1. 编程要点

1. 使能RX和TX引脚GPIO时钟和USART时钟；
    
2. 初始化GPIO，并将GPIO复用到USART上；
    
3. 配置USART参数；
    
4. 配置中断控制器并使能USART接收中断；
    
5. 使能USART；
    
6. 在USART接收中断服务函数实现数据接收和发送。
    

#### 21.5.2.2. 代码分析

**GPIO和USART宏定义**

代码清单:USART-1 GPIO和USART宏定义[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#usart-1 "永久链接至代码")

```c
/**
* 串口宏定义，不同的串口挂载的总线和IO不一样，移植时需要修改这几个宏
*/

// 串口1-USART1
#define  DEBUG_USARTx                   USART1
#define  DEBUG_USART_CLK                RCC_APB2Periph_USART1
#define  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd
#define  DEBUG_USART_BAUDRATE           115200

// USART GPIO 引脚宏定义
#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)
#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd

#define  DEBUG_USART_TX_GPIO_PORT       GPIOA
#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9
#define  DEBUG_USART_RX_GPIO_PORT       GPIOA
#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10

#define  DEBUG_USART_IRQ                USART1_IRQn
#define  DEBUG_USART_IRQHandler         USART1_IRQHandler
```
使用宏定义方便程序移植和升级 。开发板中的CH340G的收发引脚默认通过跳帽连接到USART1，如果想使用其他串口， 可以把CH340G跟USART1直接的连接跳帽拔掉，然后再把其他串口的IO用杜邦线接到CH340G的收发引脚即可。

这里我们使用USART1，设定波特率为115200，选定USART的GPIO为PA9和PA10。

**嵌套向量中断控制器NVIC配置**

代码清单:USART-2 中断控制器NVIC配置[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#usart-2 "永久链接至代码")

```c
static void NVIC_Configuration(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;

    /* 嵌套向量中断控制器组选择 */
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);

    /* 配置USART为中断源 */
    NVIC_InitStructure.NVIC_IRQChannel = DEBUG_USART_IRQ;
    /* 抢断优先级为1 */
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    /* 子优先级为1 */
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    /* 使能中断 */
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    /* 初始化配置NVIC */
    NVIC_Init(&NVIC_InitStructure);
}
```
在中断章节已对嵌套向量中断控制器的工作机制做了详细的讲解，这里我们就直接使用，配置USART作为中断源，因为本实验没有使用其他中断，对优先级没什么具体要求。

**USART初始化配置**

代码清单:USART-3 USART初始化配置[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#usart-3 "永久链接至代码")

```c
void USART_Config(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;

    // 打开串口GPIO的时钟
    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);

    // 打开串口外设的时钟
    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);

    // 将USART Tx的GPIO配置为推挽复用模式
    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);

    // 将USART Rx的GPIO配置为浮空输入模式
    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);

    // 配置串口的工作参数
    // 配置波特率
    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;
    // 配置 针数据字长
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    // 配置停止位
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    // 配置校验位
    USART_InitStructure.USART_Parity = USART_Parity_No ;
    // 配置硬件流控制
    USART_InitStructure.USART_HardwareFlowControl =
        USART_HardwareFlowControl_None;
    // 配置工作模式，收发一起
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    // 完成串口的初始化配置
    USART_Init(DEBUG_USARTx, &USART_InitStructure);

    // 串口中断优先级配置
    NVIC_Configuration();

    // 使能串口接收中断
    USART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, ENABLE);

    // 使能串口
    USART_Cmd(DEBUG_USARTx, ENABLE);
}
```
使用GPIO_InitTypeDef和USART_InitTypeDef结构体定义一个GPIO初始化变量以及一个USART初始化变量，这两个结构体内容我们之前已经有详细讲解。

调用RCC_APB2PeriphClockCmd函数开启GPIO端口时钟，**使用GPIO之前必须开启对应端口的时钟**。**使用RCC_APB2PeriphClockCmd函数开启USART时钟**。

**使用GPIO之前都需要初始化配置它，并且还要添加特殊设置**，因为我们使用它作为外设的引脚，一般都有特殊功能。 我们在初始化时需要把它的模式设置为复用功能。这里把串口的Tx引脚配置为复用推挽输出，Rx引脚为浮空输入，数据完全由外部输入决定。

接下来，我们配置USART1通信参数为：波特率115200，字长为8，1个停止位，没有校验位，不使用硬件流控制，收发一体工作模式，然后调用USART初始化函数完成配置。

程序用到USART接收中断，需要配置NVIC，这里调用NVIC_Configuration函数完成配置。配置完NVIC之后调用USART_ITConfig函数使能USART接收中断。

最后调用USART_Cmd函数使能USART，这个函数最终配置的是USART_CR1的UE位，具体的作用是开启USART的工作时钟，没有时钟那USART这个外设自然就工作不了。

**字符发送**

代码清单:USART-4 字符发送函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#usart-4 "永久链接至代码")

```c
/*****************  发送一个字符 **********************/
void Usart_SendByte( USART_TypeDef * pUSARTx, uint8_t ch)
{
    /* 发送一个字节数据到USART */
    USART_SendData(pUSARTx,ch);

    /* 等待发送数据寄存器为空 */
    while (USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) == RESET);
}

/*****************  发送字符串 **********************/
void Usart_SendString( USART_TypeDef * pUSARTx, char *str)
{
    unsigned int k=0;
    do {
        Usart_SendByte( pUSARTx, *(str + k) );
        k++;
    } while (*(str + k)!='\0');

    /* 等待发送完成 */
    while (USART_GetFlagStatus(pUSARTx,USART_FLAG_TC)==RESET) {
    }
}
```
Usart_SendByte函数用来在指定USART发送一个ASCLL码值字符，它有两个形参，第一个为USART，第二个为待发送的字符。 它是通过调用库函数USART_SendData来实现的，并且增加了等待发送完成功能。 通过使用USART_GetFlagStatus函数来获取USART事件标志来实现发送完成功能等待，它接收两个参数，一个是USART， 一个是事件标志。这里我们循环检测发送数据寄存器为空这个标志，当跳出while循环时说明发送数据寄存器为空这个事实。

Usart_SendString函数用来发送一个字符串，它实际是调用Usart_SendByte函数发送每个字符，直到遇到空字符才停止发送。 最后使用循环检测发送完成的事件标志TC来实现保证数据发送完成后才退出函数。

**USART中断服务函数**

代码清单:USART-5 USART中断服务函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#usart-5 "永久链接至代码")

```c
void DEBUG_USART_IRQHandler(void)
{
    uint8_t ucTemp;
    if (USART_GetITStatus(DEBUG_USARTx,USART_IT_RXNE)!=RESET) {
        ucTemp = USART_ReceiveData( DEBUG_USARTx );
        USART_SendData(DEBUG_USARTx,ucTemp);
    }

}
```
这段代码是存放在stm32f10x_it.c文件中的，该文件用来集中存放外设中断服务函数。当我们使能了中断并且中断发生时就会执行这里的中断服务函数。

我们在代码清单:USART-3使能了USART接收中断，当USART有接收到数据就会执行USART_IRQHandler函数。 USART_GetITStatus函数与USART_GetFlagStatus函数类似用来获取标志位状态，但USART_GetITStatus函数是专门用来获取中断事件标志的， 并返回该标志位状态。使用if语句来判断是否是真的产生USART数据接收这个中断事件， 如果是真的就使用USART数据读取函数USART_ReceiveData读取数据到指定存储区。 然后再调用USART数据发送函数USART_SendData把数据又发送给源设备，即PC端的串口调试助手。

**主函数**

代码清单:USART-6 主函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#usart-6 "永久链接至代码")

```c
int main(void)
{
    /*初始化USART 配置模式为 115200 8-N-1，中断接收*/
    USART_Config();

    Usart_SendString( DEBUG_USARTx,"这是一个串口中断接收回显实验\n");

    while (1) {

    }
}
```
首先我们需要调用USART_Config函数完成USART初始化配置，包括GPIO配置，USART配置，接收中断使能等等信息。

接下来就可以调用字符发送函数把数据发送给串口调试助手了。

最后主函数什么都不做，只是静静地等待USART接收中断的产生，并在中断服务函数把数据回传。

### 21.5.3. 下载验证

保证开发板相关硬件连接正确，用USB线连接开发板的USB转串口跟电脑，在电脑端打开串口调试助手并配置好相关参数：115200 8-N-1，把编译好的程序下载到开发板，此时串口调试助手即可收到开发板发过来的数据。我们在串口调试助手发送区域输入任意字符， 点击发送按钮，马上在串口调试助手接收区即可看到相同的字符。

![实验现象](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/USART012.png)

## 21.6. USART1指令控制RGB彩灯实验
在学习C语言时我们经常使用C语言标准函数库输入输出函数，比如printf、scanf、getchar等等。 为让开发板也支持这些函数需要把USART发送和接收函数添加到这些函数的内部函数内。

正如之前所讲，可以在串口调试助手输入指令，让开发板根据这些指令执行一些任务， 现在我们编写程序让开发板接收USART数据，然后根据数据内容控制RGB彩灯的颜色。

### 21.6.1. 硬件设计

硬件设计同第一个实验。

### 21.6.2. 软件设计

这里只讲解核心的部分代码，有些变量的设置，头文件的包含等并没有涉及到，完整的代码请参考本章配套的工程。 我们创建了两个文件：bsp _usart.c和bsp _usart.h文件用来存放USART驱动程序及相关宏定义。

#### 21.6.2.1. 编程要点

1. 初始化配置RGB彩色灯GPIO；
    
2. 使能RX和TX引脚GPIO时钟和USART时钟；
    
3. 初始化GPIO，并将GPIO复用到USART上；
    
4. 配置USART参数；
    
5. 使能USART；
    
6. 获取指令输入，根据指令控制RGB彩色灯。
    

与上一个实验不同的是我们这里不使用接收中断，而是靠查询标志位的方式来实现接收。

#### 21.6.2.2. 代码分析

**GPIO和USART宏定义**

代码清单:USART-7 GPIO和USART宏定义[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#usart-7 "永久链接至代码")

```c
#define  DEBUG_USARTx                   USART1
#define  DEBUG_USART_CLK                RCC_APB2Periph_USART1
#define  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd
#define  DEBUG_USART_BAUDRATE           115200

// USART GPIO 引脚宏定义
#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)
#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd

#define  DEBUG_USART_TX_GPIO_PORT       GPIOA
#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9
#define  DEBUG_USART_RX_GPIO_PORT       GPIOA
#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10

#define  DEBUG_USART_IRQ                USART1_IRQn
#define  DEBUG_USART_IRQHandler         USART1_IRQHandler
```
使用宏定义方便程序移植和升级，这里我们可以USART1，设定波特率为115200。

**USART初始化配置**

代码清单:USART-8 USART初始化配置[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#usart-8 "永久链接至代码")

```c
void USART_Config(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;

    // 打开串口GPIO的时钟
    DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);

    // 打开串口外设的时钟
    DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);

    // 将USART Tx的GPIO配置为推挽复用模式
    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);

    // 将USART Rx的GPIO配置为浮空输入模式
    GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);

    // 配置串口的工作参数
    // 配置波特率
    USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;
    // 配置 针数据字长
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    // 配置停止位
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    // 配置校验位
    USART_InitStructure.USART_Parity = USART_Parity_No ;
    // 配置硬件流控制
    USART_InitStructure.USART_HardwareFlowControl =
        USART_HardwareFlowControl_None;
    // 配置工作模式，收发一起
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    // 完成串口的初始化配置
    USART_Init(DEBUG_USARTx, &USART_InitStructure);

    // 使能串口
    USART_Cmd(DEBUG_USARTx, ENABLE);
}
```
该配置函数跟上一个实验的基本一样，不一样的地方是没有使用接收中断。

**重定向prinft和scanf函数**

代码清单:USART-9 重定向输入输出函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#usart-9 "永久链接至代码")

```c
///重定向c库函数printf到串口，重定向后可使用printf函数
int fputc(int ch, FILE *f)
{
    /* 发送一个字节数据到串口 */
    USART_SendData(DEBUG_USARTx, (uint8_t) ch);

    /* 等待发送完毕 */
    while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET);

    return (ch);
}

///重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数
int fgetc(FILE *f)
{
    /* 等待串口输入数据 */
    while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) == RESET);

    return (int)USART_ReceiveData(DEBUG_USARTx);
}
```
在C语言标准库中，fputc函数是printf函数内部的一个函数，功能是将字符ch写入到文件指针f所指向文件的当前写指针位置， 简单理解就是把字符写入到特定文件中。我们使用USART函数重新修改fputc函数内容，达到类似“写入”的功能。

fgetc函数与fputc函数非常相似，实现字符读取功能。在使用scanf函数时需要注意字符输入格式。

还有一点需要注意的，使用fput和fgetc函数达到重定向C语言标准库输入输出函数必须在MDK的工程选项把“Use MicroLIB”勾选上， MicoroLIB是缺省C库的备选库，它对标准C库进行了高度优化使代码更少，占用更少资源。

为使用printf、scanf函数需要在文件中包含stdio.h头文件。

**输出提示信息**

代码清单:USART-10 输出提示信息[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#usart-10 "永久链接至代码")

```c
static void Show_Message(void)
{
    printf("\r\n   这是一个通过串口通信指令控制RGB彩灯实验 \n");
    printf("使用  USART  参数为：%d 8-N-1 \n",USART_BAUDRATE);
    printf("开发板接到指令后控制RGB彩灯颜色，指令对应如下：\n");
    printf("   指令   ------ 彩灯颜色 \n");
    printf("     1    ------    红 \n");
    printf("     2    ------    绿 \n");
    printf("     3    ------    蓝 \n");
    printf("     4    ------    黄 \n");
    printf("     5    ------    紫 \n");
    printf("     6    ------    青 \n");
    printf("     7    ------    白 \n");
    printf("     8    ------    灭 \n");
}
```
Show_Message函数全部是调用printf函数，“打印”实验操作信息到串口调试助手。

**主函数**

代码清单:USART-11 主函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/USART.html#usart-11 "永久链接至代码")

```c
int main(void)
{
    char ch;

    /* 初始化RGB彩灯 */
    LED_GPIO_Config();

    /* 初始化USART 配置模式为 115200 8-N-1 */
    USART_Config();

    /* 打印指令输入提示信息 */
    Show_Message();
    while (1)
    {
        /* 获取字符指令 */
        ch=getchar();
        printf("接收到字符：%c\n",ch);

        /* 根据字符指令控制RGB彩灯颜色 */
        switch (ch)
        {
        case '1':
            LED_RED;
            break;
        case '2':
            LED_GREEN;
            break;
        case '3':
            LED_BLUE;
            break;
        case '4':
            LED_YELLOW;
            break;
        case '5':
            LED_PURPLE;
            break;
        case '6':
            LED_CYAN;
            break;
        case '7':
            LED_WHITE;
            break;
        case '8':
            LED_RGBOFF;
            break;
        default:
            /* 如果不是指定指令字符，打印提示信息 */
            Show_Message();
            break;
        }
    }
}
```
首先我们定义一个字符变量来存放接收到的字符。

接下来调用LED_GPIO_Config函数完成RGB彩色GPIO初始化配置，该函数定义在bsp_led.c文件内。

调用USART_Config函完成USART初始化配置。

Show_Message函数使用printf函数打印实验指令说明信息。

getchar函数用于等待获取一个字符，并返回字符。我们使用ch变量保持返回的字符，接下来判断ch内容执行对应的程序。

我们使用switch语句判断ch变量内容，并执行对应的功能程序。

### 21.6.3. 下载验证
保证开发板相关硬件连接正确，用USB线连接开发板“USB TO UART”接口跟电脑，在电脑端打开串口调试助手， 把编译好的程序下载到开发板，此时串口调试助手即可收到开发板发过来的数据。 我们在串口调试助手发送区域输入一个特定字符，点击发送按钮，RGB彩色灯状态随之改变。

## 21.7 USART1指令读取NFC模块实验





## 21.8. 补充说明

对于STM32芯片，各个引脚可以做什么外设功能或者电气特性参数在 **数据手册** 查阅，引脚和外设的功能特性和对应寄存器的使用在 **参考手册** 查阅。

以下对于F103芯片，当根据数据手册确定要使用某个引脚做某个外设功能时，在参考手册如下查阅外设的GPIO应该如何配置，当对各种配置不了解时以能在手册查阅出的结果为准。

![usart_supplement_1](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/usart_supplement_1.png)

---

关于串口中断的使用，以串口1举例，在参考手册、库内定义和启动文件等可以看出 串口1使用 USART1_IRQn 一个中断源，使用 USART1_IRQHandler 一个中断函数，回顾EXIT章节的补充说明有类似意思， 对于串口1这里，如果使能了多个标志位的中断，它们会在各自的时序流程触发中断，因此在中断函数里面用多个GetITStatus函数判断标志并来做此标志的流程操作，查阅手册中的寄存器描述了解各标志位的时序和如何清除标志位等， 某些标志位优先以手册中有描述的软件清除流程而可以不使用ClearFlag函数。

![usart_supplement_2](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/usart_supplement_2.png)

---

上面例程只使用了接收非空中断，可以参考补充例程内的接收非空中断加空闲中断的使用， 除此之外还有其他也能够使能中断的标志位，但不需要都用到，当加更多标志位中断时会让中断流程和主流程的逻辑配合变更复杂。

以上补充总结对之后的外设学习也是同样道理，注意对于GPIO配置和外设在不同系列芯片会存在差异，重点在于掌握整体概念，学会在不同芯片的手册中查阅对应内容。

## 21.9. 使用总结

- USART使用要点
	- 一般发送USART数据不使用中断编程的方式
	

- USART与外设通信的关系
	USART对于外设通信的要点在准备通信前置步骤基本上都是一样的，关键点在于中断函数的实现中对于缓冲寄存器中数据的处理方式上有区别。


- 迁移外设驱动
	迁移USART外设驱动的第一步首先看其是如何初始化通信端口的，把这些初始化函数块迁移，然后看其是如何利用这些通信端口的

- 接收一帧多字节USART包策略
	接收一帧多个字节流时候可以使用延时，保证接收完所有字节后才完全退出中断，而不是上一个字节的中断没有完全退出又被下一个字节引起新的中断,因为一个字节仅能够引起一次中断

```c
void USART1_IRQHandler(void)

{

  static u8 bTemp;   //接收缓存

  if(USART_GetITStatus(USART1, USART_IT_RXNE) == SET)  // 如果USART1的接收中断标识被设置则处理接收数据

  {

    bTemp = USART_ReceiveData(USART1);                 // 按字读USART1的接收数据

    if(Cmd.ReceivePoint < 32)                          // 如果接收缓存没有满

    {

      Cmd.ReceiveBuffer[Cmd.ReceivePoint++] = bTemp;   // 缓存接收数据

    }

  }

  USART_ClearITPendingBit(USART1, USART_IT_RXNE);     // 清除USART1的接收中断标志

  Delay(1);                                           //Notice:接收一帧多字节数据时候使用延时可以保证接受完一帧数据后才完全退出中断，但是不能太长

}



```

开启中断的 USART 和不开启中断的 USART 在配置步骤上的区别主要体现在**中断配置**和**数据收发方式**上。

---
### 21.9.1 轮询与中断USART
#### **1. 不开启中断的 USART（轮询方式）**

不使用中断时，数据收发通过轮询 USART 状态标志位（如 `TXE` 和 `RXNE`）来完成。  
配置步骤如下：

1. **开启时钟**：为 USART 和 GPIO 使能时钟。
2. **配置 GPIO**：配置 TX 引脚为复用推挽输出，RX 引脚为浮空输入。
3. **配置 USART**：初始化波特率、数据位、停止位、校验位等参数。
4. **使能 USART**：通过 `USART_Cmd()` 使能 USART。
5. **数据收发**：通过轮询 `USART_FLAG_TXE` 和 `USART_FLAG_RXNE` 标志位进行发送和接收。

 **示例代码（轮询方式）**

```c
void USART_Config(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;

    // 1. 开启 USART 和 GPIO 时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);

    // 2. 配置 GPIO
    // TX: PA9
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    // RX: PA10
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    // 3. USART 配置
    USART_InitStructure.USART_BaudRate = 9600;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
    USART_Init(USART1, &USART_InitStructure);

    // 4. 使能 USART
    USART_Cmd(USART1, ENABLE);
}

void USART_SendData_Polling(uint8_t data)
{
    while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);  // 等待 TXE 标志置位
    USART_SendData(USART1, data);  // 发送数据
}

uint8_t USART_ReceiveData_Polling(void)
{
    while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);  // 等待 RXNE 标志置位
    return USART_ReceiveData(USART1);  // 读取接收数据
}
```

---

#### **2. 开启中断的 USART**

开启中断时，数据收发通过 **中断服务函数 (ISR)** 处理，不需要轮询状态标志位。  
配置步骤如下：

1. **开启时钟**：为 USART 和 GPIO 使能时钟。
2. **配置 GPIO**：配置 TX 引脚为复用推挽输出，RX 引脚为浮空输入。
3. **配置 USART**：初始化波特率、数据位、停止位、校验位等参数。
4. **使能中断**：
    - 通过 `USART_ITConfig()` 使能需要的中断（如接收中断 `USART_IT_RXNE`）。
    - 配置 NVIC，将 USART 中断向量加入中断控制器。
5. **使能 USART**：通过 `USART_Cmd()` 使能 USART。
6. **中断处理**：编写中断服务函数 (`USARTx_IRQHandler`)，在中断中处理数据收发。

 **示例代码（中断方式）**

```c
void USART_Config(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;

    // 1. 开启 USART 和 GPIO 时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);

    // 2. 配置 GPIO(引脚配置模式手册可查)
    // TX: PA9
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    // RX: PA10
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    // 3. USART 配置
    USART_InitStructure.USART_BaudRate = 9600;//波特率
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
    USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
    USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
    USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;//收发模式
    USART_Init(USART1, &USART_InitStructure);

    // 4. 使能 USART 接收中断
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);

    // 5. NVIC 配置
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;// 触发该USART1中断的处理函数名
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;//抢占优先级3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;//子优先级3
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//IRQ通道使能
    NVIC_Init(&NVIC_InitStructure);

    // 6. 使能 USART
    USART_Cmd(USART1, ENABLE);
}

void USART1_IRQHandler(void)
{
    if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  // 接收中断
    {
        uint8_t data = USART_ReceiveData(USART1);  // 读取接收数据
        // 处理数据，例如存入缓冲区
        USART_SendData(USART1, data);  // 回显接收到的数据
    }
}
```

---

**配置步骤差异总结**

|**步骤**|**不开启中断**（轮询方式）|**开启中断**|
|---|---|---|
|**时钟配置**|使能 USART 和 GPIO 时钟|使能 USART 和 GPIO 时钟|
|**GPIO 配置**|配置 TX 和 RX 引脚|配置 TX 和 RX 引脚|
|**USART 配置**|初始化波特率、数据位等参数|初始化波特率、数据位等参数|
|**中断配置**|**不需要**|使能中断 `USART_IT_RXNE` 和 NVIC 配置|
|**数据收发**|轮询 `TXE` 和 `RXNE` 标志位|在中断服务函数中处理数据|
|**代码复杂度**|较简单|略复杂，需要编写中断函数|
|**实时性**|较差，CPU 被轮询占用|较好，CPU 可执行其他任务|

---

 **选择依据**

1. **轮询方式**：简单、易实现，适用于数据量小、不需要实时响应的场合，常用于发送USART。
2. **中断方式**：效率高，适用于数据量较大、实时性要求高的场合，CPU 资源得到合理利用，常用于接收USART。

实际应用中，如果你的系统需要处理其他任务，同时要保持串口收发的实时性，推荐使用**中断方式**。
# 22. DMA—直接存储区访问

本章参考资料：《STM32F10X-中文参考手册》DMA控制器章节。

学习本章时，配合《STM32F10X-中文参考手册》DMA控制器章节一起阅读，效果会更佳，特别是涉及到寄存器说明的部分。

## 22.1. DMA简介

DMA(Direct Memory Access)—直接存储器存取，是单片机的一个外设，它的主要功能是用来搬数据，但是不需要占用CPU， 即在传输数据的时候，CPU可以干其他的事情，好像是多线程一样。数据传输支持从外设到存储器或者存储器到存储器， 这里的存储器可以是SRAM或者是FLASH。DMA控制器包含了DMA1和DMA2，其中DMA1有7个通道，DMA2有5个通道， 这里的通道可以理解为传输数据的一种管道。要注意的是DMA2只存在于大容量产品和互联型产品中。

## 22.2. DMA功能框图

DMA控制器独立于内核，属于一个单独的外设，结构比较简单，从编程的角度来看，我们只需掌握功能框图中的三部分内容即可， 具体见图 [DMA框图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/DMA.html#id3) ：DMA控制器的框图。

![DMA框图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DMA002.png)

### 22.2.1. DMA请求

如果外设要想通过DMA来传输数据，必须先给DMA控制器发送DMA请求，DMA收到请求信号之后，控制器会给外设一个应答信号， 当外设应答后且DMA控制器收到应答信号之后，就会启动DMA的传输，直到传输完毕。

DMA有DMA1和DMA2两个控制器，DMA1有7个通道，DMA2有5个通道，不同的DMA控制器的通道对应着不同的外设请求， 这决定了我们在软件编程上该怎么设置，具体见DMA请求映像表。

![DMA1各个通道的请求映像](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DMA003.png)![DMA2各个通道的请求映像](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/DMA004.png)

其中ADC3、SDIO和TIM8的DMA请求只在大容量产品中存在，这个在具体项目时要注意。

### 22.2.2. 通道

DMA具有12个独立可编程的通道，其中DMA1有7个通道，DMA2有5个通道，每个通道对应不同的外设的DMA请求。 虽然每个通道可以接收多个外设的请求，但是同一时间只能接收一个，不能同时接收多个。

### 22.2.3. 仲裁器
当发生多个DMA通道请求时，就意味着有先后响应处理的顺序问题，这个就由仲裁器也管理。仲裁器管理DMA通道请求分为两个阶段。 第一阶段属于软件阶段，可以在DMA_CCRx寄存器中设置，有4个等级：非常高、高、中和低四个优先级。第二阶段属于硬件阶段， 如果两个或以上的DMA通道请求设置的优先级一样，则他们优先级取决于通道编号，编号越低优先权越高，比如通道0高于通道1。 在大容量产品和互联型产品中， DMA1控制器拥有高于DMA2控制器的优先级。

## 22.3. DMA数据配置

使用DMA，最核心就是配置要传输的数据，包括数据从哪里来，要到哪里去，传输的数据的单位是什么，要传多少数据，是一次传输还是循环传输等等。

### 22.3.1. 从哪里来到哪里去

我们知道DMA传输数据的方向有三个：从外设到存储器，从存储器到外设，从存储器到存储器。 具体的方向DMA_CCR位4 DIR配置：0表示从外设到存储器，1表示从存储器到外设。 这里面涉及到的外设地址由DMA_CPAR配置，存储器地址由DMA_CMAR配置。

**外设到存储器**

当我们使用从外设到存储器传输时，以ADC采集为例。DMA外设寄存器的地址对应的就是ADC数据寄存器的地址， DMA存储器的地址就是我们自定义的变量（用来接收存储AD采集的数据）的地址。方向我们设置外设为源地址。

**存储器到外设**

当我们使用从存储器到外设传输时，以串口向电脑端发送数据为例。DMA外设寄存器的地址对应的就是串口数据寄存器的地址， DMA存储器的地址就是我们自定义的变量（相当于一个缓冲区，用来存储通过串口发送到电脑的数据）的地址。方向我们设置外设为目标地址。

**存储器到存储器**

当我们使用从存储器到存储器传输时，以内部FLASH向内部SRAM复制数据为例。 DMA外设寄存器的地址对应的就是内部FLASH（我们这里把内部FALSH当作一个外设来看）的地址， DMA存储器的地址就是我们自定义的变量（相当于一个缓冲区，用来存储来自内部FLASH的数据）的地址。 方向我们设置外设（即内部FLASH）为源地址。跟上面两个不一样的是，这里需要把DMA_CCR位14：MEM2MEM：存储器到存储器模式配置为1，启动M2M模式。

### 22.3.2. 要传多少，单位是什么

当我们配置好数据要从哪里来到哪里去之后，我们还需要知道我们要传输的数据是多少，数据的单位是什么。

以串口向电脑发送数据为例，我们可以一次性给电脑发送很多数据，具体多少由DMA_CNDTR配置， 这是一个32位的寄存器，一次最多只能传输65535个数据。

要想数据传输正确，源和目标地址存储的数据宽度还必须一致，串口数据寄存器是8位的， 所以我们定义的要发送的数据也必须是8位。外设的数据宽度由DMA_CCRx的PSIZE[1:0]配置， 可以是8/16/32位，存储器的数据宽度由DMA_CCRx的MSIZE[1:0]配置，可以是8/16/32位。

在DMA控制器的控制下，数据要想有条不紊的从一个地方搬到另外一个地方，还必须正确设置两边数据指针的增量模式。 外设的地址指针由DMA_CCRx的PINC配置，存储器的地址指针由MINC配置。以串口向电脑发送数据为例，要发送的数据很多， 每发送完一个，那么存储器的地址指针就应该加1，而串口数据寄存器只有一个， 那么外设的地址指针就固定不变。具体的数据指针的增量模式由实际情况决定。

### 22.3.3. 什么时候传输完成

数据什么时候传输完成，我们可以通过查询标志位或者通过中断的方式来鉴别。每个DMA通道在DMA传输过半、 传输完成和传输错误时都会有相应的标志位，如果使能了该类型的中断后，则会产生中断。有关各个标志位的详细描述请参考DMA中断状态寄存器DMA_ISR的详细描述。

传输完成还分两种模式，是一次传输还是循环传输，一次传输很好理解，即是传输一次之后就停止，要想再传输的话， 必须关断DMA使能后再重新配置后才能继续传输。循环传输则是一次传输完成之后又恢复第一次传输时的配置循环传输， 不断的重复。具体的由DMA_CCRx寄存器的CIRC 循环模式位控制。

## 22.4. DMA初始化结构体详解

标准库函数对每个外设都建立了一个初始化结构体xxx_InitTypeDef(xxx为外设名称)，结构体成员用于设置外设工作参数， 并由标准库函数xxx_Init()调用这些设定参数进入设置外设相应的寄存器，达到配置外设工作环境的目的。

结构体xxx_InitTypeDef和库函数xxx_Init配合使用是标准库精髓所在，理解了结构体xxx_InitTypeDef每个成员意义基本上就可以对该外设运用自如。 结构体xxx_InitTypeDef定义在stm32f10x_xxx.h(后面xxx为外设名称)文件中，库函数xxx_Init定义在stm32f10x_xxx.c文件中， 编程时我们可以结合这两个文件内注释使用。

**DMA_ InitTypeDef初始化结构体**

```c
typedef struct
{
    uint32_t DMA_PeripheralBaseAddr;   // 外设地址
    uint32_t DMA_MemoryBaseAddr;       // 存储器地址
    uint32_t DMA_DIR;                  // 传输方向
    uint32_t DMA_BufferSize;           // 传输数目
    uint32_t DMA_PeripheralInc;        // 外设地址增量模式
    uint32_t DMA_MemoryInc;            // 存储器地址增量模式
    uint32_t DMA_PeripheralDataSize;   // 外设数据宽度
    uint32_t DMA_MemoryDataSize;       // 存储器数据宽度
    uint32_t DMA_Mode;                 // 模式选择
    uint32_t DMA_Priority;             // 通道优先级
    uint32_t DMA_M2M;                  // 存储器到存储器模式
} DMA_InitTypeDef;
```

1) DMA_PeripheralBaseAddr： 外设地址，设定DMA_CPAR寄存器的值；一般设置为外设的数据寄存器地址，如果是存储器到存储器模式则设置为其中一个存储器地址。

2) DMA_Memory0BaseAddr： 存储器地址，设定DMA_CMAR寄存器值；一般设置为我们自定义存储区的首地址。

3) DMA_DIR： 传输方向选择，可选外设到存储器、存储器到外设。它设定DMA_CCR寄存器的DIR[1:0]位的值。这里并没有存储器到存储器的方向选择，当使用存储器到存储器时，只需要把其中一个存储器当作外设使用即可。

4) DMA_BufferSize： 设定待传输数据数目，初始化设定DMA_CNDTR寄存器的值。

5) DMA_PeripheralInc： 如果配置为DMA_PeripheralInc_Enable，使能外设地址自动递增功能，它设定DMA_CCR寄存器的PINC位的值；一般外设都是只有一个数据寄存器，所以一般不会使能该位。

6) DMA_MemoryInc： 如果配置为DMA_MemoryInc_Enable，使能存储器地址自动递增功能，它设定DMA_CCR寄存器的MINC位的值；我们自定义的存储区一般都是存放多个数据的，所以要使能存储器地址自动递增功能。

7) DMA_PeripheralDataSize： 外设数据宽度，可选字节(8位)、半字(16位)和字(32位)，它设定DMA_CCR寄存器的PSIZE[1:0]位的值。

8) DMA_MemoryDataSize： 存储器数据宽度，可选字节(8位)、半字(16位)和字(32位)，它设定DMA_CCR寄存器的MSIZE[1:0]位的值。当外设和存储器之间传数据时，两边的数据宽度应该设置为一致大小。

9) DMA_Mode： DMA传输模式选择，可选一次传输或者循环传输，它设定DMA_CCR寄存器的CIRC位的值。例程我们的ADC采集是持续循环进行的，所以使用循环传输模式。

10) DMA_Priority： 软件设置通道的优先级，有4个可选优先级分别为非常高、高、中和低，它设定DMA_CCR寄存器的PL[1:0]位的值。DMA通道优先级只有在多个DMA通道同时使用时才有意义，如果是单个通道，优先级可以随便设置。

11) DMA_M2M： 存储器到存储器模式，使用存储器到存储器时用到，设定DMA_CCR的位14 MEN2MEN即可启动存储器到存储器模式。

## 22.5. DMA存储器到存储器模式实验

本章只讲解存储器到存储器和存储器到外设这两种模式，其他功能模式在其他章节使用到的时候再讲。 存储器到存储器模式可以实现数据在两个内存的快速拷贝。我们先定义一个静态的源数据，存放在内部FLASH， 然后使用DMA传输把源数据拷贝到目标地址上（内部SRAM），最后对比源数据和目标地址的数据，看看是否传输准确 。

### 22.5.1. 硬件设计

DMA存储器到存储器实验不需要其他硬件要求，只用到RGB彩色灯用于指示程序状态。

### 22.5.2. 软件设计

这里只讲解核心的部分代码，有些变量的设置，头文件的包含等并没有涉及到，完整的代码请参考本章配套的工程。 这个实验代码比较简单，主要程序代码都在main.c文件中。

#### 22.5.2.1. 编程要点

> 1. 使能DMA时钟；
>     
> 2. 配置DMA数据参数；
>     
> 3. 使能DMA，进行传输；
>     
> 4. 等待传输完成，并对源数据和目标地址数据进行比较。
>     

#### 22.5.2.2. 代码分析

**DMA宏定义及相关变量定义**

代码清单:DMA-1 DMA数据流和相关变量定义[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/DMA.html#dma-1 "永久链接至代码")

```c
// 当使用存储器到存储器模式时候，通道可以随便选，没有硬性的规定
#define DMA_CHANNEL     DMA1_Channel6
#define DMA_CLOCK       RCC_AHBPeriph_DMA1

// 传输完成标志
#define DMA_FLAG_TC     DMA1_FLAG_TC6

// 要发送的数据大小
#define BUFFER_SIZE     32

/* 定义aSRC_Const_Buffer数组作为DMA传输数据源
* const关键字将aSRC_Const_Buffer数组变量定义为常量类型
* 表示数据存储在内部的FLASH中
*/
const uint32_t aSRC_Const_Buffer[BUFFER_SIZE]=
{
    0x01020304,0x05060708,0x090A0B0C,0x0D0E0F10,
    0x11121314,0x15161718,0x191A1B1C,0x1D1E1F20,
    0x21222324,0x25262728,0x292A2B2C,0x2D2E2F30,
    0x31323334,0x35363738,0x393A3B3C,0x3D3E3F40,
    0x41424344,0x45464748,0x494A4B4C,0x4D4E4F50,
    0x51525354,0x55565758,0x595A5B5C,0x5D5E5F60,
    0x61626364,0x65666768,0x696A6B6C,0x6D6E6F70,
    0x71727374,0x75767778,0x797A7B7C,0x7D7E7F80
};
/* 定义DMA传输目标存储器
* 存储在内部的SRAM中
*/
uint32_t aDST_Buffer[BUFFER_SIZE];
```
使用宏定义设置外设配置方便程序修改和升级。

存储器到存储器传输通道没有硬性规定，可以随意选择。

aSRC_Const_Buffer[BUFFER_SIZE]定义用来存放源数据，并且使用了const关键字修饰，即常量类型，使得变量是存储在内部flash空间上。

**DMA数据配置**

代码清单:DMA-2 DMA传输参数配置[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/DMA.html#dma-2 "永久链接至代码")

```c
void DMA_Config(void)
{
    DMA_InitTypeDef DMA_InitStructure;

    // 开启DMA时钟
    RCC_AHBPeriphClockCmd(DMA_CLOCK, ENABLE);
    // 源数据地址
    DMA_InitStructure.DMA_PeripheralBaseAddr =
        (uint32_t)aSRC_Const_Buffer;
    // 目标地址
    DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)aDST_Buffer;
    // 方向：外设到存储器（这里的外设是内部的FLASH）
    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
    // 传输大小
    DMA_InitStructure.DMA_BufferSize = BUFFER_SIZE;
    // 外设（内部的FLASH）地址递增
    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;
    // 内存地址递增
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    // 外设数据单位
    DMA_InitStructure.DMA_PeripheralDataSize =
        DMA_PeripheralDataSize_Word;
    // 内存数据单位
    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
    // DMA模式，一次或者循环模式
    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal ;
    //DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
    // 优先级：高
    DMA_InitStructure.DMA_Priority = DMA_Priority_High;
    // 使能内存到内存的传输
    DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;
    // 配置DMA通道
    DMA_Init(DMA_CHANNEL, &DMA_InitStructure);
    // 使能DMA
    DMA_Cmd(DMA_CHANNEL,ENABLE);
}
```
使用DMA_InitTypeDef结构体定义一个DMA初始化变量，这个结构体内容我们之前已经有详细讲解。

调用RCC_AHBPeriphClockCmd函数开启DMA时钟，使用DMA控制器之前必须开启对应的时钟。

源地址和目标地址使用之前定义的数组首地址，传输的数据量为宏BUFFER_SIZE决定，源和目标地址指针地址递增， 使用一次传输模式不能循环传输，因为只有一个DMA通道，优先级随便设置，最后调用DMA_Init函数完成DMA的初始化配置。

DMA_ClearFlag函数用于清除DMA标志位，代码用到传输完成标志位，使用之前先清除传输完成标志位以免产生不必要干扰。 DMA_ClearFlag函数需要1个形参，即事件标志位，可选有传输完成标志位、半传输标志位、FIFO错误标志位、传输错误标志位等等， 非常多，我们这里选择传输完成标志位，由宏DMA_FLAG_TC定义。

DMA_Cmd函数用于启动或者停止DMA数据传输，它接收两个参数，第一个是DMA通道，另外一个是开启ENABLE或者停止DISABLE。

**存储器数据对比**

代码清单:DMA-3 源数据与目标地址数据对比[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/DMA.html#dma-3 "永久链接至代码")

```c
uint8_t Buffercmp(const uint32_t* pBuffer,
                uint32_t* pBuffer1, uint16_t BufferLength)
{
    /* 数据长度递减 */
    while (BufferLength--) {
        /* 判断两个数据源是否对应相等 */
        if (*pBuffer != *pBuffer1) {
            /* 对应数据源不相等马上退出函数，并返回0 */
            return 0;
        }
        /* 递增两个数据源的地址指针 */
        pBuffer++;
        pBuffer1++;
    }
    /* 完成判断并且对应数据相对 */
    return 1;
}
```
判断指定长度的两个数据源是否完全相等，如果完全相等返回1；只要其中一对数据不相等返回0。 它需要三个形参，前两个是两个数据源的地址，第三个是要比较数据长度。

**主函数**

代码清单:DMA-4 存储器到存储器模式主函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/DMA.html#dma-4 "永久链接至代码")

```c
int main(void)
{
    /* 定义存放比较结果变量 */
    uint8_t TransferStatus;

    /* LED 端口初始化 */
    LED_GPIO_Config();

    /* 设置RGB彩色灯为紫色 */
    LED_PURPLE;

    /* 简单延时函数 */
    Delay(0xFFFFFF);

    /* DMA传输配置 */
    DMA_Config();

    /* 等待DMA传输完成 */
    while (DMA_GetFlagStatus(DMA_FLAG_TC)==RESET)
    {

    }

    /* 比较源数据与传输后数据 */
    TransferStatus=Buffercmp(aSRC_Const_Buffer, aDST_Buffer, BUFFER_SIZE);

    /* 判断源数据与传输后数据比较结果*/
    if (TransferStatus==0)
    {
        /* 源数据与传输后数据不相等时RGB彩色灯显示红色 */
        LED_RED;
    }
    else
    {
        /* 源数据与传输后数据相等时RGB彩色灯显示蓝色 */
        LED_BLUE;
    }

    while (1)
    {
    }
}
```
首先定义一个变量用来保存存储器数据比较结果。

RGB彩色灯用来指示程序进程，使用之前需要初始化它，LED_GPIO_Config定义在bsp_led.c文件中。开始设置RGB彩色灯为紫色， LED_PURPLE是定义在bsp_led.h文件的一个宏定义。

Delay函数只是一个简单的延时函数。

调用DMA_Config函数完成DMA数据流配置并启动DMA数据传输。

DMA_GetFlagStatus函数获取DMA事件标志位的当前状态，这里获取DMA数据传输完成这个标志位，使用循环持续等待直到该标志位被置位， 即DMA传输完成这个事件发生，然后退出循环，运行之后程序。

确定DMA传输完成之后就可以调用Buffercmp函数比较源数据与DMA传输后目标地址的数据是否一一对应。TransferStatus保存比较结果， 如果为1表示两个数据源一一对应相等说明DMA传输成功；相反，如果为0表示两个数据源数据存在不等情况，说明DMA传输出错。

如果DMA传输成功设置RGB彩色灯为蓝色，如果DMA传输出错设置RGB彩色灯为红色。

### 22.5.3. 下载验证

确保开发板供电正常，编译程序并下载。观察RGB彩色灯变化情况。正常情况下RGB彩色灯先为紫色，然后变成蓝色。如果DMA传输出错才会为红色。

## 22.6. DMA存储器到外设模式实验

上个实验我们讲了DMA存储器到存储器模式，接下来我们再讲一个存储器到外设的实验。我们先定义一个数据变量， 存于SRAM中，然后通过DMA的方式传输到串口的数据寄存器，然后通过串口把这些数据发送到电脑的上位机显示出来。

### 22.6.1. 硬件设计

存储器到外设模式使用到USART1功能，具体电路设置参考USART章节，无需其他硬件设计。

### 22.6.2. 软件设计

这里只讲解核心的部分代码，有些变量的设置，头文件的包含等并没有涉及到，完整的代码请参考本章配套的工程。 我们编写两个串口驱动文件bsp_usart_dma.c和bsp_usart_dma.h，有关串口和DMA的宏定义以及驱动函数都在里边。

#### 22.6.2.1. 编程要点

> 1. 配置USART通信功能；
>     
> 2. 设置串口DMA工作参数；
>     
> 3. 使能DMA；
>     
> 4. DMA传输同时CPU可以运行其他任务。
>     

#### 22.6.2.2. 代码分析

**USART和DMA宏定义**

代码清单:DMA-5 USART和DMA相关宏定义[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/DMA.html#dma-5 "永久链接至代码")

```c
// 串口工作参数宏定义
#define  DEBUG_USARTx                   USART1
#define  DEBUG_USART_CLK                RCC_APB2Periph_USART1
#define  DEBUG_USART_APBxClkCmd         RCC_APB2PeriphClockCmd
#define  DEBUG_USART_BAUDRATE           115200

// USART GPIO 引脚宏定义
#define  DEBUG_USART_GPIO_CLK           (RCC_APB2Periph_GPIOA)
#define  DEBUG_USART_GPIO_APBxClkCmd    RCC_APB2PeriphClockCmd

#define  DEBUG_USART_TX_GPIO_PORT       GPIOA
#define  DEBUG_USART_TX_GPIO_PIN        GPIO_Pin_9
#define  DEBUG_USART_RX_GPIO_PORT       GPIOA
#define  DEBUG_USART_RX_GPIO_PIN        GPIO_Pin_10

// 串口对应的DMA请求通道
#define  USART_TX_DMA_CHANNEL     DMA1_Channel4
// 外设寄存器地址
#define  USART_DR_ADDRESS        (USART1_BASE+0x04)
// 一次发送的数据量
#define  SENDBUFF_SIZE            5000
```
使用宏定义设置外设配置方便程序修改和升级。

USART部分设置与USART章节内容相同，可以参考USART章节内容理解。串口的发送请求对应有固定的DMA通道， 这里的外设的地址即串口的数据寄存器，一次要发送的数据量可以自定义，配置SENDBUFF_SIZE这个宏即可。

**串口DMA传输配置**

代码清单:DMA-6 USART1 发送请求DMA设置[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/DMA.html#dma-6 "永久链接至代码")

```c
void USARTx_DMA_Config(void)
{
    DMA_InitTypeDef DMA_InitStructure;

    // 开启DMA时钟
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    // 设置DMA源地址：串口数据寄存器地址*/
    DMA_InitStructure.DMA_PeripheralBaseAddr = USART_DR_ADDRESS;
    // 内存地址(要传输的变量的指针)
    DMA_InitStructure.DMA_MemoryBaseAddr = (u32)SendBuff;
    // 方向：从内存到外设
    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
    // 传输大小
    DMA_InitStructure.DMA_BufferSize = SENDBUFF_SIZE;
    // 外设地址不增
    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    // 内存地址自增
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    // 外设数据单位
    DMA_InitStructure.DMA_PeripheralDataSize =
        DMA_PeripheralDataSize_Byte;
    // 内存数据单位
    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    // DMA模式，一次或者循环模式
    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal ;
    //DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
    // 优先级：中
    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
    // 禁止内存到内存的传输
    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    // 配置DMA通道
    DMA_Init(USART_TX_DMA_CHANNEL, &DMA_InitStructure);
    // 使能DMA
    DMA_Cmd (USART_TX_DMA_CHANNEL,ENABLE);
}
```
首先定义一个DMA初始化变量，用来填充DMA的参数，然后使能DMA时钟。

因为数据是从存储器到串口，所以设置存储器为源地址，串口的数据寄存器为目标地址，要发送的数据有很多且都先存储在存储器中， 则存储器地址指针递增，串口数据寄存器只有一个，则外设地址地址不变，两边数据单位设置成一致，传输模式可选一次或者循环传输， 只有一个DMA请求，优先级随便设，最后调用DMA_Init函数把这些参数写到DMA的寄存器中，然后使能DMA开始传输.

**主函数**

代码清单:DMA-7 存储器到外设模式主函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/DMA.html#dma-7 "永久链接至代码")

```c
int main(void)
{
    uint16_t i;
    /* 初始化USART */
    USART_Config();

    /* 配置使用DMA模式 */
    USARTx_DMA_Config();

    /* 配置RGB彩色灯 */
    LED_GPIO_Config();

    printf("\r\n USART1 DMA TX 测试 \r\n");

    /*填充将要发送的数据*/
    for (i=0; i<SENDBUFF_SIZE; i++)
    {
        SendBuff[i]  = 'P';

    }

    /*为演示DMA持续运行而CPU还能处理其它事情，持续使用DMA发送数据，量非常大，
    *长时间运行可能会导致电脑端串口调试助手会卡死，鼠标乱飞的情况，
    *或把DMA配置中的循环模式改为单次模式*/

    /* USART1 向 DMA发出TX请求 */
    USART_DMACmd(USARTx, USART_DMAReq_Tx, ENABLE);

    /* 此时CPU是空闲的，可以干其他的事情 */
    //例如同时控制LED
    while (1)
    {
        LED1_TOGGLE
        Delay(0xFFFFF);
    }
}
```
USART_Config函数定义在bsp_usart_dma.c中，它完成USART初始化配置，包括GPIO初始化，USART通信参数设置等等，具体可参考USART章节讲解。

USARTx_DMA_Config函数也是定义在bsp_usart_dma.c中，之前我们已详细分析。

LED_GPIO_Config函数定义在bsp_led.c中，它完成RGB彩色灯初始化配置，具体可参考GPIO章节讲解。

使用for循环填充源数据，SendBuff[SENDBUFF_SIZE]是定义在bsp_usart_dma.c中的一个全局无符号8位整数数组，是DMA传输的源数据， 在USART_DMA_Config函数中已经被设置为存储器地址。

USART_DMACmd函数用于控制USART的DMA请求的启动和关闭。它接收三个参数，第一个参数用于设置串口外设，可以是USART1/2/3和UART4/5这5个参数可选， 第二个参数设置串口的具体DMA请求，有串口发送请求USART_DMAReq_Tx和接收请求USART_DMAReq_Rx可选， 第三个参数用于设置启动请求ENABLE或者关闭请求DISABLE。运行该函数后USART的DMA发送传输就开始了，根据配置存储器的数据会发送到串口。

DMA传输过程是不占用CPU资源的，可以一边传输一次运行其他任务。

### 22.6.3. 下载验证
保证开发板相关硬件连接正确，用USB线连接开发板的USB转串口和电脑，在电脑端打开串口调试助手，把编译好的程序下载到开发板。 程序运行后在串口调试助手可接收到大量的数据，同时开发板上RGB彩色灯不断闪烁。

这里要注意为演示DMA持续运行并且CPU还能处理其它事情，持续使用DMA发送数据，量非常大，长时间运行可能会导致电脑端串口调试助手会卡死， 鼠标乱飞的情况，所以在测试时最好把串口调试助手的自动清除接收区数据功能勾选上或把DMA配置中的循环模式改为单次模式。



# 23. 常用存储器介绍

## 23.1. 存储器种类

存储器是计算机结构的重要组成部分。存储器是用来存储程序代码和数据的部件，有了存储器计算机才具有记忆功能。 基本的存储器种类见图 [基本存储器种类](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/storage.html#id3) 。

![基本存储器种类](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag002.jpeg)

存储器按其存储介质特性主要分为“易失性存储器”和“非易失性存储器”两大类。其中的“易失/非易失”是指存储器断电后， 它存储的数据内容是否会丢失的特性。由于一般易失性存储器存取速度快，而非易失性存储器可长期保存数据， 它们都在计算机中占据着重要角色。在计算机中易失性存储器最典型的代表是内存，非易失性存储器的代表则是硬盘。

## 23.2. RAM存储器

RAM是“Random Access Memory”的缩写，被译为随机存储器。所谓“随机存取”，指的是当存储器中的消息被读取或写入时， 所需要的时间与这段信息所在的位置无关。这个词的由来是因为早期计算机曾使用磁鼓作为存储器，磁鼓是顺序读写设备， 而RAM可随读取其内部任意地址的数据，时间都是相同的，因此得名。实际上现在RAM已经专门用于指代作为计算机内存的易失性半导体存储器。

根据RAM的存储机制，又分为动态随机存储器DRAM(Dynamic RAM)以及静态随机存储器SRAM(Static RAM)两种。

### 23.2.1. DRAM

动态随机存储器DRAM的存储单元以电容的电荷来表示数据，有电荷代表1，无电荷代表0，见图 [DRAM存储单元](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/storage.html#id4) 。 但时间一长，代表1的电容会放电，代表0的电容会吸收电荷，因此它需要定期刷新操作，这就是“动态(Dynamic)”一词所形容的特性。 刷新操作会对电容进行检查，若电量大于满电量的1/2，则认为其代表1，并把电容充满电；若电量小于1/2，则认为其代表0，并把电容放电，藉此来保证数据的正确性。

![DRAM存储单元](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag003.jpg)

#### 23.2.1.1. SDRAM

根据DRAM的通讯方式，又分为同步和异步两种，这两种方式根据通讯时是否需要使用时钟信号来区分。 图 [同步通讯时序图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/storage.html#id5) 是一种利用时钟进行同步的通讯时序，它在时钟的上升沿表示有效数据。

![同步通讯时序图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag004.jpeg)

由于使用时钟同步的通讯速度更快，所以同步DRAM使用更为广泛，这种DRAM被称为SDRAM(Synchronous DRAM)。

#### 23.2.1.2. DDR SDRAM

为了进一步提高SDRAM的通讯速度，人们设计了DDR SDRAM存储器(Double Data Rate SDRAM)。它的存储特性与SDRAM没有区别， 但SDRAM只在上升沿表示有效数据，在1个时钟周期内，只能表示1个有数据；而DDRSDRAM在时钟的上升沿及下降沿各表示一个数据， 也就是说在1个时钟周期内可以表示2位数据，在时钟频率同样的情况下，提高了一倍的速度。至于DDRII和DDRIII， 它们的通讯方式并没有区别，主要是通讯同步时钟的频率提高了。

当前个人计算机常用的内存条是DDRIII SDRAM存储器，在一个内存条上包含多个DDRIII SDRAM芯片。

### 23.2.2. SRAM

静态随机存储器SRAM的存储单元以锁存器来存储数据，见图 [SRAM存储单元](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/storage.html#id6) 。 这种电路结构不需要定时刷新充电，就能保持状态(当然，如果断电了，数据还是会丢失的)，所以这种存储器被称为“静态(Static)”RAM。

![SRAM存储单元](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag005.jpg)

同样地，SRAM根据其通讯方式也分为同步(SSRAM)和异步SRAM，相对来说，异步SRAM用得比较广泛。

### 23.2.3. DRAM与SRAM的应用场合

对比DRAM与SRAM的结构，可知DRAM的结构简单得多，所以生产相同容量的存储器，DRAM的成本要更低，且集成度更高。 而DRAM中的电容结构则决定了它的存取速度不如SRAM，特性对比见表 [DRAM与SRAM对比](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/storage.html#id7) 。

![DRAM与SRAM对比](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag01.png)

所以在实际应用场合中，SRAM一般只用于CPU内部的高速缓存(Cache)，而外部扩展的内存一般使用DRAM。 在STM32系统的控制器中，只有STM32F429型号或更高级的芯片才支持扩展SDRAM，其它型号如STM32F1、STM32F2及STM32F407等型号只能扩展SRAM。

## 23.3. 非易失性存储器

非易失性存储器种类非常多，半导体类的有ROM和FLASH，而其它的则包括光盘、软盘及机械硬盘。

### 23.3.1. ROM存储器
ROM是“Read Only Memory”的缩写，意为只能读的存储器。由于技术的发展，后来设计出了可以方便写入数据的ROM， 而这个“Read Only Memory”的名称被沿用下来了，现在一般用于指代非易失性半导体存储器， 包括后面介绍的FLASH存储器，有些人也把它归到ROM类里边。

#### 23.3.1.1. MASK ROM

MASK(掩膜) ROM就是正宗的“Read Only Memory”，存储在它内部的数据是在出厂时使用特殊工艺固化的，生产后就不可修改， 其主要优势是大批量生产时成本低。当前在生产量大，数据不需要修改的场合，还有应用。

#### 23.3.1.2. OTPROM

OTPROM(One Time Programable ROM)是一次可编程存储器。这种存储器出厂时内部并没有资料，用户可以使用专用的编程器将自己的资料写入， 但只能写入一次，被写入过后，它的内容也不可再修改。在NXP公司生产的控制器芯片中常使用OTPROM来存储密钥或设备独有的mac地址等内容。

#### 23.3.1.3. EPROM

EPROM(Erasable Programmable ROM)是可重复擦写的存储器， 它解决了PROM芯片只能写入一次的问题。这种存储器使用紫外线照射芯片内部擦除数据， 擦除和写入都要专用的设备。现在这种存储器基本淘汰，被EEPROM取代。

#### 23.3.1.4. EEPROM
EEPROM(Electrically Erasable Programmable ROM)是电可擦除存储器。 EEPROM可以重复擦写，它的擦除和写入都是直接使用电路控制， 不需要再使用外部设备来擦写。而且可以按字节为单位修改数据，无需整个芯片擦除。现在主要使用的ROM芯片都是EEPROM。

### 23.3.2. FLASH存储器

FLASH存储器又称为闪存，它也是可重复擦写的储器，部分书籍会把FLASH存储器称为FLASH ROM，但它的容量一般比EEPROM大得多， 且在擦除时，一般以多个字节为单位。如有的FLASH存储器以4096个字节为扇区，最小的擦除单位为一个扇区。根据存储单元电路的不同， FLASH存储器又分为NOR FLASH和NAND FLASH，见表 [NOR_FLASH与NAND_FLASH特性对比](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/storage.html#nor-flashnand-flash) 。

![NOR_FLASH与NAND_FLASH特性对比](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/storag02.png)

NOR与NAND的共性是在数据写入前都需要有擦除操作，而擦除操作一般是以“扇区/块”为单位的。 而NOR与NAND特性的差别，主要是由于其内部“地址/数据线”是否分开导致的。

由于NOR的地址线和数据线分开，它可以按“字节”读写数据，符合CPU的指令译码执行要求，所以假如NOR上存储了代码指令， CPU给NOR一个地址，NOR就能向CPU返回一个数据让CPU执行，中间不需要额外的处理操作。

而由于NAND的数据和地址线共用，只能按“块”来读写数据，假如NAND上存储了代码指令，CPU给NAND地址后， 它无法直接返回该地址的数据，所以不符合指令译码要求。 表 [NOR_FLASH与NAND_FLASH特性对比](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/storage.html#nor-flashnand-flash) 中的最后一项“是否支持XIP”描述的就是这种立即执行的特性(eXecute In Place)。

若代码存储在NAND上，可以把它先加载到RAM存储器上，再由CPU执行。所以在功能上可以认为NOR是一种断电后数据不丢失的RAM， 但它的擦除单位与RAM有区别，且读写速度比RAM要慢得多。

另外，FLASH的擦除次数都是有限的(现在普遍是10万次左右)，当它的使用接近寿命的时候，可能会出现写操作失败。 由于NAND通常是整块擦写，块内有一位失效整个块就会失效，这被称为坏块，而且由于擦写过程复杂，从整体来说NOR块块更少， 寿命更长。由于可能存在坏块，所以FLASH存储器需要“探测/错误更正(EDC/ECC)”算法来确保数据的正确性。

由于两种FLASH存储器特性的差异，NOR FLASH一般应用在代码存储的场合，如嵌入式控制器内部的程序存储空间。 而NAND FLASH一般应用在大数据量存储的场合，包括SD卡、U盘以及固态硬盘等，都是NAND FLASH类型的。

在本教程中会对如何使用RAM、EEPROM、FLASH存储器进行实例讲解。

# 24. I2C—读写EEPROM

本章参考资料：《STM32F10X-中文参考手册》I2C章节及《I2C总线协议》。

若对I2C通讯协议不了解，可先阅读《I2C总线协议》文档的内容学习。

关于EEPROM存储器，请参考“常用存储器介绍”章节，实验中的EEPROM，请参考其规格书《AT24C02》来了解。

## 24.1. I2C协议简介

I2C 通讯协议(Inter－Integrated Circuit)是由Phiilps公司开发的，由于它引脚少，硬件实现简单，可扩展性强， 不需要USART、CAN等通讯协议的外部收发设备，现在被广泛地使用在系统内多个集成电路(IC)间的通讯。

在计算机科学里，大部分复杂的问题都可以通过分层来简化。如芯片被分为内核层和片上外设；STM32标准库则是在寄存器与用户代码之间的软件层。 对于通讯协议，我们也以分层的方式来理解，最基本的是把它分为物理层和协议层。物理层规定通讯系统中具有机械、电子功能部分的特性， 确保原始数据在物理媒体的传输。协议层主要规定通讯逻辑，统一收发双方的数据打包、解包标准。 简单来说物理层规定我们用嘴巴还是用肢体来交流，协议层则规定我们用中文还是英文来交流。

下面我们分别对I2C协议的物理层及协议层进行讲解。

### 24.1.1. **I2C物理层**

I2C通讯设备之间的常用连接方式见图 [常见的I2C通讯系统](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id2) 。

![常见的I2C通讯系统](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C002.png)

它的物理层有如下特点：

(1) 它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个I2C通讯总线中， 可连接多个I2C通讯设备，支持多个通讯主机及多个通讯从机。

(2) 一个I2C总线只使用两条总线线路，一条双向串行数据线(SDA) ， 一条串行时钟线 (SCL)。数据线即用来表示数据，时钟线用于数据收发同步。

(3) 每个连接到总线的设备都有一个独立的地址， 主机可以利用这个地址进行不同设备之间的访问。

(4) 总线通过上拉电阻接到电源。当I2C设备空闲时，会输出高阻态， 而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。

(5) 多个主机同时使用总线时，为了防止数据冲突， 会利用仲裁方式决定由哪个设备占用总线。

(6) 具有三种传输模式：标准模式传输速率为100kbit/s ，快速模式为400kbit/s ， 高速模式下可达 3.4Mbit/s，但目前大多I2C设备尚不支持高速模式。

(7) 连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制 。

### 24.1.2. 协议层

I2C的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节。

#### 24.1.2.1. I2C基本读写过程

先看看I2C通讯过程的基本结构，它的通讯过程见图 [主机写数据到从机](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id5) 、 图 [主机由从机中读数据](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id6) 及图 [I2C通讯复合格式](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id7) 。

![主机写数据到从机](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C003.jpg)![主机由从机中读数据](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C004.jpg)![I2C通讯复合格式](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C005.jpeg)

这些图表示的是主机和从机通讯时，SDA线的数据包序列。

其中S表示由主机的I2C接口产生的传输起始信号(S)，这时连接到I2C总线上的所有从机都会接收到这个信号。

起始信号产生后，所有从机就开始等待主机紧接下来广播 的从机地址信号 (SLAVE_ADDRESS)。在I2C总线上， 每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。 根据I2C协议，这个从机地址可以是7位或10位。

在地址位之后，是传输方向的选择位，该位为0时，表示后面的数据传输方向是由主机传输至从机，即主机向从机写数据。该位为1时，则相反，即主机由从机读数据。

从机接收到匹配的地址后，主机或从机会返回一个应答(ACK)或非应答(NACK)信号，只有接收到应答信号后，主机才能继续发送或接收数据。

**写数据**

若配置的方向传输位为“写数据”方向，即第一幅图的情况，广播完地址，接收到应答信号后，主机开始正式向从机传输数据(DATA)， 数据包的大小为8位，主机每发送完一个字节数据，都要等待从机的应答信号(ACK)，重复这个过程，可以向从机传输N个数据， 这个N没有大小限制。当数据传输结束时，主机向从机发送一个停止传输信号(P)，表示不再传输数据。

**读数据**

若配置的方向传输位为“读数据”方向，即第二幅图的情况，广播完地址，接收到应答信号后，从机开始向主机返回数据(DATA)， 数据包大小也为8位，从机每发送完一个数据，都会等待主机的应答信号(ACK)，重复这个过程，可以返回N个数据，这个N也没有大小限制。 当主机希望停止接收数据时，就向从机返回一个非应答信号(NACK)，则从机自动停止数据传输。

**读和写数据**

除了基本的读写，I2C通讯更常用的是复合格式，即第三幅图的情况，该传输过程有两次起始信号(S)。一般在第一次传输中， 主机通过SLAVE_ADDRESS寻找到从设备后，发送一段“数据”，这段数据通常用于表示从设备内部的寄存器或存储器地址(注意区分它与SLAVE_ADDRESS的区别)； 在第二次的传输中，对该地址的内容进行读或写。也就是说，第一次通讯是告诉从机读写地址，第二次则是读写的实际内容。

以上通讯流程中包含的各个信号分解如下：

#### 24.1.2.2. 通讯的起始和停止信号
前文中提到的起始(S)和停止(P)信号是两种特殊的状态，见图 [起始和停止信号](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id9) 。 当 SCL 线是高电平时 SDA 线从高电平向低电平切换，这个情况表示通讯的起始。 当 SCL 是高电平时 SDA 线由低电平向高电平切换，表示通讯的停止。起始和停止信号一般由主机产生。

![起始和停止信号](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C008.jpg)

#### 24.1.2.3. 数据有效性

I2C使用SDA信号线来传输数据，使用SCL信号线进行数据同步。见图 [数据有效性](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id11) 。 SDA数据线在SCL的每个时钟周期传输一位数据。传输时，SCL为高电平的时候SDA表示的数据有效，即此时的SDA为高电平时表示数据“1”， 为低电平时表示数据“0”。当SCL为低电平时，SDA的数据无效，一般在这个时候SDA进行电平切换，为下一次表示数据做好准备。

![数据有效性](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C009.jpg)

每次数据传输都以字节为单位，每次传输的字节数不受限制。

#### 24.1.2.4. 地址及数据方向
I2C总线上的每个设备都有自己的独立地址，主机发起通讯时，通过SDA信号线发送设备地址(SLAVE_ADDRESS)来查找从机。 I2C协议规定设备地址可以是7位或10位，实际中7位的地址应用比较广泛。紧跟设备地址的一个数据位用来表示数据传输方向， 它是数据方向位(R/)，第8位或第11位。数据方向位为“1”时表示主机由从机读数据，该位为“0”时表示主机向从机写数据。 见图 [设备地址及数据传输方向](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id13) 。

![设备地址及数据传输方向](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C010.jpg)

读数据方向时，主机会释放对SDA信号线的控制，由从机控制SDA信号线，主机接收信号， 写数据方向时，SDA由主机控制，从机接收信号。

#### 24.1.2.5. 响应

I2C的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号。作为数据接收端时， 当设备(无论主从机)接收到I2C传输的一个字节数据或地址后，若希望对方继续发送数据，则需要向对方发送“应答(ACK)”信号， 发送方会继续发送下一个数据；若接收端希望结束数据传输，则向对方发送“非应答(NACK)”信号， 发送方接收到该信号后会产生一个停止信号，结束信号传输。见图 [响应与非响应信号](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id15) 。

![响应与非响应信号](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C011.jpg)

传输时主机产生时钟，在第9个时钟时，数据发送端会释放SDA的控制权，由数据接收端控制SDA， 若SDA为高电平，表示非应答信号(NACK)，低电平表示应答信号(ACK)。

## 24.2. STM32的I2C特性及架构

如果我们直接控制STM32的两个GPIO引脚，分别用作SCL及SDA，按照上述信号的时序要求， 直接像控制LED灯那样控制引脚的输出(若是接收数据时则读取SDA电平)，就可以实现I2C通讯。 同样，假如我们按照USART的要求去控制引脚，也能实现USART通讯。所以只要遵守协议，就是标准的通讯， 不管您如何实现它，不管是ST生产的控制器还是ATMEL生产的存储器， 都能按通讯标准交互。

由于直接控制GPIO引脚电平产生通讯时序时，需要由CPU控制每个时刻的引脚状态， 所以称之为“软件模拟协议”方式。

相对地，还有“硬件协议”方式，STM32的I2C片上外设专门负责实现I2C通讯协议， 只要配置好该外设，它就会自动根据协议要求产生通讯信号，收发数据并缓存起来， CPU只要检测该外设的状态和访问数据寄存器，就能完成数据收发。 这种由硬件外设处理I2C协议的方式减轻了CPU的工作，且使软件设计更加简单。

### 24.2.1. STM32的I2C外设简介

STM32的I2C外设可用作通讯的主机及从机，支持100Kbit/s和400Kbit/s的速率，支持7位、10位设备地址， 支持DMA数据传输，并具有数据校验功能。它的I2C外设还支持SMBus2.0协议，SMBus协议与I2C类似， 主要应用于笔记本电脑的电池管理中，本教程不展开，感兴趣的读者可参考《SMBus20》文档了解。

### 24.2.2. STM32的I2C架构剖析

![I2C架构图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C012.jpg)

#### 24.2.2.1. 通讯引脚

I2C的所有硬件架构都是根据图中左侧SCL线和SDA线展开的(其中的SMBA线用于SMBUS的警告信号，I2C通讯没有使用)。 STM32芯片有多个I2C外设，它们的I2C通讯信号引出到不同的GPIO引脚上，使用时必须配置到这些指定的引脚，见 表 23‑1。关于GPIO引脚的复用功能，以规格书为准。

表 23‑1 STM32F10x的I2C引脚

|   |   |   |
|---|---|---|
|引脚|I2C1|I2C2|
|SCL|PB6 / PB8(重映射)|PB10|
|SDA|PB7 / PB9(重映射)|PB11|

#### 24.2.2.2. 时钟控制逻辑

SCL线的时钟信号，由I2C接口根据时钟控制寄存器(CCR)控制， 控制的参数主要为时钟频率。配置I2C的CCR寄存器可修改通讯速率相关的参数：

- 可选择I2C通讯的“标准/快速”模式，这两个模式分别I2C对应100/400Kbit/s的通讯速率。
    
- 在快速模式下可选择SCL时钟的占空比，可选Tlow/Thigh=2或Tlow/Thigh=16/9模式， 我们知道I2C协议在SCL高电平时对SDA信号采样， SCL低电平时SDA准备下一个数据，修改SCL的高低电平比会影响数据采样，但其实这两个模式的比例差别并不大， 若不是要求非常严格，这里随便选就可以了。
    
- CCR寄存器中还有一个12位的配置因子CCR，它与I2C外设的输入时钟源共同作用，产生SCL时钟， STM32的I2C外设都挂载在APB1总线上，使用APB1的时钟源PCLK1，SCL信号线的输出时钟公式如下：
    

**标准模式：**

> Thigh=CCR*TPCKL1 Tlow = CCR*TPCLK1

**快速模式中** Tlow/Thigh=2 **时：**

> Thigh = CCR*TPCKL1 Tlow = 2*CCR*TPCKL1

**快速模式中** Tlow/Thigh=16/9 **时：**

> Thigh = 9*CCR*TPCKL1 Tlow = 16*CCR*TPCKL1

例如，我们的PCLK1=36MHz，想要配置400Kbit/s的速率，计算方式如下：

PCLK时钟周期： TPCLK1 = 1/36000000

目标SCL时钟周期： TSCL = 1/400000

SCL时钟周期内的高电平时间： THIGH = TSCL/3

SCL时钟周期内的低电平时间： TLOW = 2*TSCL/3

计算CCR的值： CCR = THIGH/TPCLK1 = 30

计算结果得出CCR为30，向该寄存器位写入此值则可以控制IIC的通讯速率为400KHz，其实即使配置出来的SCL时钟不完全等于标准的400KHz， IIC通讯的正确性也不会受到影响，因为所有数据通讯都是由SCL协调的，只要它的时钟频率不远高于标准即可。

#### 24.2.2.3. 数据控制逻辑

I2C的SDA信号主要连接到数据移位寄存器上，数据移位寄存器的数据来源及目标是数据寄存器(DR)、地址寄存器(OAR)、PEC寄存器以及SDA数据线。 当向外发送数据的时候，数据移位寄存器以“数据寄存器”为数据源，把数据一位一位地通过SDA信号线发送出去；当从外部接收数据的时候， 数据移位寄存器把SDA信号线采样到的数据一位一位地存储到“数据寄存器”中。若使能了数据校验，接收到的数据会经过PCE计算器运算， 运算结果存储在“PEC寄存器”中。当STM32的I2C工作在从机模式的时候，接收到设备地址信号时， 数据移位寄存器会把接收到的地址与STM32的自身的“I2C地址寄存器”的值作比较，以便响应主机的寻址。 STM32的自身I2C地址可通过修改“自身地址寄存器”修改，支持同时使用两个I2C设备地址，两个地址分别存储在OAR1和OAR2中。

#### 24.2.2.4. 整体控制逻辑

整体控制逻辑负责协调整个I2C外设，控制逻辑的工作模式根据我们配置的“控制寄存器(CR1/CR2)”的参数而改变。在外设工作时， 控制逻辑会根据外设的工作状态修改“状态寄存器(SR1和SR2)”，我们只要读取这些寄存器相关的寄存器位，就可以了解I2C的工作状态。 除此之外，控制逻辑还根据要求，负责控制产生I2C中断信号、DMA请求及各种I2C的通讯信号(起始、停止、响应信号等)。

### 24.2.3. 通讯过程

使用I2C外设通讯时，在通讯的不同阶段它会对“状态寄存器(SR1及SR2)”的不同数据位写入参数，我们通过读取这些寄存器标志来了解通讯状态。

#### 24.2.3.1. 主发送器

见图 [主发送器通讯过程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id25) 。图中的是“主发送器”流程，即作为I2C通讯的主机端时，向外发送数据时的过程。

![主发送器通讯过程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C013.jpg)

主发送器发送流程及事件说明如下：

(1) 控制产生起始信号(S)，当发生起始信号后，它产生事件“EV5”， 并会对SR1寄存器的“SB”位置1，表示起始信号已经发送；

(2) 紧接着发送设备地址并等待应答信号，若有从机应答，则产生事件“EV6”及“EV8”， 这时SR1寄存器的“ADDR”位及“TXE”位被置1，ADDR 为1表示地址已经发送，TXE为1表示数据寄存器为空；

(3) 以上步骤正常执行并对ADDR位清零后，我们往I2C的“数据寄存器DR”写入要发送的数据， 这时TXE位会被重置0，表示数据寄存器非空，I2C外设通过SDA信号线一位位把数据发送出去后，又会产生“EV8”事件，即TXE位被置1，重复这个过程，就可以发送多个字节数据了；

(4) 当我们发送数据完成后，控制I2C设备产生一个停止信号(P)，这个时候会产生EV8_2事件， SR1的TXE位及BTF位都被置1，表示通讯结束。

假如我们使能了I2C中断，以上所有事件产生时，都会产生I2C中断信号，进入同一个中断服务函数，到I2C中断服务程序后，再通过检查寄存器位来判断是哪一个事件。

#### 24.2.3.2. 主接收器

再来分析主接收器过程，即作为I2C通讯的主机端时，从外部接收数据的过程，见图 [主接收器过程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id27) 。

![主接收器过程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C014.jpg)

主接收器接收流程及事件说明如下：

(1) 同主发送流程，起始信号(S)是由主机端产生的，控制发生起始信号后，它产生事件“EV5”， 并会对SR1寄存器的“SB”位置1，表示起始信号已经发送；

(2) 紧接着发送设备地址并等待应答信号，若有从机应答，则产生事件“EV6”这时SR1寄存器的“ADDR”位被置1， 表示地址已经发送。

(3) 从机端接收到地址后，开始向主机端发送数据。当主机接收到这些数据后，会产生“EV7”事件， SR1寄存器的RXNE被置1，表示接收数据寄存器非空，我们读取该寄存器后，可对数据寄存器清空， 以便接收下一次数据。此时我们可以控制I2C发送应答信号(ACK)或非应答信号(NACK)，若应答， 则重复以上步骤接收数据，若非应答，则停止传输；

(4) 发送非应答信号后， 产生停止信号(P)，结束传输。

在发送和接收过程中，有的事件不只是标志了我们上面提到的状态位，还可能同时标志主机状态之类的状态位，而且读了之后还需要清除标志位， 比较复杂。我们可使用STM32标准库函数来直接检测这些事件的复合标志，降低编程难度。

## 24.3. I2C初始化结构体详解

跟其它外设一样，STM32标准库提供了I2C初始化结构体及初始化函数来配置I2C外设。 初始化结构体及函数定义在库文件“stm32f10x_i2c.h”及“stm32f10x_i2c.c”中， 编程时我们可以结合这两个文件内的注释使用或参考库帮助文档。了解初始化结构体后我们就能对I2C外设运用自如了， 见 [代码清单:I2C-1](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-1) 。

代码清单:I2C-1 I2C初始化结构体[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-1 "永久链接至代码")

```c
typedef struct {
    uint32_t I2C_ClockSpeed; /*!< 设置SCL时钟频率，此值要低于400000*/
    uint16_t I2C_Mode;      /*!< 指定工作模式，可选I2C模式及SMBUS模式 */
    uint16_t I2C_DutyCycle; /*指定时钟占空比，可选low/high = 2:1及16:9模式*/
    uint16_t I2C_OwnAddress1;     /*!< 指定自身的I2C设备地址 */
    uint16_t I2C_Ack;                 /*!< 使能或关闭响应(一般都要使能) */
    uint16_t I2C_AcknowledgedAddress; /*!< 指定地址的长度，可为7位及10位 */
} I2C_InitTypeDef;
```
这些结构体成员说明如下，其中括号内的文字是对应参数在STM32标准库中定义的宏：

1. I2C_ClockSpeed
    

本成员设置的是I2C的传输速率，在调用初始化函数时，函数会根据我们输入的数值经过运算后把时钟因子写入到I2C的时钟控制寄存器CCR。 而我们写入的这个参数值不得高于400KHz。实际上由于CCR寄存器不能写入小数类型的时钟因子，影响到SCL的实际频率可能会低于本成员设置的参数值， 这时除了通讯稍慢一点以外，不会对I2C的标准通讯造成其它影响。

2. I2C_Mode
    

本成员是选择I2C的使用方式，有I2C模式(I2C_Mode_I2C)和SMBus主、 从模式(I2C_Mode_SMBusHost、 I2C_Mode_SMBusDevice ) 。 I2C不需要在此处区分主从模式，直接设置I2C_Mode_I2C即可。

3. I2C_DutyCycle
    

本成员设置的是I2C的SCL线时钟的占空比。该配置有两个选择， 分别为低电平时间比高电平时间为2：1 ( I2C_DutyCycle_2)和16：9 (I2C_DutyCycle_16_9)。 其实这两个模式的比例差别并不大，一般要求都不会如此严格，这里随便选就可以。

4. I2C_OwnAddress1
    

本成员配置的是STM32的I2C设备自己的地址，每个连接到I2C总线上的设备都要有一个自己的地址，作为主机也不例外。 地址可设置为7位或10位(受下面I2C_AcknowledgeAddress成员决定)，只要该地址是I2C总线上唯一的即可。

STM32的I2C外设可同时使用两个地址，即同时对两个地址作出响应，这个结构成员I2C_OwnAddress1配置的是默认的、OAR1寄存器存储的地址， 若需要设置第二个地址寄存器OAR2，可使用I2C_OwnAddress2Config函数来配置，OAR2不支持10位地址，只有7位。

5. I2C_Ack_Enable
    

本成员是关于I2C应答设置，设置为使能则可以发送响应信号。本实验配置为允许应答(I2C_Ack_Enable)， 这是绝大多数遵循I2C标准的设备的通讯要求，改为禁止应答(I2C_Ack_Disable)往往会导致通讯错误。

6. I2C_AcknowledgeAddress
    

本成员选择I2C的寻址模式是7位还是10位地址。这需要根据实际连接到I2C总线上设备的地址进行选择，这个成员的配置也影响到I2C_OwnAddress1成员， 只有这里设置成10位模式时，I2C_OwnAddress1才支持10位地址。

配置完这些结构体成员值，调用库函数I2C_Init即可把结构体的配置写入到寄存器中。

## 24.4. I2C—读写EEPROM实验

EEPROM是一种掉电后数据不丢失的存储器，常用来存储一些配置信息，以便系统重新上电的时候加载之。 EEPOM芯片最常用的通讯方式就是I2C协议， 本小节以EEPROM的读写实验为大家讲解STM32的I2C使用方法。 实验中STM32的I2C外设采用主模式，分别用作主发送器和主接收器，通过查询事件的方式来确保正常通讯。

### 24.4.1. 硬件设计
![EEPROM硬件连接图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C015.png)

本实验板中的EEPROM芯片(型号：AT24C02)的SCL及SDA引脚连接到了STM32对应的I2C引脚中，结合上拉电阻， 构成了I2C通讯总线，它们通过I2C总线交互。EEPROM芯片的设备地址一共有7位，其中高4位固定为：1010 b， 低3位则由A0/A1/A2信号线的电平决定，见图 [EEPROM设备地址](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id31) ，图中的R/W是读写方向位，与地址无关。

![EEPROM设备地址](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C016.jpg)

按照我们此处的连接，A0/A1/A2均为0，所以EEPROM的7位设备地址是：101 0000b，即0x50。 由于I2C通讯时常常是地址跟读写方向连在一起构成一个8位数，且当R/W位为0时，表示写方向， 所以加上7位地址，其值为“0xA0”，常称该值为I2C设备的“写地址”；当R/W位为1时，表示读方向， 加上7位地址，其值为“0xA1”，常称该值为“读地址”。

EEPROM芯片中还有一个WP引脚，具有写保护功能，当该引脚电平为高时，禁止写入数据，当引脚为低电平时， 可写入数据，我们直接接地，不使用写保护功能。

关于EEPROM的更多信息，可参考其数据手册《AT24C02》来了解。若您使用的实验板EEPROM的型号、 设备地址或控制引脚不一样，只需根据我们的工程修改即可，程序的控制原理相同。

### 24.4.2. 软件设计

为了使工程更加有条理，我们把读写EEPROM相关的代码独立分开存储，方便以后移植。 在“工程模板”之上新建“bsp_i2c_ee.c”及“bsp_i2c_ee.h”文件，这些文件也可根据您的喜好命名， 它们不属于STM32标准库的内容，是由我们自己根据应用需要编写的。

#### 24.4.2.1. 编程要点[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id33 "永久链接至标题")

1. 配置通讯使用的目标引脚为开漏模式；
    
2. 使能I2C外设的时钟；
    
3. 配置I2C外设的模式、地址、速率等参数并使能I2C外设；
    
4. 编写基本I2C按字节收发的函数；
    
5. 编写读写EEPROM存储内容的函数；
    
6. 编写测试程序，对读写数据进行校验。
    

#### 24.4.2.2. 代码分析

I2C硬件相关宏定义

我们把I2C硬件相关的配置都以宏的形式定义到 “bsp_i2c_ee.h”文件中，见 [代码清单:I2C-2](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-2) 。

代码清单:I2C-2 I2C硬件配置相关的宏[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-2 "永久链接至代码")

```c
/**************************I2C参数定义，I2C1或I2C2*********************/
#define       EEPROM_I2Cx                       I2C1
#define       EEPROM_I2C_APBxClock_FUN          RCC_APB1PeriphClockCmd
#define       EEPROM_I2C_CLK                    RCC_APB1Periph_I2C1
#define       EEPROM_I2C_GPIO_APBxClock_FUN     RCC_APB2PeriphClockCmd
#define                     EEPROM_I2C_GPIO_CLK         RCC_APB2Periph_GPIOB
#define             EEPROM_I2C_SCL_PORT                        GPIOB
#define             EEPROM_I2C_SCL_PIN                         GPIO_Pin_6
#define             EEPROM_I2C_SDA_PORT                        GPIOB
#define             EEPROM_I2C_SDA_PIN                         GPIO_Pin_7

/* STM32 I2C 快速模式 */
#define I2C_Speed              400000  //*

/* 这个地址只要与STM32外挂的I2C器件地址不一样即可 */
#define I2Cx_OWN_ADDRESS7      0X0A

/* AT24C01/02每页有8个字节 */
#define I2C_PageSize           8
```
以上代码根据硬件连接，把与EEPROM通讯使用的I2C号 、引脚号都以宏封装起来，并且定义了自身的I2C地址及通讯速率，以便配置模式的时候使用。

**初始化I2C的 GPIO**

利用上面的宏，编写I2C GPIO引脚的初始化函数，见 [代码清单:I2C-3](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-3) 。

代码清单:I2C-3 I2C GPIO初始化函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-3 "永久链接至代码")

```C
static void I2C_GPIO_Config(void)
{
    GPIO_InitTypeDef  GPIO_InitStructure;

    /* 使能与 I2C 有关的时钟 */
    EEPROM_I2C_APBxClock_FUN ( EEPROM_I2C_CLK, ENABLE );
    EEPROM_I2C_GPIO_APBxClock_FUN ( EEPROM_I2C_GPIO_CLK, ENABLE );

    /* I2C_SCL、I2C_SDA*/
    GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SCL_PIN;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;        // 开漏输出
    GPIO_Init(EEPROM_I2C_SCL_PORT, &GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin = EEPROM_I2C_SDA_PIN;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;        // 开漏输出
    GPIO_Init(EEPROM_I2C_SDA_PORT, &GPIO_InitStructure);
}
```
开启相关的时钟并初始化GPIO引脚，函数执行流程如下：

(1) 使用GPIO_InitTypeDef定义GPIO初始化结构体变量， 以便下面用于存储GPIO配置；

(2) 调用库函数RCC_APB1PeriphClockCmd（代码中为宏EEPROM_I2C_APBxClock_FUN）使能I2C外设时钟， 调用RCC_APB2PeriphClockCmd（代码中为宏EEPROM_I2C_GPIO_APBxClock_FUN）来使能I2C引脚使用的GPIO端口时钟， 调用时我们使用“|”操作同时配置两个引脚。

(3) 向GPIO初始化结构体赋值，把引脚初始化成复用开漏模式， 要注意I2C的引脚必须使用这种模式。

(4) 使用以上初始化结构体的配置， 调用GPIO_Init函数向寄存器写入参数，完成GPIO的初始化。

**配置I2C的模式**

以上只是配置了I2C使用的引脚，还不算对I2C模式的配置，见 [代码清单:I2C-4](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-4) 。

代码清单:I2C-4 配置I2C模式[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-4 "永久链接至代码")

```C
/**
* @brief  I2C 工作模式配置
* @param  无
* @retval 无
*/
static void I2C_Mode_Configu(void)
{
    I2C_InitTypeDef  I2C_InitStructure;

    /* I2C 配置 */
    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;

    /* 高电平数据稳定，低电平数据变化 SCL 时钟线的占空比 */
    I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;

    I2C_InitStructure.I2C_OwnAddress1 =I2Cx_OWN_ADDRESS7;
    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable ;

    /* I2C的寻址模式 */
I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;

    /* 通信速率 */
    I2C_InitStructure.I2C_ClockSpeed = I2C_Speed;

    /* I2C 初始化 */
    I2C_Init(EEPROM_I2Cx, &I2C_InitStructure);

    /* 使能 I2C */
    I2C_Cmd(EEPROM_I2Cx, ENABLE);
}

/**
* @brief  I2C 外设(EEPROM)初始化
* @param  无
* @retval 无
*/
void I2C_EE_Init(void)
{
    I2C_GPIO_Config();

    I2C_Mode_Configu();

    /* 根据头文件i2c_ee.h中的定义来选择EEPROM要写入的设备地址  */
    /* 选择 EEPROM Block0 来写入 */
    EEPROM_ADDRESS = EEPROM_Block0_ADDRESS;
}
```
熟悉STM32 I2C结构的话，这段初始化程序就十分好理解，它把I2C外设通讯时钟SCL的低/高电平比设置为2，使能响应功能， 使用7位地址I2C_OWN_ADDRESS7以及速率配置为I2C_Speed(前面在bsp_i2c_ee.h定义的宏)。最后调用库函数I2C_Init把这些配置写入寄存器， 并调用I2C_Cmd函数使能外设。

为方便调用，我们把I2C的GPIO及模式配置都用I2C_EE_Init函数封装起来。

**向EEPROM写入一个字节的数据**

初始化好I2C外设后，就可以使用I2C通讯，我们看看如何向EEPROM写入一个字节的数据，见 [代码清单:I2C-5](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-5) 。

代码清单:I2C-5 向EEPROM写入一个字节的数据[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-5 "永久链接至代码")

```C
/***************************************************************/
/*通讯等待超时时间*/
#define I2CT_FLAG_TIMEOUT   ((uint32_t)0x1000)
#define I2CT_LONG_TIMEOUT   ((uint32_t)(10 * I2CT_FLAG_TIMEOUT))

/**
* @brief  I2C等待事件超时的情况下会调用这个函数来处理
* @param  errorCode：错误代码，可以用来定位是哪个环节出错.
* @retval 返回0，表示IIC读取失败.
*/
static  uint32_t I2C_TIMEOUT_UserCallback(uint8_t errorCode)
{
    /* 使用串口printf输出错误信息，方便调试 */
    EEPROM_ERROR("I2C 等待超时!errorCode = %d",errorCode);
    return 0;
}
/**
* @brief   写一个字节到I2C EEPROM中
* @param   pBuffer:缓冲区指针
* @param   WriteAddr:写地址
* @retval  正常返回1，异常返回0
*/
uint32_t I2C_EE_ByteWrite(u8* pBuffer, u8 WriteAddr)
{
    /* 产生I2C起始信号 */
    I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);

    /*设置超时等待时间*/
    I2CTimeout = I2CT_FLAG_TIMEOUT;
    /* 检测 EV5 事件并清除标志*/
    while (!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(0);
    }

    /* 发送EEPROM设备地址 */
    I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS,
                        I2C_Direction_Transmitter);

    I2CTimeout = I2CT_FLAG_TIMEOUT;
    /* 检测 EV6 事件并清除标志*/
    while (!I2C_CheckEvent(EEPROM_I2Cx,
                        I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(1);
    }

    /* 发送要写入的EEPROM内部地址(即EEPROM内部存储器的地址) */
    I2C_SendData(EEPROM_I2Cx, WriteAddr);

    I2CTimeout = I2CT_FLAG_TIMEOUT;
    /* 检测 EV8 事件并清除标志*/
    while (!I2C_CheckEvent(EEPROM_I2Cx,
                        I2C_EVENT_MASTER_BYTE_TRANSMITTED))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(2);
    }
    /* 发送一字节要写入的数据 */
    I2C_SendData(EEPROM_I2Cx, *pBuffer);

    I2CTimeout = I2CT_FLAG_TIMEOUT;
    /* 检测 EV8 事件并清除标志*/
    while (!I2C_CheckEvent(EEPROM_I2Cx,
                        I2C_EVENT_MASTER_BYTE_TRANSMITTED))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(3);
    }

    /* 发送停止信号 */
    I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);

    return 1;
}
```
先来分析I2C_TIMEOUT_UserCallback函数，它的函数体里只调用了宏EEPROM_ERROR，这个宏封装了printf函数， 方便使用串口向上位机打印调试信息，阅读代码时把它当成printf函数即可。在I2C通讯的很多过程，都需要检测事件， 当检测到某事件后才能继续下一步的操作，但有时通讯错误或者I2C总线被占用，我们不能无休止地等待下去， 所以我们设定每个事件检测都有等待的时间上限，若超过这个时间，我们就调用I2C_TIMEOUT_UserCallback函数输出调试信息(或可以自己加其它操作)，并终止I2C通讯。

了解了这个机制，再来分析I2C_EE_ByteWrite函数，这个函数实现了前面讲的I2C主发送器通讯流程

(1) 使用库函数I2C_GenerateSTART产生I2C起始信号， 其中的EEPROM_I2C宏是前面硬件定义相关的I2C编号；

(2) 对I2CTimeout变量赋值为宏I2CT_FLAG_TIMEOUT，这个I2CTimeout变量在下面的while循环中每次循环减1， 该循环通过调用库函数I2C_CheckEvent检测事件，若检测到事件，则进入通讯的下一阶段，若未检测到事件则停留在此处一直检测， 当检测I2CT_FLAG_TIMEOUT次都还没等待到事件则认为通讯失败，调用前面的I2C_TIMEOUT_UserCallback输出调试信息，并退出通讯；

(3) 调用库函数I2C_Send7bitAddress发送EEPROM的设备地址， 并把数据传输方向设置为I2C_Direction_Transmitter(即发送方向)， 这个数据传输方向就是通过设置I2C通讯中紧跟地址后面的R/W位实现的。发送地址后以同样的方式检测EV6标志；

(4) 调用库函数I2C_SendData向EEPROM发送要写入的内部地址， 该地址是I2C_EE_ByteWrite函数的输入参数，发送完毕后等待EV8事件。 要注意这个内部地址跟上面的EEPROM地址不一样，上面的是指I2C总线设备的独立地址，而此处的内部地址是指EEPROM内数据组织的地址， 也可理解为EEPROM内存的地址或I2C设备的寄存器地址；

(5) 调用库函数I2C_SendData向EEPROM发送要写入的数据， 该数据是I2C_EE_ByteWrite函数的输入参数，发送完毕后等待EV8事件；

(6) 一个I2C通讯过程完毕， 调用I2C_GenerateSTOP发送停止信号。

在这个通讯过程中，STM32实际上通过I2C向EEPROM发送了两个数据，但为何第一个数据被解释为EEPROM的内存地址？ 这是由EEPROM的自己定义的单字节写入时序，见图 [EEPROM单字节写入时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id35) 。

![EEPROM单字节写入时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C017.jpg)

EEPROM的单字节时序规定，向它写入数据的时候，第一个字节为内存地址，第二个字节是要写入的数据内容。 所以我们需要理解：命令、地址的本质都是数据，对数据的解释不同，它就有了不同的功能。

**多字节写入及状态等待**

单字节写入通讯结束后，EEPROM芯片会根据这个通讯结果擦写该内存地址的内容，这需要一段时间，所以我们在多次写入数据时， 要先等待EEPROM内部擦写完毕。多个数据写入过程见 [代码清单:I2C-6](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-6) 。

代码清单:I2C-6 多字节写入[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-6 "永久链接至代码")

```C
/**
* @brief   将缓冲区中的数据写到I2C EEPROM中，采用单字节写入的方式，
            速度比页写入慢
* @param  pBuffer:缓冲区指针
* @param  WriteAddr:写地址
* @param  NumByteToWrite:写的字节数
* @retval  无
*/
uint8_t I2C_EE_ByetsWrite(uint8_t* pBuffer,uint8_t WriteAddr,
                        uint16_t NumByteToWrite)
{
    uint16_t i;
    uint8_t res;

    /*每写一个字节调用一次I2C_EE_ByteWrite函数*/
    for (i=0; i<NumByteToWrite; i++)
    {
        /*等待EEPROM准备完毕*/
        I2C_EE_WaitEepromStandbyState();
        /*按字节写入数据*/
        res = I2C_EE_ByteWrite(pBuffer++,WriteAddr++);
    }
    return res;
}
```
这段代码比较简单，直接使用for循环调用前面定义的I2C_EE_ByteWrite函数一个字节一个字节地向EEPROM发送要写入的数据。 在每次数据写入通讯前调用了I2C_EE_WaitEepromStandbyState函数等待EEPROM内部擦写完毕， 该函数的定义见 [代码清单:I2C-7](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-7) 。

代码清单:I2C-7 等待EEPROM处于准备状态[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-7 "永久链接至代码")

```C
/**
* @brief  等待EEPROM到准备状态
* @param  无
* @retval 无
*/
void I2C_EE_WaitEepromStandbyState(void)
{
    vu16 SR1_Tmp = 0;

    do {
        /* 发送起始信号 */
        I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);

        /* 读 I2C1 SR1 寄存器 */
        SR1_Tmp = I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1);

        /* 发送 EEPROM 地址 + 写方向 */
        I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS,
                            I2C_Direction_Transmitter);
    }
    // SR1 位1 ADDR：1 表示地址发送成功，0表示地址发送没有结束
    // 等待地址发送成功
    while (!(I2C_ReadRegister(EEPROM_I2Cx, I2C_Register_SR1) & 0x0002));

    /* 清除 AF 位 */
    I2C_ClearFlag(EEPROM_I2Cx, I2C_FLAG_AF);
    /* 发送停止信号 */
    I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);
}
```
这个函数主要实现是向EEPROM发送它设备地址，检测EEPROM的响应，若EEPROM接收到地址后返回应答信号，则表示EEPROM已经准备好， 可以开始下一次通讯。函数中检测响应是通过读取STM32的SR1寄存器的ADDR位及AF位来实现的，当I2C设备响应了地址的时候，ADDR会置1， 若应答失败，AF位会置1。

**EEPROM的页写入**

在以上的数据通讯中，每写入一个数据都需要向EEPROM发送写入的地址，我们希望向连续地址写入多个数据的时候， 只要告诉EEPROM第一个内存地址address1，后面的数据按次序写入到address2、address3… 这样可以节省通讯的时间， 加快速度。为应对这种需求，EEPROM定义了一种页写入时序，见图 [EEPROM页写入时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id36) 。

![EEPROM页写入时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C018.jpg)

根据页写入时序，第一个数据被解释为要写入的内存地址address1，后续可连续发送n个数据，这些数据会依次写入到内存中。 其中AT24C02型号的芯片页写入时序最多可以一次发送8个数据(即n = 8 )，该值也称为页大小， 某些型号的芯片每个页写入时序最多可传输16个数据。EEPROM的页写入代码实现见 [代码清单:I2C-8](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-8) 。

代码清单:I2C-8 EEPROM的页写入[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-8 "永久链接至代码")

```C
/**
* @brief   在EEPROM的一个写循环中可以写多个字节，但一次写入的字节数
*          不能超过EEPROM页的大小，AT24C02每页有8个字节
* @param
* @param    pBuffer:缓冲区指针
* @param    WriteAddr:写地址
* @param    NumByteToWrite:要写的字节数要求NumByToWrite小于页大小
* @retval  正常返回1，异常返回0
*/
uint8_t I2C_EE_PageWrite(uint8_t* pBuffer, uint8_t WriteAddr,
                        uint8_t NumByteToWrite)
{
    I2CTimeout = I2CT_LONG_TIMEOUT;

    while (I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(4);
    }

    /* 产生I2C起始信号 */
    I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);

    I2CTimeout = I2CT_FLAG_TIMEOUT;

    /* 检测 EV5 事件并清除标志 */
    while (!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(5);
    }

    /* 发送EEPROM设备地址  */
    I2C_Send7bitAddress(EEPROM_I2Cx,EEPROM_ADDRESS,I2C_Direction_Transmitter);

    I2CTimeout = I2CT_FLAG_TIMEOUT;

    /* 检测 EV6 事件并清除标志*/
    while (!I2C_CheckEvent(EEPROM_I2Cx,
                        I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(6);
    }
    /* 发送要写入的EEPROM内部地址(即EEPROM内部存储器的地址) */
    I2C_SendData(EEPROM_I2Cx, WriteAddr);

    I2CTimeout = I2CT_FLAG_TIMEOUT;

    /* 检测 EV8 事件并清除标志*/
    while (! I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(7);
    }
    /* 循环发送NumByteToWrite个数据 */
    while (NumByteToWrite--)
    {
        /* 发送缓冲区中的数据 */
        I2C_SendData(EEPROM_I2Cx, *pBuffer);

        /* 指向缓冲区中的下一个数据 */
        pBuffer++;

        I2CTimeout = I2CT_FLAG_TIMEOUT;

        /* 检测 EV8 事件并清除标志*/
        while (!I2C_CheckEvent(EEPROM_I2Cx, _EVENT_MASTER_BYTE_TRANSMITTED))
        {
            if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(8);
        }
    }
    /* 发送停止信号 */
    I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);
    return 1;
}
```
这段页写入函数主体跟单字节写入函数是一样的，只是它在发送数据的时候，使用for循环控制发送多个数据，发送完多个数据后才产生I2C停止信号， 只要每次传输的数据小于等于EEPROM时序规定的页大小，就能正常传输。

快速写入多字节

利用EEPROM的页写入方式，可以改进前面的“多字节写入”函数，加快传输速度，见 [代码清单:I2C-9](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-9) 。

代码清单:I2C-9 快速写入多字节函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-9 "永久链接至代码")

```C
// AT24C01/02每页有8个字节
#define I2C_PageSize        8

/**
* @brief   将缓冲区中的数据写到I2C EEPROM中
* @param
*   @arg pBuffer:缓冲区指针
*   @arg WriteAddr:写地址
*     @arg NumByteToWrite:写的字节数
* @retval  无
*/
void I2C_EE_BufferWrite(u8* pBuffer, u8 WriteAddr,
                        u16 NumByteToWrite)
{
    u8 NumOfPage=0,NumOfSingle=0,Addr =0,count=0,temp =0;

    /*mod运算求余，若writeAddr是I2C_PageSize整数倍，
    运算结果Addr值为0*/
    Addr = WriteAddr % I2C_PageSize;

    /*差count个数据值，刚好可以对齐到页地址*/
    count = I2C_PageSize - Addr;

    /*计算出要写多少整数页*/
    NumOfPage =  NumByteToWrite / I2C_PageSize;

    /*mod运算求余，计算出剩余不满一页的字节数*/
    NumOfSingle = NumByteToWrite % I2C_PageSize;

    // Addr=0,则WriteAddr 刚好按页对齐 aligned
    // 这样就很简单了，直接写就可以，写完整页后
    // 把剩下的不满一页的写完即可
    if (Addr == 0) {
        /* 如果 NumByteToWrite < I2C_PageSize */
        if (NumOfPage == 0) {
            I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
            I2C_EE_WaitEepromStandbyState();
        }
        /* 如果 NumByteToWrite > I2C_PageSize */
        else {
            /*先把整数页都写了*/
            while (NumOfPage--) {
                I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize);
                I2C_EE_WaitEepromStandbyState();
                WriteAddr +=  I2C_PageSize;
                pBuffer += I2C_PageSize;
            }
            /*若有多余的不满一页的数据，把它写完*/
            if (NumOfSingle!=0) {
                I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
                I2C_EE_WaitEepromStandbyState();
            }
        }
    }
    // 如果 WriteAddr 不是按 I2C_PageSize 对齐
    // 那就算出对齐到页地址还需要多少个数据，然后
    // 先把这几个数据写完，剩下开始的地址就已经对齐
    // 到页地址了，代码重复上面的即可
    else {
        /* 如果 NumByteToWrite < I2C_PageSize */
        if (NumOfPage== 0) {
            /*若NumOfSingle>count，当前面写不完，要写到下一页*/
            if (NumOfSingle > count) {
                // temp的数据要写到写一页
                temp = NumOfSingle - count;

                I2C_EE_PageWrite(pBuffer, WriteAddr, count);
                I2C_EE_WaitEepromStandbyState();
                WriteAddr +=  count;
                pBuffer += count;

                I2C_EE_PageWrite(pBuffer, WriteAddr, temp);
                I2C_EE_WaitEepromStandbyState();
            } else { /*若count比NumOfSingle大*/
                I2C_EE_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
                I2C_EE_WaitEepromStandbyState();
            }
        }
        /* 如果 NumByteToWrite > I2C_PageSize */
        else {
            /*地址不对齐多出的count分开处理，不加入这个运算*/
            NumByteToWrite -= count;
            NumOfPage =  NumByteToWrite / I2C_PageSize;
            NumOfSingle = NumByteToWrite % I2C_PageSize;

            /*先把WriteAddr所在页的剩余字节写了*/
            if (count != 0) {
                I2C_EE_PageWrite(pBuffer, WriteAddr, count);
                I2C_EE_WaitEepromStandbyState();

                /*WriteAddr加上count后，地址就对齐到页了*/
                WriteAddr += count;
                pBuffer += count;
            }
            /*把整数页都写了*/
            while (NumOfPage--) {
                I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize);
                I2C_EE_WaitEepromStandbyState();
                WriteAddr +=  I2C_PageSize;
                pBuffer += I2C_PageSize;
            }
            /*若有多余的不满一页的数据，把它写完*/
            if (NumOfSingle != 0) {
                I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
                I2C_EE_WaitEepromStandbyState();
            }
        }
    }
}
```
很多读者觉得这段代码的运算很复杂，看不懂，其实它的主旨就是对输入的数据进行分页(本型号芯片每页8个字节)，见表 [首地址对齐到页时的情况](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id37) 。 通过“整除”计算要写入的数据NumByteToWrite能写满多少“完整的页”，计算得的值存储在NumOfPage中，但有时数据不是刚好能写满完整页的， 会多一点出来，通过“求余”计算得出“不满一页的数据个数”就存储在NumOfSingle中。计算后通过按页传输NumOfPage次整页数据及最后的NumOfSing个数据， 使用页传输，比之前的单个字节数据传输要快很多。

除了基本的分页传输，还要考虑首地址的问题，见表 24‑3。若首地址不是刚好对齐到页的首地址，会需要一个count值， 用于存储从该首地址开始写满该地址所在的页，还能写多少个数据。实际传输时，先把这部分count个数据先写入，填满该页， 然后把剩余的数据(NumByteToWrite-count)，再重复上述求出NumOPage及NumOfSingle的过程，按页传输到EEPROM。

1. 若writeAddress=16，计算得Addr=16%8= 0 ，count=8-0= 8；
    
2. 同时，若NumByteToWrite=22，计算得NumOfPage=22/8= 2，NumOfSingle=22%8= 6。
    
3. 数据传输情况如表 [首地址未对齐到页时的情况](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id38)
    

![首地址对齐到页时的情况](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C02.jpg)

4. 若writeAddress=17，计算得Addr=17%8= 1，count=8-1= 7；
    
5. 同时，若NumByteToWrite=22，
    
6. 先把count去掉，特殊处理，计算得新的NumByteToWrite=22-7= 15
    
7. 计算得NumOfPage=15/8= 1，NumOfSingle=15%8= 7。
    
8. 数据传输情况如表 [首地址未对齐到页时的情况](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id38)
    

![首地址未对齐到页时的情况](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C03.jpg)

最后，强调一下，EEPROM支持的页写入只是一种加速的I2C的传输时序，实际上并不要求每次都以页为单位进行读写， EEPROM是支持随机访问的(直接读写任意一个地址)，如前面的单个字节写入。在某些存储器，如NAND FLASH， 它是必须按照Block写入的，例如每个Block为512或4096字节，数据写入的最小单位是Block， 写入前都需要擦除整个Block；NOR FLASH则是写入前必须以Sector/Block为单位擦除，然后才可以按字节写入。 而我们的EEPROM数据写入和擦除的最小单位是“字节”而不是“页”，数据写入前不需要擦除整页。

**从EEPROM读取数据**

从EEPROM读取数据是一个复合的I2C时序，它实际上包含一个写过程和一个读过程，见图 [EEPROM数据读取时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id39) 。

![EEPROM数据读取时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C019.jpg)

读时序的第一个通讯过程中，使用I2C发送设备地址寻址(写方向)，接着发送要读取的“内存地址”；第二个通讯过程中， 再次使用I2C发送设备地址寻址，但这个时候的数据方向是读方向；在这个过程之后，EEPROM会向主机返回从“内存地址”开始的数据， 一个字节一个字节地传输，只要主机的响应为“应答信号”，它就会一直传输下去，主机想结束传输时，就发送“非应答信号”， 并以“停止信号”结束通讯，作为从机的EEPROM也会停止传输。实现代码见 [代码清单:I2C-10](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-10) 。

代码清单:I2C-10 从EEPROM读取数据[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-10 "永久链接至代码")

```C
/**
* @brief   从EEPROM里面读取一块数据
* @param  pBuffer:存放从EEPROM读取的数据的缓冲区指针
* @param  ReadAddr:接收数据的EEPROM的地址
* @param  NumByteToRead:要从EEPROM读取的字节数
* @retval  正常返回1，异常返回0
*/
uint8_t I2C_EE_BufferRead(uint8_t* pBuffer, uint8_t ReadAddr,
                        u16 NumByteToRead)
{
    I2CTimeout = I2CT_LONG_TIMEOUT;

    while (I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_BUSY))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(9);
    }

    /* 产生I2C起始信号 */
    I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);

    I2CTimeout = I2CT_FLAG_TIMEOUT;

    /* 检测 EV5 事件并清除标志*/
    while (!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(10);
    }

    /* 发送EEPROM设备地址 */
    I2C_Send7bitAddress(EEPROM_I2Cx,EEPROM_ADDRESS,I2C_Direction_Transmitter);

    I2CTimeout = I2CT_FLAG_TIMEOUT;

    /* 检测 EV6 事件并清除标志*/
    while (!I2C_CheckEvent(EEPROM_I2Cx,
                        I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(11);
    }
    /*通过重新设置PE位清除EV6事件 */
    I2C_Cmd(EEPROM_I2Cx, ENABLE);

    /* 发送要读取的EEPROM内部地址(即EEPROM内部存储器的地址) */
    I2C_SendData(EEPROM_I2Cx, ReadAddr);

    I2CTimeout = I2CT_FLAG_TIMEOUT;

    /* 检测 EV8 事件并清除标志*/
    while (!I2C_CheckEvent(EEPROM_I2Cx,I2C_EVENT_MASTER_BYTE_TRANSMITTED))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(12);
    }
    /* 产生第二次I2C起始信号 */
    I2C_GenerateSTART(EEPROM_I2Cx, ENABLE);

    I2CTimeout = I2CT_FLAG_TIMEOUT;

    /* 检测 EV5 事件并清除标志*/
    while (!I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(13);
    }
    /* 发送EEPROM设备地址 */
    I2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS, I2C_Direction_Receiver);

    I2CTimeout = I2CT_FLAG_TIMEOUT;

    /* 检测 EV6 事件并清除标志*/
    while (!I2C_CheckEvent(EEPROM_I2Cx,
                        I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
    {
        if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(14);
    }
    /* 读取NumByteToRead个数据*/
    while (NumByteToRead)
    {
        /*若NumByteToRead=1，表示已经接收到最后一个数据了，
        发送非应答信号，结束传输*/
        if (NumByteToRead == 1)
        {
            /* 发送非应答信号 */
            I2C_AcknowledgeConfig(EEPROM_I2Cx, DISABLE);

            /* 发送停止信号 */
            I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE);
        }

        I2CTimeout = I2CT_LONG_TIMEOUT;
        while (I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED)==0)
        {
            if ((I2CTimeout--) == 0) return I2C_TIMEOUT_UserCallback(3);
        }
        {
            /*通过I2C，从设备中读取一个字节的数据 */
            *pBuffer = I2C_ReceiveData(EEPROM_I2Cx);

            /* 存储数据的指针指向下一个地址 */
            pBuffer++;

            /* 接收数据自减 */
            NumByteToRead--;
        }
    }

    /* 使能应答，方便下一次I2C传输 */
    I2C_AcknowledgeConfig(EEPROM_I2Cx, ENABLE);
    return 1;
}
```
这段中的写过程跟前面的写字节函数类似，而读过程中接收数据时，需要使用库函数I2C_ReceiveData来读取。 响应信号则通过库函数I2C_AcknowledgeConfig来发送，DISABLE时为非响应信号，ENABLE为响应信号。

#### 24.4.2.3. main文件[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#main "永久链接至标题")

**EEPROM读写测试函数**

完成基本的读写函数后，接下来我们编写一个读写测试函数来检验驱动程序，见 [代码清单:I2C-11](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-11) 。

代码清单:I2C-11 EEPROM读写测试函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-11 "永久链接至代码")

```C
/**
* @brief  I2C(AT24C02)读写测试
* @param  无
* @retval 正常返回1 ，不正常返回0
*/
uint8_t I2C_Test(void)
{
    u16 i;
    EEPROM_INFO("写入的数据");

    for ( i=0; i<=255; i++ ) //填充缓冲
    {
        I2c_Buf_Write[i] = i;

        printf("0x%02X ", I2c_Buf_Write[i]);
        if (i%16 == 15)
            printf("\n\r");
    }

    //将I2c_Buf_Write中顺序递增的数据写入EERPOM中
    //页写入方式
//  I2C_EE_BufferWrite( I2c_Buf_Write, EEP_Firstpage, 256);
    //字节写入方式
    I2C_EE_ByetsWrite( I2c_Buf_Write, EEP_Firstpage, 256);

    EEPROM_INFO("写结束");

    EEPROM_INFO("读出的数据");
    //将EEPROM读出数据顺序保持到I2c_Buf_Read中
    I2C_EE_BufferRead(I2c_Buf_Read, EEP_Firstpage, 256);

    //将I2c_Buf_Read中的数据通过串口打印
    for (i=0; i<256; i++)
    {
        if (I2c_Buf_Read[i] != I2c_Buf_Write[i])
        {
            printf("0x%02X ", I2c_Buf_Read[i]);
            EEPROM_ERROR("错误:I2C EEPROM写入与读出的数据不一致");
            return 0;
        }
        printf("0x%02X ", I2c_Buf_Read[i]);
        if (i%16 == 15)
            printf("\n\r");

    }
    EEPROM_INFO("I2C(AT24C02)读写测试成功");
    return 1;
}
```
代码中先填充一个数组，数组的内容为1,2,3至N，接着把这个数组的内容写入到EEPROM中，写入时可以采用单字节写入的方式或页写入的方式。 写入完毕后再从EEPROM的地址中读取数据，把读取得到的与写入的数据进行校验，若一致说明读写正常，否则读写过程有问题或者EEPROM芯片不正常。 其中代码用到的EEPROM_INFO跟EEPROM_ERROR宏类似，都是对printf函数的封装，使用和阅读代码时把它直接当成printf函数就好。 具体的宏定义在“bsp_i2c_ee.h文件中”，在以后的代码我们常常会用类似的宏来输出调试信息。

**main函数**

最后编写main函数，函数中初始化串口、I2C外设，然后调用上面的I2C_Test函数进行读写测试，见 [代码清单:I2C-12](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-12) 。

代码清单:I2C-12 main函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#i2c-12 "永久链接至代码")

```C
/**
* @brief  主函数
* @param  无
* @retval 无
*/
int main(void)
{
    LED_GPIO_Config();

    LED_BLUE;
    /*初始化USART1*/
    Debug_USART_Config();

    printf("\r\n 欢迎使用野火  STM32 F103 开发板。\r\n");

    printf("\r\n 这是一个I2C外设(AT24C02)读写测试例程 \r\n");

    /* I2C 外设(AT24C02)初始化 */
    I2C_EE_Init();

    if (I2C_Test() ==1)
    {
        LED_GREEN;
    }
    else
    {
        LED_RED;
    }

    while (1)
    {
    }

}
```
### 24.4.3. 下载验证[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/I2C.html#id40 "永久链接至标题")

用USB线连接开发板“USB TO UART”接口跟电脑，在电脑端打开串口调试助手， 把编译好的程序下载到开发板。在串口调试助手可看到EEPROM测试的调试信息。

![EEPROM测试成功](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/I2C020.png)






# 25. SPI—读写串行FLASH

本章参考资料：《STM32F10X-中文参考手册》SPI章节及《SPI总线协议介绍》。

若对SPI通讯协议不了解，可先阅读《SPI总线协议介绍》文档的内容学习。

关于FLASH存储器，请参考“常用存储器介绍”章节，实验中FLASH芯片的具体参数，请参考其规格书《W25Q64》来了解。

## 25.1. SPI协议简介

SPI协议是由摩托罗拉公司提出的通讯协议(Serial Peripheral Interface)，即串行外围设备接口， 是一种高速全双工的通信总线。它被广泛地使用在ADC、LCD等设备与MCU间，要求通讯速率较高的场合。

学习本章时，可与I2C章节对比阅读，体会两种通讯总线的差异以及EEPROM存储器与FLASH存储器的区别。下面我们分别对SPI协议的物理层及协议层进行讲解。

### 25.1.1. **SPI物理层**

SPI通讯设备之间的常用连接方式见图 [常见的SPI通讯系统](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id2) 。

![常见的SPI通讯系统](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI002.png)

SPI通讯使用3条总线及片选线，3条总线分别为SCK、MOSI、MISO，片选线为SS，它们的作用介绍如下：

(1) SS ( Slave Select)：从设备选择信号线，常称为片选信号线，也称为NSS、CS，以下用NSS表示。当有多个SPI从设备与SPI主机相连时， 设备的其它信号线SCK、MOSI及MISO同时并联到相同的SPI总线上，即无论有多少个从设备，都共同只使用这3条总线； 而每个从设备都有独立的这一条NSS信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。 I2C协议中通过设备地址来寻址、选中总线上的某个设备并与其进行通讯；而SPI协议中没有设备地址，它使用NSS信号线来寻址， 当主机要选择从设备时，把该从设备的NSS信号线设置为低电平，该从设备即被选中，即片选有效， 接着主机开始与被选中的从设备进行SPI通讯。所以SPI通讯以NSS线置低电平为开始信号，以NSS线被拉高作为结束信号。

(2) SCK (Serial Clock)：时钟信号线，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样， 如STM32的SPI时钟频率最大为fpclk/2，两个设备之间通讯时，通讯速率受限于低速设备。

(3) MOSI (Master Output， Slave Input)：主设备输出/从设备输入引脚。主机的数据从这条信号线输出， 从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。

(4) MISO (Master Input,，Slave Output)：主设备输入/从设备输出引脚。主机从这条信号线读入数据， 从机的数据由这条信号线输出到主机，即在这条线上数据的方向为从机到主机。

### 25.1.2. 协议层

与I2C的类似，SPI协议定义了通讯的起始和停止信号、数据有效性、时钟同步等环节。

#### 25.1.2.1. SPI基本通讯过程

先看看SPI通讯的通讯时序，见图 [SPI通讯时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id5) 。

![SPI通讯时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI003.jpg)

这是一个主机的通讯时序。NSS、SCK、MOSI信号都由主机控制产生，而MISO的信号由从机产生，主机通过该信号线读取从机的数据。 MOSI与MISO的信号只在NSS为低电平的时候才有效，在SCK的每个时钟周期MOSI和MISO传输一位数据。

以上通讯流程中包含的各个信号分解如下：

#### 25.1.2.2. 通讯的起始和停止信号

在图 [SPI通讯时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id5) 中的标号处，NSS信号线由高变低，是SPI通讯的起始信号。NSS是每个从机各自独占的信号线， 当从机在自己的NSS线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。在图中的标号处，NSS信号由低变高， 是SPI通讯的停止信号，表示本次通讯结束，从机的选中状态被取消。

#### 25.1.2.3. 数据有效性

SPI使用MOSI及MISO信号线来传输数据，使用SCK信号线进行数据同步。MOSI及MISO数据线在SCK的每个时钟周期传输一位数据， 且数据输入输出是同时进行的。数据传输时，MSB先行或LSB先行并没有作硬性规定，但要保证两个SPI通讯设备之间使用同样的协定， 一般都会采用图 [SPI通讯时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id5) 中的MSB先行模式。

观察图中的标号处，MOSI及MISO的数据在SCK的上升沿期间变化输出，在SCK的下降沿时被采样。即在SCK的下降沿时刻， MOSI及MISO的数据有效，高电平时表示数据“1”，为低电平时表示数据“0”。在其它时刻，数据无效，MOSI及MISO为下一次表示数据做准备。

SPI每次数据传输可以8位或16位为单位，每次传输的单位数不受限制。

#### 25.1.2.4. CPOL/CPHA及通讯模式

上面讲述的图 [SPI通讯时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id5) 中的时序只是SPI中的其中一种通讯模式，SPI一共有四种通讯模式， 它们的主要区别是总线空闲时SCK的时钟状态以及数据采样时刻。为方便说明，在此引入“时钟极性CPOL”和“时钟相位CPHA”的概念。

时钟极性CPOL是指SPI通讯设备处于空闲状态时，SCK信号线的电平信号(即SPI通讯开始前、 NSS线为高电平时SCK的状态)。CPOL=0时， SCK在空闲状态时为低电平，CPOL=1时，则相反。

时钟相位CPHA是指数据的采样的时刻，当CPHA=0时，MOSI或MISO数据线上的信号将会在SCK时钟线的“奇数边沿”被采样。当CPHA=1时， 数据线在SCK的“偶数边沿”采样。见图 CPHA = [0时的SPI通讯模式](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id8) 及图 CPHA = [1时的SPI通讯模式](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id9) 。

![CPHA=0时的SPI通讯模式](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI004.jpeg)

我们来分析这个CPHA=0的时序图。首先，根据SCK在空闲状态时的电平，分为两种情况。 SCK信号线在空闲状态为低电平时，CPOL=0；空闲状态为高电平时，CPOL=1。

无论CPOL=0还是=1，因为我们配置的时钟相位CPHA=0，在图中可以看到，采样时刻都是在SCK的奇数边沿。 注意当CPOL=0的时候，时钟的奇数边沿是上升沿，而CPOL=1的时候，时钟的奇数边沿是下降沿。所以SPI的采样时刻不是由上升/下降沿决定的。 MOSI和MISO数据线的有效信号在SCK的奇数边沿保持不变，数据信号将在SCK奇数边沿时被采样，在非采样时刻，MOSI和MISO的有效信号才发生切换。

类似地，当CPHA=1时，不受CPOL的影响，数据信号在SCK的偶数边沿被采样，见图 CPHA=1时的SPI通讯模式_ 。

![CPHA=1时的SPI通讯模式](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI005.jpeg)

由CPOL及CPHA的不同状态，SPI分成了四种模式，见表 [SPI的四种模式](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id10) ， 主机与从机需要工作在相同的模式下才可以正常通讯，实际中采用较多的是“模式0”与“模式3”。

![SPI的四种模式](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI01.png)

## 25.2. STM32的SPI特性及架构
与I2C外设一样，STM32芯片也集成了专门用于SPI协议通讯的外设。

### 25.2.1. STM32的SPI外设简介

STM32的SPI外设可用作通讯的主机及从机， 支持最高的SCK时钟频率为fpclk/2 (STM32F103型号的芯片默认fpclk1为36MHz， fpclk2为72MHz)，完全支持SPI协议的4种模式，数据帧长度可设置为8位或16位， 可设置数据MSB先行或LSB先行。它还支持双线全双工(前面小节说明的都是这种模式)、双线单向以及单线模式。 其中双线单向模式可以同时使用MOSI及MISO数据线向一个方向传输数据，可以加快一倍的传输速度。而单线模式则可以减少硬件接线， 当然这样速率会受到影响。我们只讲解双线全双工模式。

### 25.2.2. STM32的SPI架构剖析

![SPI架构图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI006.png)

#### 25.2.2.1. 通讯引脚

SPI的所有硬件架构都从图 [SPI架构图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id13) 中左侧MOSI、MISO、SCK及NSS线展开的。STM32芯片有多个SPI外设， 它们的SPI通讯信号引出到不同的GPIO引脚上，使用时必须配置到这些指定的引脚，见表 [STM32F10x的SPI引脚](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#stm32f10xspi) 。 关于GPIO引脚的复用功能，可查阅《STM32F10x规格书》，以它为准。

![STM32F10x的SPI引脚](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI02.png)

其中SPI1是APB2上的设备，最高通信速率达36Mbtis/s，SPI2、SPI3是APB1上的设备，最高通信速率为18Mbits/s。除了通讯速率， 在其它功能上没有差异。其中SPI3用到了下载接口的引脚，这几个引脚默认功能是下载，第二功能才是IO口，如果想使用SPI3接口， 则程序上必须先禁用掉这几个IO口的下载功能。一般在资源不是十分紧张的情况下，这几个IO口是专门用于下载和调试程序，不会复用为SPI3。

#### 25.2.2.2. 时钟控制逻辑

SCK线的时钟信号，由波特率发生器根据“控制寄存器CR1”中的BR[0:2]位控制，该位是对fpclk时钟的分频因子， 对fpclk的分频结果就是SCK引脚的输出时钟频率，计算方法见表 [BR位对fpclk的分频](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#brfpclk) 。

![BR位对fpclk的分频](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI03.png)

其中的fpclk频率是指SPI所在的APB总线频率， APB1为fpclk1，APB2为fpckl2。

通过配置“控制寄存器CR”的“CPOL位”及“CPHA”位可以把SPI设置成前面分析的[4种SPI模式](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#cpolcpha%E5%8F%8A%E9%80%9A%E8%AE%AF%E6%A8%A1%E5%BC%8F)。

#### 25.2.2.3. 数据控制逻辑

SPI的MOSI及MISO都连接到数据移位寄存器上，数据移位寄存器的数据来源及目标接收、发送缓冲区以及MISO、MOSI线。 当向外发送数据的时候，数据移位寄存器以“发送缓冲区”为数据源，把数据一位一位地通过数据线发送出去；当从外部接收数据的时候， 数据移位寄存器把数据线采样到的数据一位一位地存储到“接收缓冲区”中。通过写SPI的“数据寄存器DR”把数据填充到发送缓冲区中， 通讯读“数据寄存器DR”，可以获取接收缓冲区中的内容。其中数据帧长度可以通过“控制寄存器CR1”的“DFF位”配置成8位及16位模式； 配置“LSBFIRST位”可选择MSB先行还是LSB先行。

#### 25.2.2.4. 整体控制逻辑

整体控制逻辑负责协调整个SPI外设，控制逻辑的工作模式根据我们配置的“控制寄存器(CR1/CR2)”的参数而改变， 基本的控制参数包括前面提到的SPI模式、波特率、LSB先行、主从模式、单双向模式等等。在外设工作时， 控制逻辑会根据外设的工作状态修改“状态寄存器(SR)”，我们只要读取状态寄存器相关的寄存器位， 就可以了解SPI的工作状态了。除此之外，控制逻辑还根据要求，负责控制产生SPI中断信号、DMA请求及控制NSS信号线。

实际应用中，我们一般不使用STM32 SPI外设的标准NSS信号线，而是更简单地使用普通的GPIO，软件控制它的电平输出，从而产生通讯起始和停止信号。

### 25.2.3. 通讯过程
STM32使用SPI外设通讯时，在通讯的不同阶段它会对“状态寄存器SR”的不同数据位写入参数，我们通过读取这些寄存器标志来了解通讯状态。

图 [主发送器通讯过程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id19) 中的是“主模式”流程，即STM32作为SPI通讯的主机端时的数据收发过程。

![主发送器通讯过程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI007.jpeg)

主模式收发流程及事件说明如下：

(1) 控制NSS信号线， 产生起始信号(图中没有画出)；

(2) 把要发送的数据写入到“数据寄存器DR”中， 该数据会被存储到发送缓冲区；

(3) 通讯开始，SCK时钟开始运行。MOSI把发送缓冲区中的数据一位一位地传输出去； MISO则把数据一位一位地存储进接收缓冲区中；

(4) 当发送完一帧数据的时候，“状态寄存器SR”中的“TXE标志位”会被置1，表示传输完一帧，发送缓冲区已空；类似地， 当接收完一帧数据的时候，“RXNE标志位”会被置1，表示传输完一帧，接收缓冲区非空；

(5) 等待到“TXE标志位”为1时，若还要继续发送数据，则再次往“数据寄存器DR”写入数据即可；等待到“RXNE标志位”为1时， 通过读取“数据寄存器DR”可以获取接收缓冲区中的内容。

假如我们使能了TXE或RXNE中断，TXE或RXNE置1时会产生SPI中断信号，进入同一个中断服务函数，到SPI中断服务程序后， 可通过检查寄存器位来了解是哪一个事件，再分别进行处理。也可以使用DMA方式来收发“数据寄存器DR”中的数据。

## 25.3. SPI初始化结构体详解

跟其它外设一样，STM32标准库提供了SPI初始化结构体及初始化函数来配置SPI外设。 初始化结构体及函数定义在库文件“stm32f10x_spi.h”及“stm32f10x_spi.c”中，编程时我们可以结合这两个文件内的注释使用或参考库帮助文档。 了解初始化结构体后我们就能对SPI外设运用自如了，见 [代码清单:SPI-1](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-1) 。

代码清单:SPI-1 SPI初始化结构体[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-1 "永久链接至代码")

```C
typedef struct
{
    uint16_t SPI_Direction;           /*设置SPI的单双向模式 */
    uint16_t SPI_Mode;                /*设置SPI的主/从机端模式 */
    uint16_t SPI_DataSize;            /*设置SPI的数据帧长度，可选8/16位 */
    uint16_t SPI_CPOL;                /*设置时钟极性CPOL，可选高/低电平*/
    uint16_t SPI_CPHA;                /*设置时钟相位，可选奇/偶数边沿采样 */
    uint16_t SPI_NSS;                /*设置NSS引脚由SPI硬件控制还是软件控制*/
    uint16_t SPI_BaudRatePrescaler;  /*设置时钟分频因子，fpclk/分频数=fSCK */
    uint16_t SPI_FirstBit;            /*设置MSB/LSB先行 */
    uint16_t SPI_CRCPolynomial;       /*设置CRC校验的表达式 */
} SPI_InitTypeDef;
```
这些结构体成员说明如下，其中括号内的文字是对应参数在STM32标准库中定义的宏：

1. SPI_Direction
    

本成员设置SPI的通讯方向，可设置为双线全双工(SPI_Direction_2Lines_FullDuplex)，双线只接收(SPI_Direction_2Lines_RxOnly)， 单线只接收(SPI_Direction_1Line_Rx)、单线只发送模式(SPI_Direction_1Line_Tx)。

2. SPI_Mode
    

本成员设置SPI工作在主机模式(SPI_Mode_Master)或从机模式(SPI_Mode_Slave )， 这两个模式的最大区别为SPI的SCK信号线的时序， SCK的时序是由通讯中的主机产生的。若被配置为从机模式，STM32的SPI外设将接受外来的SCK信号。

3. SPI_DataSize
    

本成员可以选择SPI通讯的数据帧大小是为8位(SPI_DataSize_8b)还是16位(SPI_DataSize_16b)。

4. SPI_CPOL和SPI_CPHA
    

这两个成员配置SPI的时钟极性CPOL和时钟相位CPHA，这两个配置影响到SPI的通讯模式， 关于CPOL和CPHA的说明参考前面“通讯模式”小节。

时钟极性CPOL成员，可设置为高电平(SPI_CPOL_High)或低电平(SPI_CPOL_Low )。

时钟相位CPHA 则可以设置为SPI_CPHA_1Edge(在SCK的奇数边沿采集数据) 或SPI_CPHA_2Edge(在SCK的偶数边沿采集数据) 。

5. SPI_NSS
    

本成员配置NSS引脚的使用模式，可以选择为硬件模式(SPI_NSS_Hard )与软件模式(SPI_NSS_Soft )， 在硬件模式中的SPI片选信号由SPI硬件自动产生，而软件模式则需要我们亲自把相应的GPIO端口拉高或置低产生非片选和片选信号。实际中软件模式应用比较多。

6. SPI_BaudRatePrescaler
    

本成员设置波特率分频因子，分频后的时钟即为SPI的SCK信号线的时钟频率。这个成员参数可设置为fpclk的2、4、6、8、16、32、64、128、256分频。

7. SPI_FirstBit
    

所有串行的通讯协议都会有MSB先行(高位数据在前)还是LSB先行(低位数据在前)的问题，而STM32的SPI模块可以通过这个结构体成员，对这个特性编程控制。

8. SPI_CRCPolynomial
    

这是SPI的CRC校验中的多项式，若我们使用CRC校验时，就使用这个成员的参数(多项式)，来计算CRC的值。

配置完这些结构体成员后，我们要调用SPI_Init函数把这些参数写入到寄存器中，实现SPI的初始化，然后调用SPI_Cmd来使能SPI外设。

## 25.4. SPI—读写串行FLASH实验

FLSAH存储器又称闪存，它与EEPROM都是掉电后数据不丢失的存储器，但FLASH存储器容量普遍大于EEPROM， 现在基本取代了它的地位。我们生活中常用的U盘、SD卡、SSD固态硬盘以及我们STM32芯片内部用于存储程序的设备， 都是FLASH类型的存储器。在存储控制上，最主要的区别是FLASH芯片只能一大片一大片地擦写，而在“I2C章节”中我们了解到EEPROM可以单个字节擦写。

本小节以一种使用SPI通讯的串行FLASH存储芯片的读写实验为大家讲解STM32的SPI使用方法。 实验中STM32的SPI外设采用主模式，通过查询事件的方式来确保正常通讯。

### 25.4.1. 硬件设计

![SPI串行FLASH硬件连接图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI008.png)

本实验板中的FLASH芯片(型号：W25Q64)是一种使用SPI通讯协议的NOR FLASH存储器， 它的CS/CLK/DIO/DO引脚分别连接到了STM32对应的SPI引脚NSS/SCK/MOSI/MISO上，其中STM32的NSS引脚是一个普通的GPIO， 不是SPI的专用NSS引脚，所以程序中我们要使用软件控制的方式。

FLASH芯片中还有WP和HOLD引脚。WP引脚可控制写保护功能，当该引脚为低电平时，禁止写入数据。 我们直接接电源，不使用写保护功能。HOLD引脚可用于暂停通讯，该引脚为低电平时，通讯暂停， 数据输出引脚输出高阻抗状态，时钟和数据输入引脚无效。我们直接接电源，不使用通讯暂停功能。

关于FLASH芯片的更多信息，可参考其数据手册《W25Q64》来了解。若您使用的实验板FLASH的型号或控制引脚不一样， 只需根据我们的工程修改即可，程序的控制原理相同。

### 25.4.2. 软件设计

为了使工程更加有条理，我们把读写FLASH相关的代码独立分开存储，方便以后移植。 在“工程模板”之上新建“bsp_spi_flash.c”及“bsp_spi_ flash.h”文件，这些文件也可根据您的喜好命名， 它们不属于STM32标准库的内容，是由我们自己根据应用需要编写的。

#### 25.4.2.1. 编程要点

1. 初始化通讯使用的目标引脚及端口时钟；
    
2. 使能SPI外设的时钟；
    
3. 配置SPI外设的模式、地址、速率等参数并使能SPI外设；
    
4. 编写基本SPI按字节收发的函数；
    
5. 编写对FLASH擦除及读写操作的的函数；
    
6. 编写测试程序，对读写数据进行校验。
    

#### 25.4.2.2. 代码分析

**SPI硬件相关宏定义**

我们把SPI硬件相关的配置都以宏的形式定义到 “bsp_spi_ flash.h”文件中，见 [代码清单:SPI-2](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-2) 。

代码清单:SPI-2 SPI硬件配置相关的宏[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-2 "永久链接至代码")

```C
/*SPI接口定义-开头****************************/
#define      FLASH_SPIx                        SPI1
#define      FLASH_SPI_APBxClock_FUN          RCC_APB2PeriphClockCmd
#define      FLASH_SPI_CLK                     RCC_APB2Periph_SPI1

//CS(NSS)引脚 片选选普通GPIO即可
#define      FLASH_SPI_CS_APBxClock_FUN       RCC_APB2PeriphClockCmd
#define      FLASH_SPI_CS_CLK                  RCC_APB2Periph_GPIOC
#define      FLASH_SPI_CS_PORT                 GPIOC
#define      FLASH_SPI_CS_PIN                  GPIO_Pin_0

//SCK引脚
#define      FLASH_SPI_SCK_APBxClock_FUN      RCC_APB2PeriphClockCmd
#define      FLASH_SPI_SCK_CLK                 RCC_APB2Periph_GPIOA
#define      FLASH_SPI_SCK_PORT                GPIOA
#define      FLASH_SPI_SCK_PIN                 GPIO_Pin_5
//MISO引脚
#define      FLASH_SPI_MISO_APBxClock_FUN     RCC_APB2PeriphClockCmd
#define      FLASH_SPI_MISO_CLK                RCC_APB2Periph_GPIOA
#define      FLASH_SPI_MISO_PORT               GPIOA
#define      FLASH_SPI_MISO_PIN                GPIO_Pin_6
//MOSI引脚
#define      FLASH_SPI_MOSI_APBxClock_FUN     RCC_APB2PeriphClockCmd
#define      FLASH_SPI_MOSI_CLK                RCC_APB2Periph_GPIOA
#define      FLASH_SPI_MOSI_PORT               GPIOA
#define      FLASH_SPI_MOSI_PIN                GPIO_Pin_7

define  FLASH_SPI_CS_LOW()         GPIO_ResetBits( FLASH_SPI_CS_PORT, FLASH_SPI_CS_PIN )
define  FLASH_SPI_CS_HIGH()        GPIO_SetBits( FLASH_SPI_CS_PORT, FLASH_SPI_CS_PIN )

/*SPI接口定义-结尾****************************/
```
以上代码根据硬件连接，把与FLASH通讯使用的SPI号 、GPIO等都以宏封装起来， 并且定义了控制CS(NSS)引脚输出电平的宏，以便配置产生起始和停止信号时使用。

**初始化SPI的 GPIO**

利用上面的宏，编写SPI的初始化函数，见 [代码清单:SPI-3](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-3) 。

代码清单:SPI-3 SPI的初始化函数(GPIO初始化部分)[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-3 "永久链接至代码")

```C
/**
* @brief  SPI_FLASH初始化
* @param  无
* @retval 无

*/
void SPI_FLASH_Init(void)
{
    SPI_InitTypeDef  SPI_InitStructure;
    GPIO_InitTypeDef GPIO_InitStructure;

    /* 使能SPI时钟 */
    FLASH_SPI_APBxClock_FUN ( FLASH_SPI_CLK, ENABLE );

    /* 使能SPI引脚相关的时钟 */
    FLASH_SPI_CS_APBxClock_FUN ( FLASH_SPI_CS_CLK|FLASH_SPI_SCK_CLK|
                    FLASH_SPI_MISO_PIN|FLASH_SPI_MOSI_PIN, ENABLE );

    /* 配置SPI的 CS引脚，普通IO即可 */
    GPIO_InitStructure.GPIO_Pin = FLASH_SPI_CS_PIN;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_Init(FLASH_SPI_CS_PORT, &GPIO_InitStructure);

    /* 配置SPI的 SCK引脚*/
    GPIO_InitStructure.GPIO_Pin = FLASH_SPI_SCK_PIN;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(FLASH_SPI_SCK_PORT, &GPIO_InitStructure);

    /* 配置SPI的 MISO引脚*/
    GPIO_InitStructure.GPIO_Pin = FLASH_SPI_MISO_PIN;
    GPIO_Init(FLASH_SPI_MISO_PORT, &GPIO_InitStructure);

    /* 配置SPI的 MOSI引脚*/
    GPIO_InitStructure.GPIO_Pin = FLASH_SPI_MOSI_PIN;
    GPIO_Init(FLASH_SPI_MOSI_PORT, &GPIO_InitStructure);

    /* 停止信号 FLASH: CS引脚高电平*/
    FLASH_SPI_CS_HIGH();
    //为方便讲解，以下省略 SPI 模式初始化部分
```
与所有使用到GPIO的外设一样，都要先把使用到的GPIO引脚模式初始化，配置好复用功能。GPIO初始化流程如下：

(1) 使用GPIO_InitTypeDef定义GPIO初始化结构体变量， 以便下面用于存储GPIO配置；

(2) 调用库函数RCC_APB2PeriphClockCmd 来使能SPI引脚使用的GPIO端口时钟。

(3) 向GPIO初始化结构体赋值，把SCK/MOSI/MISO引脚初始化成复用推挽模式。 而CS(NSS)引脚由于使用软件控制，我们把它配置为普通的推挽输出模式。

(4) 使用以上初始化结构体的配置，调用GPIO_Init函数向寄存器写入参数， 完成GPIO的初始化。

**配置SPI的模式**

以上只是配置了SPI使用的引脚，对SPI外设模式的配置。在配置STM32的SPI模式前，我们要先了解从机端的SPI模式。 本例子中可通过查阅FLASH数据手册《W25Q64》获取。根据FLASH芯片的说明，它支持SPI模式0及模式3，支持双线全双工， 使用MSB先行模式，支持最高通讯时钟为104MHz，数据帧长度为8位。我们要把STM32的SPI外设中的这些参数配置一致。 见 [代码清单:SPI-4](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-4) 。

代码清单:SPI-4 配置SPI模式[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-4 "永久链接至代码")

```C
/**
* @brief  SPI_FLASH引脚初始化
* @param  无
* @retval 无
*/
void SPI_FLASH_Init(void)
{
    /*为方便讲解，省略了SPI的GPIO初始化部分*/
    //......

    SPI_InitTypeDef  SPI_InitStructure;
    /* SPI 模式配置 */
    // FLASH芯片 支持SPI模式0及模式3，据此设置CPOL CPHA
    SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
    SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
    SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
    SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
    SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
    SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
    SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
    SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
    SPI_InitStructure.SPI_CRCPolynomial = 7;
    SPI_Init(FLASH_SPIx, &SPI_InitStructure);

    /* 使能 SPI  */
    SPI_Cmd(FLASH_SPIx, ENABLE);
}
```
这段代码中，把STM32的SPI外设配置为主机端，双线全双工模式，数据帧长度为8位，使用SPI模式3(CPOL=1，CPHA=1)， NSS引脚由软件控制以及MSB先行模式。代码中把SPI的时钟频率配置成了4分频，实际上可以配置成2分频以提高通讯速率， 读者可亲自尝试一下。最后一个成员为CRC计算式，由于我们与FLASH芯片通讯不需要CRC校验，并没有使能SPI的CRC功能， 这时CRC计算式的成员值是无效的。

赋值结束后调用库函数SPI_Init把这些配置写入寄存器，并调用SPI_Cmd函数使能外设。

**使用SPI发送和接收一个字节的数据**

初始化好SPI外设后，就可以使用SPI通讯了，复杂的数据通讯都是由单个字节数据收发组成的， 我们看看它的代码实现，见 [代码清单:SPI-5](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-5) 。

代码清单:SPI-5 使用SPI发送和接收一个字节的数据[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-5 "永久链接至代码")

```C
#define Dummy_Byte 0xFF
/**
* @brief  使用SPI发送一个字节的数据
* @param  byte：要发送的数据
* @retval 返回接收到的数据
*/
u8 SPI_FLASH_SendByte(u8 byte)
{
    SPITimeout = SPIT_FLAG_TIMEOUT;

    /* 等待发送缓冲区为空，TXE事件 */
    while (SPI_I2S_GetFlagStatus(FLASH_SPIx, SPI_I2S_FLAG_TXE) == RESET)
    {
        if ((SPITimeout--) == 0) return SPI_TIMEOUT_UserCallback(0);
    }

    /* 写入数据寄存器，把要写入的数据写入发送缓冲区 */
    SPI_I2S_SendData(FLASH_SPIx, byte);

    SPITimeout = SPIT_FLAG_TIMEOUT;

    /* 等待接收缓冲区非空，RXNE事件 */
    while (SPI_I2S_GetFlagStatus(FLASH_SPIx, SPI_I2S_FLAG_RXNE) == RESET)
    {
        if ((SPITimeout--) == 0) return SPI_TIMEOUT_UserCallback(1);
    }

    /* 读取数据寄存器，获取接收缓冲区数据 */
    return SPI_I2S_ReceiveData(FLASH_SPIx);
}

/**
* @brief  使用SPI读取一个字节的数据
* @param  无
* @retval 返回接收到的数据
*/
u8 SPI_FLASH_ReadByte(void)
{
    return (SPI_FLASH_SendByte(Dummy_Byte));
}
```
SPI_FLASH_SendByte发送单字节函数中包含了等待事件的超时处理，这部分原理跟I2C中的一样，在此不再赘述。

SPI_FLASH_SendByte函数实现了前面讲解的“SPI通讯过程”：

(1) 本函数中不包含SPI起始和停止信号，只是收发的主要过程， 所以在调用本函数前后要做好起始和停止信号的操作；

(2) 对SPITimeout变量赋值为宏SPIT_FLAG_TIMEOUT。这个SPITimeout变量在下面的while循环中每次循环减1， 该循环通过调用库函数SPI_I2S_GetFlagStatus检测事件，若检测到事件，则进入通讯的下一阶段， 若未检测到事件则停留在此处一直检测，当检测SPIT_FLAG_TIMEOUT次都还没等待到事件则认为通讯失败， 调用的SPI_TIMEOUT_UserCallback输出调试信息，并退出通讯；

(3) 通过检测TXE标志，获取发送缓冲区的状态，若发送缓冲区为空， 则表示可能存在的上一个数据已经发送完毕；

(4) 等待至发送缓冲区为空后，调用库函数SPI_I2S_SendData把要发送的数据“byte”写入到SPI的数据寄存器DR， 写入SPI数据寄存器的数据会存储到发送缓冲区，由SPI外设发送出去；

(5) 写入完毕后等待RXNE事件，即接收缓冲区非空事件。 由于SPI双线全双工模式下MOSI与MISO数据传输是同步的(请对比“SPI通讯过程”阅读)，当接收缓冲区非空时， 表示上面的数据发送完毕，且接收缓冲区也收到新的数据；

(6) 等待至接收缓冲区非空时，通过调用库函数SPI_I2S_ReceiveData读取SPI的数据寄存器DR，就可以获取接收缓冲区中的新数据了。 代码中使用关键字“return”把接收到的这个数据作为SPI_FLASH_SendByte函数的返回值， 所以我们可以看到在下面定义的SPI接收数据函数SPI_FLASH_ReadByte，它只是简单地调用了SPI_FLASH_SendByte函数发送数据“Dummy_Byte”， 然后获取其返回值(因为不关注发送的数据，所以此时的输入参数“Dummy_Byte”可以为任意值)。 可以这样做的原因是SPI的接收过程和发送过程实质是一样的，收发同步进行，关键在于我们的上层应用中，关注的是发送还是接收的数据。

**控制FLASH的指令**

搞定SPI的基本收发单元后，还需要了解如何对FLASH芯片进行读写。FLASH芯片自定义了很多指令， 我们通过控制STM32利用SPI总线向FLASH芯片发送指令，FLASH芯片收到后就会执行相应的操作。

而这些指令，对主机端(STM32)来说，只是它遵守最基本的SPI通讯协议发送出的数据，但在设备端(FLASH芯片)把这些数据解释成不同的意义， 所以才成为指令。查看FLASH芯片的数据手册《W25Q64》，可了解各种它定义的各种指令的功能及指令格式， 见表 [FLASH常用芯片指令表](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#flash) 。

![FLASH常用芯片指令表](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI04.png)

该表中的第一列为指令名，第二列为指令编码，第三至第N列的具体内容根据指令的不同而有不同的含义。 其中带括号的字节参数，方向为FLASH向主机传输，即命令响应，不带括号的则为主机向FLASH传输。 表中“A0~A23”指FLASH芯片内部存储器组织的地址；“M0~M7”为厂商号（MANUFACTURERID）； “ID0-ID15”为FLASH芯片的ID；“dummy”指该处可为任意数据；“D0~D7”为FLASH内部存储矩阵的内容。

在FLSAH芯片内部，存储有固定的厂商编号(M7-M0)和不同类型FLASH芯片独有的编号(ID15-ID0)， 见表 [FLASH数据手册的设备ID说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#flashid) 。

![FLASH数据手册的设备ID说明](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI05.png)

通过指令表中的读ID指令“JEDEC ID”可以获取这两个编号，该指令编码为“9F h”， 其中“9F h”是指16进制数“9F” (相当于C语言中的0x9F)。 紧跟指令编码的三个字节分别为FLASH芯片输出的“(M7-M0)”、“(ID15-ID8)”及“(ID7-ID0)” 。

此处我们以该指令为例，配合其指令时序图进行讲解，见图 [FLASH读ID指令JEDEC_ID的时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#flashidjedec-id) 。

![FLASH读ID指令JEDEC_ID的时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI009.jpeg)

主机首先通过MOSI线向FLASH芯片发送第一个字节数据为“9F h”，当FLASH芯片收到该数据后，它会解读成主机向它发送了“JEDEC指令”， 然后它就作出该命令的响应：通过MISO线把它的厂商ID(M7-M0)及芯片类型(ID15-0)发送给主机，主机接收到指令响应后可进行校验。 常见的应用是主机端通过读取设备ID来测试硬件是否连接正常，或用于识别设备。

对于FLASH芯片的其它指令，都是类似的，只是有的指令包含多个字节，或者响应包含更多的数据。

实际上，编写设备驱动都是有一定的规律可循的。首先我们要确定设备使用的是什么通讯协议。如上一章的EEPROM使用的是I2C， 本章的FLASH使用的是SPI。那么我们就先根据它的通讯协议，选择好STM32的硬件模块，并进行相应的I2C或SPI模块初始化。 接着，我们要了解目标设备的相关指令，因为不同的设备，都会有相应的不同的指令。如EEPROM中会把第一个数据解释为内部存储矩阵的地址(实质就是指令)。 而FLASH则定义了更多的指令，有写指令，读指令，读ID指令等等。最后，我们根据这些指令的格式要求，使用通讯协议向设备发送指令，达到控制设备的目标。

**定义FLASH指令编码表**

为了方便使用，我们把FLASH芯片的常用指令编码使用宏来封装起来，后面需要发送指令编码的时候我们直接使用这些宏即可， 见 [代码清单:SPI-6](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-6) 。

代码清单:SPI-6 FLASH指令编码表[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-6 "永久链接至代码")

```C
/*FLASH常用命令*/
#define W25X_WriteEnable                0x06
#define W25X_WriteDisable               0x04
#define W25X_ReadStatusReg              0x05
#define W25X_WriteStatusReg             0x01
#define W25X_ReadData                   0x03
#define W25X_FastReadData               0x0B
#define W25X_FastReadDual               0x3B
#define W25X_PageProgram                0x02
#define W25X_BlockErase                 0xD8
#define W25X_SectorErase                0x20
#define W25X_ChipErase                  0xC7
#define W25X_PowerDown                  0xB9
#define W25X_ReleasePowerDown           0xAB
#define W25X_DeviceID                   0xAB
#define W25X_ManufactDeviceID           0x90
#define W25X_JedecDeviceID              0x9F
/*其它*/
#define  sFLASH_ID                      0XEF4017
#define Dummy_Byte                      0xFF
```
**读取FLASH芯片ID**

根据“JEDEC”指令的时序，我们把读取FLASH ID的过程编写成一个函数，见 [代码清单:SPI-7](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-7) 。

代码清单:SPI-7 读取FLASH芯片ID[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-7 "永久链接至代码")

```C
/**
* @brief  读取FLASH ID
* @param  无
* @retval FLASH ID
*/
u32 SPI_FLASH_ReadID(void)
{
    u32 Temp = 0, Temp0 = 0, Temp1 = 0, Temp2 = 0;

    /* 开始通讯：CS低电平 */
    SPI_FLASH_CS_LOW();

    /* 发送JEDEC指令，读取ID */
    SPI_FLASH_SendByte(W25X_JedecDeviceID);

    /* 读取一个字节数据 */
    Temp0 = SPI_FLASH_SendByte(Dummy_Byte);

    /* 读取一个字节数据 */
    Temp1 = SPI_FLASH_SendByte(Dummy_Byte);

    /* 读取一个字节数据 */
    Temp2 = SPI_FLASH_SendByte(Dummy_Byte);

    /* 停止通讯：CS高电平 */
    SPI_FLASH_CS_HIGH();

    /*把数据组合起来，作为函数的返回值*/
    Temp = (Temp0 << 16) | (Temp1 << 8) | Temp2;

    return Temp;
}
```
这段代码利用控制CS引脚电平的宏“SPI_FLASH_CS_LOW/HIGH”以及前面编写的单字节收发函数SPI_FLASH_SendByte， 很清晰地实现了“JEDEC ID”指令的时序：发送一个字节的指令编码“W25X_JedecDeviceID”，然后读取3个字节， 获取FLASH芯片对该指令的响应，最后把读取到的这3个数据合并到一个变量Temp中，然后作为函数返回值， 把该返回值与我们定义的宏“sFLASH_ID”对比，即可知道FLASH芯片是否正常。

**FLASH写使能以及读取当前状态**

在向FLASH芯片存储矩阵写入数据前，首先要使能写操作，通过“Write Enable”命令即可写使能， 见 [代码清单:SPI-8](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-8) 。

代码清单:SPI-8 写使能命令[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-8 "永久链接至代码")

```C
/**
* @brief  向FLASH发送 写使能 命令
* @param  none
* @retval none
*/
void SPI_FLASH_WriteEnable(void)
{
    /* 通讯开始：CS低 */
    SPI_FLASH_CS_LOW();

    /* 发送写使能命令*/
    SPI_FLASH_SendByte(W25X_WriteEnable);

    /*通讯结束：CS高 */
    SPI_FLASH_CS_HIGH();
}
```
与EEPROM一样，由于FLASH芯片向内部存储矩阵写入数据需要消耗一定的时间，并不是在总线通讯结束的一瞬间完成的， 所以在写操作后需要确认FLASH芯片“空闲”时才能进行再次写入。为了表示自己的工作状态，FLASH芯片定义了一个状态寄存器， 见图 [FLASH芯片的状态寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id27) 。

![FLASH芯片的状态寄存器](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI010.jpeg)

我们只关注这个状态寄存器的第0位“BUSY”，当这个位为“1”时，表明FLASH芯片处于忙碌状态， 它可能正在对内部的存储矩阵进行“擦除”或“数据写入”的操作。

利用指令表中的“Read Status Register”指令可以获取FLASH芯片状态寄存器的内容， 其时序见图 [读取状态寄存器的时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id28) 。

![读取状态寄存器的时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI011.jpeg)

只要向FLASH芯片发送了读状态寄存器的指令，FLASH芯片就会持续向主机返回最新的状态寄存器内容， 直到收到SPI通讯的停止信号。据此我们编写了具有等待FLASH芯片写入结束功能的函数，见 [代码清单:SPI-9](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-9) 。

代码清单:SPI-9 通过读状态寄存器等待FLASH芯片空闲[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-9 "永久链接至代码")

```C
/* WIP(busy)标志，FLASH内部正在写入 */
#define WIP_Flag                  0x01

/**
* @brief  等待WIP(BUSY)标志被置0，即等待到FLASH内部数据写入完毕
* @param  none
* @retval none
*/
void SPI_FLASH_WaitForWriteEnd(void)
{
    u8 FLASH_Status = 0;

    /* 选择 FLASH: CS 低 */
    SPI_FLASH_CS_LOW();

    /* 发送 读状态寄存器 命令 */
    SPI_FLASH_SendByte(W25X_ReadStatusReg);

    /* 若FLASH忙碌，则等待 */
    do
    {
        /* 读取FLASH芯片的状态寄存器 */
        FLASH_Status = SPI_FLASH_SendByte(Dummy_Byte);
    }
    while ((FLASH_Status & WIP_Flag) == SET);  /* 正在写入标志 */

    /* 停止信号  FLASH: CS 高 */
    SPI_FLASH_CS_HIGH();
}
```
这段代码发送读状态寄存器的指令编码“W25X_ReadStatusReg”后，在while循环里持续获取寄存器的内容并检验它的“WIP_Flag标志”(即BUSY位)， 一直等待到该标志表示写入结束时才退出本函数，以便继续后面与FLASH芯片的数据通讯。

**FLASH扇区擦除**

由于FLASH存储器的特性决定了它只能把原来为“1”的数据位改写成“0”，而原来为“0”的数据位不能直接改写为“1”。 所以这里涉及到数据“擦除”的概念，在写入前，必须要对目标存储矩阵进行擦除操作，把矩阵中的数据位擦除为“1”， 在数据写入的时候，如果要存储数据“1”，那就不修改存储矩阵，在要存储数据“0”时，才更改该位。

通常，对存储矩阵擦除的基本操作单位都是多个字节进行，如本例子中的FLASH芯片支持“扇区擦除”、“块擦除”以及“整片擦除”， 见表 [本实验FLASH芯片的擦除单位](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id29) 。

![本实验FLASH芯片的擦除单位](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI06.png)

FLASH芯片的最小擦除单位为扇区(Sector)，而一个块(Block)包含16个扇区， 其内部存储矩阵分布见图 [FLASH芯片的存储矩阵](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id30) 。。

![FLASH芯片的存储矩阵](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI012.png)

使用扇区擦除指令“[Sector Erase](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#%E6%8E%A7%E5%88%B6flash%E7%9A%84%E6%8C%87%E4%BB%A4)”可控制FLASH芯片开始擦写， 其指令时序见图 [扇区擦除时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id31) 。

![扇区擦除时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI013.png)

扇区擦除指令的第一个字节为指令编码，紧接着发送的3个字节用于表示要擦除的存储矩阵地址。要注意的是在扇区擦除指令前， 还需要先发送“写使能”指令，发送扇区擦除指令后，通过读取寄存器状态等待扇区擦除操作完毕， 代码实现见 [代码清单:SPI-10](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-10) 。

代码清单:SPI-10 擦除扇区[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-10 "永久链接至代码")

```C
/**
* @brief  擦除FLASH扇区
* @param  SectorAddr：要擦除的扇区地址
* @retval 无
*/
void SPI_FLASH_SectorErase(u32 SectorAddr)
{
    /* 发送FLASH写使能命令 */
    SPI_FLASH_WriteEnable();
    SPI_FLASH_WaitForWriteEnd();
    /* 擦除扇区 */
    /* 选择FLASH: CS低电平 */
    SPI_FLASH_CS_LOW();
    /* 发送扇区擦除指令*/
    SPI_FLASH_SendByte(W25X_SectorErase);
    /*发送擦除扇区地址的高位*/
    SPI_FLASH_SendByte((SectorAddr & 0xFF0000) >> 16);
    /* 发送擦除扇区地址的中位 */
    SPI_FLASH_SendByte((SectorAddr & 0xFF00) >> 8);
    /* 发送擦除扇区地址的低位 */
    SPI_FLASH_SendByte(SectorAddr & 0xFF);
    /* 停止信号 FLASH: CS 高电平 */
    SPI_FLASH_CS_HIGH();
    /* 等待擦除完毕*/
    SPI_FLASH_WaitForWriteEnd();
}
```
这段代码调用的函数在前面都已讲解，只要注意发送擦除地址时高位在前即可。调用扇区擦除指令时注意输入的地址要对齐到4KB。

**FLASH的页写入**

目标扇区被擦除完毕后，就可以向它写入数据了。与EEPROM类似，FLASH芯片也有页写入命令， 使用页写入命令最多可以一次向FLASH传输256个字节的数据，我们把这个单位为页大小。 FLASH页写入的时序见图 [FLASH芯片页写入](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#id32) 。

![FLASH芯片页写入](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI014.jpeg)

从时序图可知，第1个字节为“页写入指令”编码，2-4字节为要写入的“地址A”，接着的是要写入的内容，最多个可以发送256字节数据， 这些数据将会从“地址A”开始，按顺序写入到FLASH的存储矩阵。若发送的数据超出256个，则会覆盖前面发送的数据。

与擦除指令不一样，页写入指令的地址并不要求按256字节对齐，只要确认目标存储单元是擦除状态即可(即被擦除后没有被写入过)。 所以，若对“地址x”执行页写入指令后，发送了200个字节数据后终止通讯，下一次再执行页写入指令，从“地址(x+200)”开始写入200个字节也是没有问题的(小于256均可)。 只是在实际应用中由于基本擦除单元是4KB，一般都以扇区为单位进行读写，想深入了解，可学习我们的“FLASH文件系统”相关的例子。

把页写入时序封装成函数，其实现见 [代码清单:SPI-11](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-11) 。

代码清单:SPI-11 FLASH的页写入[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-11 "永久链接至代码")

```C
/**
* @brief  对FLASH按页写入数据，调用本函数写入数据前需要先擦除扇区
* @param  pBuffer，要写入数据的指针
* @param WriteAddr，写入地址
* @param  NumByteToWrite，写入数据长度，必须小于等于页大小
* @retval 无
*/
void SPI_FLASH_PageWrite(u8* pBuffer, u32 WriteAddr, u16 NumByteToWrite)
{
    /* 发送FLASH写使能命令 */
    SPI_FLASH_WriteEnable();

    /* 选择FLASH: CS低电平 */
    SPI_FLASH_CS_LOW();
    /* 写送写指令*/
    SPI_FLASH_SendByte(W25X_PageProgram);
    /*发送写地址的高位*/
    SPI_FLASH_SendByte((WriteAddr & 0xFF0000) >> 16);
    /*发送写地址的中位*/
    SPI_FLASH_SendByte((WriteAddr & 0xFF00) >> 8);
    /*发送写地址的低位*/
    SPI_FLASH_SendByte(WriteAddr & 0xFF);

    if (NumByteToWrite > SPI_FLASH_PerWritePageSize)
    {
        NumByteToWrite = SPI_FLASH_PerWritePageSize;
        FLASH_ERROR("SPI_FLASH_PageWrite too large!");
    }

    /* 写入数据*/
    while (NumByteToWrite--)
    {
        /* 发送当前要写入的字节数据 */
        SPI_FLASH_SendByte(*pBuffer);
        /* 指向下一字节数据 */
        pBuffer++;
    }

    /* 停止信号 FLASH: CS 高电平 */
    SPI_FLASH_CS_HIGH();

    /* 等待写入完毕*/
    SPI_FLASH_WaitForWriteEnd();
}
```
这段代码的内容为：先发送“写使能”命令，接着才开始页写入时序，然后发送指令编码、地址，再把要写入的数据一个接一个地发送出去， 发送完后结束通讯，检查FLASH状态寄存器，等待FLASH内部写入结束。

**不定量数据写入**

应用的时候我们常常要写入不定量的数据，直接调用“页写入”函数并不是特别方便，所以我们在它的基础上编写了“不定量数据写入”的函数， 基实现见 [代码清单:SPI-12](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-12) 。

代码清单:SPI-12不定量数据写入[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-12 "永久链接至代码")

```C
/**
* @brief  对FLASH写入数据，调用本函数写入数据前需要先擦除扇区
* @param   pBuffer，要写入数据的指针
* @param  WriteAddr，写入地址
* @param  NumByteToWrite，写入数据长度
* @retval 无
*/
void SPI_FLASH_BufferWrite(u8* pBuffer, u32 WriteAddr, u16 NumByteToWrite)
{
    u8 NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;

    /*mod运算求余，若writeAddr是SPI_FLASH_PageSize整数倍，
    运算结果Addr值为0*/
    Addr = WriteAddr % SPI_FLASH_PageSize;

    /*差count个数据值，刚好可以对齐到页地址*/
    count = SPI_FLASH_PageSize - Addr;
    /*计算出要写多少整数页*/
    NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
    /*mod运算求余，计算出剩余不满一页的字节数*/
    NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;

    /* Addr=0,则WriteAddr 刚好按页对齐 aligned  */
    if (Addr == 0)
    {
        /* NumByteToWrite < SPI_FLASH_PageSize */
        if (NumOfPage == 0)
        {
            SPI_FLASH_PageWrite(pBuffer, WriteAddr,
                                NumByteToWrite);
        }
        else /* NumByteToWrite > SPI_FLASH_PageSize */
        {
            /*先把整数页都写了*/
            while (NumOfPage--)
            {
                SPI_FLASH_PageWrite(pBuffer, WriteAddr,
                                    SPI_FLASH_PageSize);
                WriteAddr +=  SPI_FLASH_PageSize;
                pBuffer += SPI_FLASH_PageSize;
            }
            /*若有多余的不满一页的数据，把它写完*/
            SPI_FLASH_PageWrite(pBuffer, WriteAddr,
                                NumOfSingle);
        }
    }
    /* 若地址与 SPI_FLASH_PageSize 不对齐  */
    else
    {
        /* NumByteToWrite < SPI_FLASH_PageSize */
        if (NumOfPage == 0)
        {
            /*当前页剩余的count个位置比NumOfSingle小，一页写不完*/
            if (NumOfSingle > count)
            {
                temp = NumOfSingle - count;
                /*先写满当前页*/
                SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);

                WriteAddr +=  count;
                pBuffer += count;
                /*再写剩余的数据*/
                SPI_FLASH_PageWrite(pBuffer, WriteAddr, temp);
            }
            else /*当前页剩余的count个位置能写完NumOfSingle个数据*/
            {
                SPI_FLASH_PageWrite(pBuffer, WriteAddr,
                                    NumByteToWrite);
            }
        }
        else /* NumByteToWrite > SPI_FLASH_PageSize */
        {
            /*地址不对齐多出的count分开处理，不加入这个运算*/
            NumByteToWrite -= count;
            NumOfPage =  NumByteToWrite / SPI_FLASH_PageSize;
            NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;

            /* 先写完count个数据，为的是让下一次要写的地址对齐 */
            SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);

            /* 接下来就重复地址对齐的情况 */
            WriteAddr +=  count;
            pBuffer += count;
            /*把整数页都写了*/
            while (NumOfPage--)
            {
                SPI_FLASH_PageWrite(pBuffer, WriteAddr,
                                    SPI_FLASH_PageSize);
                WriteAddr +=  SPI_FLASH_PageSize;
                pBuffer += SPI_FLASH_PageSize;
            }
            /*若有多余的不满一页的数据，把它写完*/
            if (NumOfSingle != 0)
            {
                SPI_FLASH_PageWrite(pBuffer, WriteAddr,
                                    NumOfSingle);
            }
        }
    }
}
```
这段代码与EEPROM章节中的“快速写入多字节”函数原理是一样的，运算过程在此不再赘述。区别是页的大小以及实际数据写入的时候， 使用的是针对FLASH芯片的页写入函数，且在实际调用这个“不定量数据写入”函数时，还要注意确保目标扇区处于擦除状态。

**从FLASH读取数据**

相对于写入，FLASH芯片的数据读取要简单得多，使用读取指令“Read Data”即可， 其指令时序见图 [SPI_FLASH读取数据时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-flash) 。

![SPI_FLASH读取数据时序](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/SPI015.jpeg)

发送了指令编码及要读的起始地址后，FLASH芯片就会按地址递增的方式返回存储矩阵的内容，读取的数据量没有限制， 只要没有停止通讯，FLASH芯片就会一直返回数据。代码实现见 [代码清单:SPI-13](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-13) 。

代码清单:SPI-13 从FLASH读取数据[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-13 "永久链接至代码")

```C
/**
* @brief  读取FLASH数据
* @param  pBuffer，存储读出数据的指针
* @param   ReadAddr，读取地址
* @param   NumByteToRead，读取数据长度
* @retval 无
*/
void SPI_FLASH_BufferRead(u8* pBuffer, u32 ReadAddr, u16 NumByteToRead)
{
    /* 选择FLASH: CS低电平 */
    SPI_FLASH_CS_LOW();

    /* 发送 读 指令 */
    SPI_FLASH_SendByte(W25X_ReadData);

    /* 发送 读 地址高位 */
    SPI_FLASH_SendByte((ReadAddr & 0xFF0000) >> 16);
    /* 发送 读 地址中位 */
    SPI_FLASH_SendByte((ReadAddr& 0xFF00) >> 8);
    /* 发送 读 地址低位 */
    SPI_FLASH_SendByte(ReadAddr & 0xFF);

    /* 读取数据 */
    while (NumByteToRead--)
    {
        /* 读取一个字节*/
        *pBuffer = SPI_FLASH_SendByte(Dummy_Byte);
        /* 指向下一个字节缓冲区 */
        pBuffer++;
    }

    /* 停止信号 FLASH: CS 高电平 */
    SPI_FLASH_CS_HIGH();
}
```
由于读取的数据量没有限制，所以发送读命令后一直接收NumByteToRead个数据到结束即可。

#### 25.4.2.3. main函数

最后我们来编写main函数，进行FLASH芯片读写校验，见 [代码清单:SPI-14](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-14) 。

代码清单:SPI-14 main函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/SPI.html#spi-14 "永久链接至代码")

```C
int main(void)
{
    LED_GPIO_Config();
    LED_BLUE;

    /* 配置串口1为：115200 8-N-1 */
    USART_Config();
    printf("\r\n 这是一个8Mbyte串行flash(W25Q64)实验 \r\n");

    /* 8M串行flash W25Q64初始化 */
    SPI_FLASH_Init();

    /* 获取 Flash Device ID */
    DeviceID = SPI_FLASH_ReadDeviceID();
    Delay( 200 );

    /* 获取 SPI Flash ID */
    FlashID = SPI_FLASH_ReadID();
    printf("\r\n FlashID is 0x%X,\
    Manufacturer Device ID is 0x%X\r\n", FlashID, DeviceID);

    /* 检验 SPI Flash ID */
    if (FlashID == sFLASH_ID)
    {
        printf("\r\n 检测到串行flash W25Q64 !\r\n");

        /* 擦除将要写入的 SPI FLASH 扇区，FLASH写入前要先擦除 */
        // 这里擦除4K，即一个扇区，擦除的最小单位是扇区
        SPI_FLASH_SectorErase(FLASH_SectorToErase);

        /* 将发送缓冲区的数据写到flash中 */
        // 这里写一页，一页的大小为256个字节
        SPI_FLASH_BufferWrite(Tx_Buffer, FLASH_WriteAddress, BufferSize);
        printf("\r\n 写入的数据为：%s \r\t", Tx_Buffer);

        /* 将刚刚写入的数据读出来放到接收缓冲区中 */
        SPI_FLASH_BufferRead(Rx_Buffer, FLASH_ReadAddress, BufferSize);
        printf("\r\n 读出的数据为：%s \r\n", Rx_Buffer);

        /* 检查写入的数据与读出的数据是否相等 */
        TransferStatus1 = Buffercmp(Tx_Buffer, Rx_Buffer, BufferSize);

        if ( PASSED == TransferStatus1 )
        {
            LED_GREEN;
            printf("\r\n 8M串行flash(W25Q64)测试成功!\n\r");
        }
        else
        {
            LED_RED;
            printf("\r\n 8M串行flash(W25Q64)测试失败!\n\r");
        }
    }// if (FlashID == sFLASH_ID)
    else// if (FlashID == sFLASH_ID)
    {
        LED_RED;
        printf("\r\n 获取不到 W25Q64 ID!\n\r");
    }

    while (1);
}
```
函数中初始化了LED、串口、SPI外设，然后读取FLASH芯片的ID进行校验，若ID校验通过则向FLASH的特定地址写入测试数据， 然后再从该地址读取数据，测试读写是否正常。

注意

由于实验板上的FLASH芯片默认已经存储了特定用途的数据，如擦除了这些数据会影响到某些程序的运行。 所以我们预留了FLASH芯片的“第0扇区(0-4096地址)”专用于本实验，如非必要，请勿擦除其它地址的内容。如已擦除， 可在配套资料里找到“刷外部FLASH内容”程序，根据其说明给FLASH重新写入出厂内容。

### 25.4.3. 下载验证

用USB线连接开发板“USB TO UART”接口跟电脑，在电脑端打开串口调试助手， 把编译好的程序下载到开发板。在串口调试助手可看到FLASH测试的调试信息。


# 26. 串行FLASH文件系统FatFs
本章参考资料：《00index_e.html》，这是FatFs官方的编译好的HTML文档，里面有FatFs所有函数的介绍和函数的应用示例，学习FatFs看这个官方的文档即可。

![FatFs参考资料](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/FLASHF002.png)

## 26.1. 文件系统

即使读者可能不了解文件系统，读者也一定对“文件”这个概念十分熟悉。数据在PC上是以文件的形式储存在磁盘中的， 这些数据的形式一般为ASCII码或二进制形式。在上一章我们已经写好了SPI Flash芯片的驱动函数，我们可以非常方便的在SPI Flash芯片上读写数据。 如需要记录本书的书名“零死角玩转STM32-F103系列”，可以把这些文字转化成ASCII码，存储在数组中，然后调用SPI_FLASH_BufferWrite函数， 把数组内容写入到SPI Flash芯片的指定地址上，在需要的时候从该地址把数据读取出来，再对读出来的数据以ASCII码的格式进行解读。

但是，这样直接存储数据会带来极大的不便，如难以记录有效数据的位置，难以确定存储介质的剩余空间，以及应以何种格式来解读数据。 就如同一个巨大的图书馆无人管理，杂乱无章地存放着各种书籍，难以查找所需的文档。想象一下图书馆的采购人员购书后，把书籍往馆内一扔，拍拍屁股走人， 当有人来借阅某本书的时候，就不得不一本本地查找。这样直接存储数据的方式对于小容量的存储介质如EEPROM还可以接受， 但对于SPI Flash芯片或者SD卡之类的大容量设备，我们需要一种高效的方式来管理它的存储内容。

这些管理方式即为文件系统，它是为了存储和管理数据，而在存储介质建立的一种组织结构，这些结构包括操作系统引导区、目录和文件。 常见的windows下的文件系统格式包括FAT32、NTFS、exFAT。在使用文件系统前，要先对存储介质进行格式化。格式化先擦除原来内容， 在存储介质上新建一个文件分配表和目录 。这样，文件系统就可以记录数据存放的物理地址，剩余空间。

使用文件系统时， 数据都以文件的形式存储。写入新文件时，先在目录中创建一个文件索引，它指示了文件存放的物理地址， 再把数据存储到该地址中。当需要读取数据时，可以从目录中找到该文件的索引，进而在相应的地址中读取出数据。 具体还涉及到逻辑地址、簇大小、不连续存储等一系列辅助结构或处理过程。

文件系统的存在使我们在存取数据时，不再是简单地向某物理地址直接读写，而是要遵循它的读写格式。如经过逻辑转换， 一个完整的文件可能被分开成多段存储到不连续的物理地址，使用目录或链表的方式来获知下一段的位置。

上一章的SPI Flash芯片驱动只完成了向物理地址写入数据的工作，而根据文件系统格式的逻辑转换部分则需要额外的代码来完成。 实质上，这个逻辑转换部分可以理解为当我们需要写入一段数据时，由它来求解向什么物理地址写入数据、以什么格式写入及写入一些原始数据以外的信息(如目录)。 这个逻辑转换部分代码我们也习惯称之为文件系统。

## 26.2. FatFs文件系统简介

上面提到的逻辑转换部分代码(文件系统)即为本章的要点，文件系统庞大而复杂，它需要根据应用的文件系统格式而编写， 而且一般与驱动层分离开来，很方便移植，所以工程应用中一般是移植现成的文件系统源码。

FatFs是面向小型嵌入式系统的一种通用的FAT文件系统。它完全是由ANSIC语言编写并且完全独立于底层的I/O介质。 因此它可以很容易地不加修改地移植到其他的处理器当中，如8051、PIC、AVR、SH、Z80、H8、ARM等。FatFs支持FAT12、FAT16、FAT32等格式， 所以我们利用前面写好的SPI Flash芯片驱动，把FatFs文件系统代码移植到工程之中， 就可以利用文件系统的各种函数，对SPI Flash芯片以“文件”格式进行读写操作了。

FatFs文件系统的源码可以从fatfs官网下载:

[http://elm-chan.org/fsw/ff/00index_e.html](http://elm-chan.org/fsw/ff/00index_e.html)

### 26.2.1. FatFs的目录结构

在移植FatFs文件系统到开发板之前，我们先要到FatFs的官网获取源码，官网有对FatFs做详细的介绍，有兴趣可以了解。 解压之后可看到里面有 doc 和 src 这两个文件夹，见图 [FatFs文件目录](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id4) 。 doc 文件夹里面是一些使用帮助文档； src 才是FatFs文件系统的源码。

![FatFs文件目录](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/FLASHF003.png)

### 26.2.2. FatFs帮助文档

打开 doc 文件夹，可看到如图 [doc文件夹的文件目录](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#doc) 的文件目录：

![doc文件夹的文件目录](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/FLASHF004.png)

其中 en 和 ja 这两个文件夹里面是编译好的html文档，讲的是FATFS里面各个函数的使用方法，这些函数都是封装得非常好的函数， 利用这些函数我们就可以操作SPI Flash芯片。有关具体的函数我们在用到的时候再讲解。这两个文件夹的唯一区别就是 en 文件夹下的文档是英文的， ja文件夹下的是日文的。img文件夹包含en和ja文件夹下文件需要用到的图片，还有四个名为app.c文件，内容都是FatFs具体应用例程。 00index_e.html和00index_j.html是一些关于FATFS的简介，至于另外两个文件可以不看。

### 26.2.3. FATFS源码

打开 src 文件夹，可看到如图 [src文件夹的文件目录](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#src) 的文件目录：

![src文件夹的文件目录](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/FLASHF005.png)

option 文件夹下是一些可选的外部c文件，包含了多语言支持需要用到的文件和转换函数。

diskio.c文件是FatFs移植最关键的文件，它为文件系统提供了最底层的访问SPI Flash芯片的方法， FatFs有且仅有它需要用到与SPI Flash芯片相关的函数。 diskio.h定义了FatFs用到的宏，以及diskio.c文件内与底层硬件接口相关的函数声明。

00history.txt介绍了FatFs的版本更新情况。

00readme.txt说明了当前目录下 diskio.c 、diskio.h、ff.c、ff.h、integer.h的功能。

src文件夹下的源码文件功能简介如下：

- integer.h：文件中包含了一些数值类型定义。
    
- diskio.c：包含底层存储介质的操作函数，这些函数需要用户自己实现，主要添加底层驱动函数。
    
- ff.c： FatFs核心文件，文件管理的实现方法。该文件独立于底层介质操作文件的函数，利用这些函数实现文件的读写。
    
- cc936.c：本文件在option目录下，是简体中文支持所需要添加的文件，包含了简体中文的GBK和Unicode相互转换功能函数。
    
- ffconf.h: 这个头文件包含了对FatFs功能配置的宏定义，通过修改这些宏定义就可以裁剪FatFs的功能。如需要支持简体中文， 需要把 ffconf.h中的_CODE_PAGE 的宏改成936并把上面的cc936.c文件加入到工程之中。*
    

小技巧

建议阅读这些源码的顺序为： integer.h –> diskio.c –> ff.c 。 阅读文件系统源码ff.c文件需要一定的功底，建议读者先阅读FAT32的文件格式，再去分析ff.c文件。若仅为使用文件系统， 则只需要理解integer.h及diskio.c文件并会调用ff.c文件中的函数就可以了。 本章主要讲解如何把FATFS文件系统移植到开发板上，并编写一个简单读写操作范例。

## 26.3. FatFs文件系统移植实验

### 26.3.1. FatFs程序结构图
移植FatFs之前我们先通过FatFs的程序结构图了解FatFs在程序中的关系网络，见图 [FatFs程序结构图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id9) 。

![FatFs程序结构图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/FLASHF006.png)

用户应用程序需要由用户编写，想实现什么功能就编写什么的程序，一般我们只用到f_mount()、f_open()、f_write()、f_read()就可以实现文件的读写操作。

FatFs组件是FatFs的主体，文件都在源码src文件夹中，其中ff.c、ff.h、integer.h以及diskio.h四个文件我们不需要改动，只需要修改ffconf.h和diskio.c两个文件。

底层设备输入输出要求实现存储设备的读写操作函数、存储设备信息获取函数等等。我们使用SPI Flash芯片作为物理设备， 在上一章节已经编写好了SPI Flash芯片的驱动程序，这里我们就直接使用。

### 26.3.2. 硬件设计

FatFs属于软件组件，不需要附带其他硬件电路。我们使用SPI Flash芯片作为物理存储设备，其硬件电路在上一章已经做了分析，这里就直接使用。

### 26.3.3. FatFs移植步骤
上一章我们已经实现了SPI Flash芯片驱动程序，并实现了读写测试， 为移植FatFs方便，我们直接拷贝一份工程， 我们在工程基础上添加FatFs组件，并修改main函数的用户程序即可。

1) 先拷贝一份SPI Flash芯片测试的工程文件(整个文件夹)，并修改文件夹名为“SPI—FatFs文件系统”。 将FatFs源码中的src文件夹整个文件夹拷贝一份至“SPI—FatFs文件系统USER”文件夹下并修改名为“FATFS”， 见图 [拷贝FatFs源码到工程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id12) 。

![拷贝FatFs源码到工程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/FLASHF007.png)

2) 使用KEIL软件打开工程文件(..SPI—FatFs文件系统ProjectRVMDK(uv5)\ BH-F103.uvprojx)， 并将FatFs组件文件添加到工程中， 需要添加有ff.c、diskio.c和cc936.c三个文件，见图 [添加FatFS文件到工程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id13) 。

![添加FatFS文件到工程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/FLASHF008.jpg)

3) 添加FATFS文件夹到工程的include选项中。打开工程选项对话框，选择“C/C++”选项下的“Include Paths”项目， 在弹出路径设置对话框中选择添加“FATFS”文件夹，见图 [添加FATFS路径到工程选项](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id14) 。

![添加FATFS路径到工程选项](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/FLASHF009.jpg)

4) 如果现在编译工程，可以发现有两个错误，一个是来自diskio.c文件，提示有一些头文件没找到， diskio.c文件内容是与底层设备输入输出接口函数文件，不同硬件设计驱动就不同，需要的文件也不同； 另外一个错误来自cc936.c文件，提示该文件不是工程所必需的，这是因为FatFs默认使用日语， 我们想要支持简体中文需要修改FatFs的配置，即修改ffconf.h文件。至此，将FatFs添加到工程的框架已经操作完成， 接下来要做的就是修改diskio.c文件和ffconf.h文件。

### 26.3.4. FatFs底层设备驱动函数
FatFs文件系统与底层介质的驱动分离开来，对底层介质的操作都要交给用户去实现，它仅仅是提供了一个函数接口而已。 表 [FatFs移植需要用户支持函数](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id16) 为FatFs移植时用户必须支持的函数。 通过表 [FatFs移植需要用户支持函数](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id16) 我们可以清晰知道很多函数是在一定条件下才需要添加的， 只有前三个函数是必须添加的。我们完全可以根据实际需求选择实现用到的函数。

前三个函数是实现读文件最基本需求。接下来三个函数是实现创建文件、修改文件需要的。为实现格式化功能， 需要在disk_ioctl添加两个获取物理设备信息选项。我们一般只要实现前面六个函数就可以了，已经足够满足大部分功能。

为支持简体中文长文件名称需要添加ff_convert和ff_wtoupper函数，实际这两个已经在cc936.c文件中实现，我们只要直接把cc936.c文件添加到工程中就可以。

后面六个函数一般都不用。如真有需要可以参考syscall.c文件(srcoption文件夹内)。

![FatFs移植需要用户支持函数](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/_images/FLASHF01.png)

底层设备驱动函数是存放在diskio.c文件，我们的目的就是把diskio.c中的函数接口与SPI Flash芯片驱动连接起来。 总共有五个函数，分别为设备状态获取(disk_status)、设备初始化(disk_initialize)、扇区读取(disk_read)、 扇区写入(disk_write)、其他控制(disk_ioctl)。

接下来，我们对每个函数结合SPI Flash芯片驱动做详细讲解。

**宏定义**

代码清单:文件系统-1 物理编号宏定义[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id17 "永久链接至代码")

```C
/* 为每个设备定义一个物理编号 */
#define ATA         0     // 预留SD卡使用
#define SPI_FLASH   1     // 外部SPI Flash
```
这两个宏定义在FatFs中非常重要，FatFs是支持多物理设备的，必须为每个物理设备定义一个不同的编号。

SD卡是预留接口，在讲解SDIO接口相关章节后会用到，可以实现使用读写SD卡内文件。

**设备状态获取**

代码清单:文件系统-2设备状态获取[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id18 "永久链接至代码")

```C
DSTATUS disk_status (
    BYTE pdrv   /* 物理编号 */
)
{

    DSTATUS status = STA_NOINIT;

    switch (pdrv) {
    case ATA: /* SD CARD */
        break;

    case SPI_FLASH:
        /* SPI Flash状态检测：读取SPI Flash 设备ID */
        if (sFLASH_ID == SPI_FLASH_ReadID()) {
            /* 设备ID读取结果正确 */
            status &= ~STA_NOINIT;
        } else {
            /* 设备ID读取结果错误 */
            status = STA_NOINIT;;
        }
        break;

    default:
        status = STA_NOINIT;
    }
    return status;
}
```
disk_status函数只有一个参数pdrv，表示物理编号。一般我们都是使用switch函数实现对pdrv的分支判断。 对于SD卡只是预留接口，留空即可。对于SPI Flash芯片，我们直接调用在SPI_FLASH_ReadID()获取设备ID， 然后判断是否正确，如果正确，函数返回正常标准；如果错误，函数返回异常标志。SPI_FLASH_ReadID()是定义在bsp_spi_flash.c文件中，上一章节已做了分析。

**设备初始化**

代码清单:文件系统-3 设备初始化[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id19 "永久链接至代码")

```C
DSTATUS disk_initialize (
    BYTE pdrv       /* 物理编号 */
)
{
    uint16_t i;
    DSTATUS status = STA_NOINIT;
    switch (pdrv) {
    case ATA:          /* SD CARD */
        break;

    case SPI_FLASH:    /* SPI Flash */
        /* 初始化SPI Flash */
        SPI_FLASH_Init();
        /* 延时一小段时间 */
        i=500;
        while (--i);
        /* 唤醒SPI Flash */
        SPI_Flash_WAKEUP();
        /* 获取SPI Flash芯片状态 */
        status=disk_status(SPI_FLASH);
        break;

    default:
        status = STA_NOINIT;
    }
    return status;
}
```
disk_initialize函数也是有一个参数pdrv，用来指定设备物理编号。 对于SPI Flash芯片我们调用SPI_FLASH_Init()函数实现对SPI Flash芯片引脚GPIO初始化配置以及SPI通信参数配置。 SPI_Flash_WAKEUP()函数唤醒SPI Flash芯片，当SPIFlash芯片处于睡眠模式时需要唤醒芯片才可以进行读写操作。

最后调用disk_status函数获取SPI Flash芯片状态，并返回状态值。

**读取扇区**

代码清单:文件系统-4 扇区读取[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id20 "永久链接至代码")

```C
DRESULT disk_read (
    BYTE pdrv,    /* 设备物理编号(0..) */
    BYTE *buff,   /* 数据缓存区 */
    DWORD sector, /* 扇区首地址 */
    UINT count    /* 扇区个数(1..128) */
)
{
    DRESULT status = RES_PARERR;
    switch (pdrv) {
    case ATA: /* SD CARD */
        break;

    case SPI_FLASH:
        /* 扇区偏移2MB，外部Flash文件系统空间放在SPI Flash后面6MB空间 */
        sector+=512;
        SPI_FLASH_BufferRead(buff, sector <<12, count<<12);
        status = RES_OK;
        break;

    default:
        status = RES_PARERR;
    }
    return status;
}
```
disk_read函数有四个形参。pdrv为设备物理编号。buff是一个BYTE类型指针变量，buff指向用来存放读取到数据的存储区首地址。 sector是一个DWORD类型变量，指定要读取数据的扇区首地址。count是一个UINT类型变量，指定扇区数量。

BYTE类型实际是unsigned char类型，DWORD类型实际是unsigned long类型， UINT类型实际是 unsigned int类型，类型定义在integer.h文件中。

开发板使用的SPI Flash芯片型号为W25Q64FV，每个扇区大小为4096个字节(4KB)，总共有8M字节空间， 为兼容后面实验程序，我们只将后部分6MB空间分配给FatFs使用，前部分2MB空间用于其他实验需要，即FatFs是从2MB空间开始， 为实现这个效果需要将所有的读写地址都偏移512个扇区空间。

对于SPI Flash芯片，主要是使用SPI_FLASH_BufferRead()实现在指定地址读取指定长度的数据，它接收三个参数， 第一个参数为指定数据存放地址指针。第二个参数为指定数据读取地址，这里使用左移运算符，左移12位实际是乘以4096， 这与每个扇区大小是息息相关的。第三个参数为读取数据个数，也是需要使用左移运算符。

**扇区写入**

代码清单:文件系统-5 扇区写入[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id21 "永久链接至代码")

```C
DRESULT disk_write (
    BYTE pdrv,        /* 设备物理编号(0..) */
    const BYTE *buff, /* 欲写入数据的缓存区 */
    DWORD sector,     /* 扇区首地址 */
    UINT count        /* 扇区个数(1..128) */
)
{
    uint32_t write_addr;
    DRESULT status = RES_PARERR;
    if (!count) {
        return RES_PARERR;    /* Check parameter */
    }

    switch (pdrv) {
    case ATA: /* SD CARD */
        break;

    case SPI_FLASH:
        /* 扇区偏移2MB，外部Flash文件系统空间放在SPI Flash后面6MB空间 */
        sector+=512;
        write_addr = sector<<12;
        SPI_FLASH_SectorErase(write_addr);
        SPI_FLASH_BufferWrite((u8 *)buff,write_addr,count<<12);
        status = RES_OK;
        break;

    default:
        status = RES_PARERR;
    }
    return status;
}
```
disk_write函数有四个形参，pdrv为设备物理编号。buff指向待写入扇区数据的首地址。sector，指定要写入数据的扇区首地址。 count指定扇区数量。对于SPI Flash芯片，在写入数据之前需要先擦除，所以用到扇区擦除函数(SPI_FLASH_SectorErase)。 然后就是在调用数据写入函数(SPI_FLASH_BufferWrite)把数据写入到指定位置内。

**其他控制**

代码清单:文件系统-6 其他控制[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id22 "永久链接至代码")

```C
DRESULT disk_ioctl (
    BYTE pdrv,    /* 物理编号 */
    BYTE cmd,     /* 控制指令 */
    void *buff    /* 写入或者读取数据地址指针 */
)
{
    DRESULT status = RES_PARERR;
    switch (pdrv) {
    case ATA: /* SD CARD */
        break;

    case SPI_FLASH:
        switch (cmd) {
        /* 扇区数量：1536*4096/1024/1024=6(MB) */
        case GET_SECTOR_COUNT:
            *(DWORD * )buff = 1536;
            break;
        /* 扇区大小  */
        case GET_SECTOR_SIZE :
            *(WORD * )buff = 4096;
            break;
        /* 同时擦除扇区个数 */
        case GET_BLOCK_SIZE :
            *(DWORD * )buff = 1;
            break;
        }
        status = RES_OK;
        break;

    default:
        status = RES_PARERR;
    }
    return status;
}
```
disk_ioctl函数有三个形参，pdrv为设备物理编号，cmd为控制指令，包括发出同步信号、获取扇区数目、获取扇区大小、 获取擦除块数量等等指令，buff为指令对应的数据指针。

对于SPI Flash芯片，为支持FatFs格式化功能， 需要用到获取扇区数量(GET_SECTOR_COUNT)指令和获取擦除块数量(GET_BLOCK_SIZE)指令。 另外，SD卡扇区大小为512字节，SPI Flash芯片一般设置扇区大小为4096字节，所以需要用到获取扇区大小(GET_SECTOR_SIZE)指令。

**时间戳获取**

代码清单:文件系统-7 时间戳获取[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id23 "永久链接至代码")

```C
__weak DWORD get_fattime(void)
{
    /* 返回当前时间戳 */
    return    ((DWORD)(2015 - 1980) << 25)  /* Year 2015 */
            | ((DWORD)1 << 21)        /* Month 1 */
            | ((DWORD)1 << 16)        /* Mday 1 */
            | ((DWORD)0 << 11)        /* Hour 0 */
            | ((DWORD)0 << 5)         /* Min 0 */
            | ((DWORD)0 >> 1);        /* Sec 0 */
}
```
get_fattime函数用于获取当前时间戳，在ff.c文件中被调用。FatFs在文件创建、被修改时会记录时间， 这里我们直接使用赋值方法设定时间戳。为更好的记录时间，可以使用控制器RTC功能，具体要求返回值格式为：

- bit31:25 ——从1980至今是多少年，范围是 (0..127) ；
    
- bit24:21 ——月份，范围为 (1..12) ；
    
- bit20:16 ——该月份中的第几日，范围为(1..31) ；
    
- bit15:11——时，范围为 (0..23)；
    
- bit10:5 ——分，范围为 (0..59)；
    
- bit4:0 ——秒/ 2，范围为 (0..29) 。
    

### 26.3.5. FatFs功能配置[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id24 "永久链接至标题")

ffconf.h文件是FatFs功能配置文件，我们可以对文件内容进行修改，使得FatFs更符合我们的要求。 ffconf.h对每个配置选项都做了详细的使用情况说明。下面只列出修改的配置，其他配置采用默认即可。

代码清单:文件系统-8 FatFs功能配置选项[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id25 "永久链接至代码")

```C
#define _USE_MKFS   1
#define _CODE_PAGE  936
#define _USE_LFN    2
#define _VOLUMES    2
#define _MIN_SS     512
#define _MAX_SS     4096
```
1) _USE_MKFS： 格式化功能选择，为使用FatFs格式化功能，需要把它设置为1。

2) _CODE_PAGE： 语言功能选择，并要求把相关语言文件添加到工程宏。为支持简体中文文件名需要使用“936”， 正如在图 [添加FatFS文件到工程](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id13) 的操作，我们已经把cc936.c文件添加到工程中。

3) _USE_LFN： 长文件名支持，默认不支持长文件名，这里配置为2，支持长文件名，并指定使用栈空间为缓冲区。

4) _VOLUMES： 指定物理设备数量，这里设置为2，包括预留SD卡和SPI Flash芯片。

5) _MIN_SS 、_MAX_SS： 指定扇区大小的最小值和最大值。SD卡扇区大小一般都为512字节，SPI Flash芯片扇区大小一般设置为4096字节，所以需要把_MAX_SS改为4096。

### 26.3.6. FatFs功能测试[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id26 "永久链接至标题")

移植操作到此，就已经把FatFs全部添加到我们的工程了，这时我们编译功能，顺利编译通过，没有错误。接下来， 我们就可以使用编写图 [FatFs程序结构图](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id9) 中用户应用程序了。

主要的测试包括格式化测试、文件写入测试和文件读取测试三个部分，主要程序都在main.c文件中实现。

**变量定义**

代码清单:文件系统-9 变量定义[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id27 "永久链接至代码")

```C
FATFS fs;                         /* FatFs文件系统对象 */
FIL fnew;                         /* 文件对象 */
FRESULT res_flash;                /* 文件操作结果 */
UINT fnum;                        /* 文件成功读写数量 */
BYTE buffer[1024]= {0};           /* 读缓冲区 */
BYTE textFileBuffer[] =           /* 写缓冲区*/
    "欢迎使用野火STM32开发板 今天是个好日子，新建文件系统测试文件\r\n";
```
FATFS是在ff.h文件定义的一个结构体类型，针对的对象是物理设备，包含了物理设备的物理编号、扇区大小等等信息， 一般我们都需要为每个物理设备定义一个FATFS变量。

FIL也是在ff.h文件定义的一个结构体类型，针对的对象是文件系统内具体的文件，包含了文件很多基本属性，比如文件大小、 路径、当前读写地址等等。如果需要在同一时间打开多个文件进行读写，才需要定义多个FIL变量，不然一般定义一个FIL变量即可。

FRESULT是也在ff.h文件定义的一个枚举类型，作为FatFs函数的返回值类型，主要管理FatFs运行中出现的错误。总共有19种错误类型， 包括物理设备读写错误、找不到文件、没有挂载工作空间等等错误。这在实际编程中非常重要，当有错误出现时我们要停止文件读写， 通过返回值我们可以快速定位到错误发生的可能地点。如果运行没有错误才返回FR_OK。

fnum是个32位无符号整形变量，用来记录实际读取或者写入数据的数组。

buffer和textFileBuffer分别对应读取和写入数据缓存区，都是8位无符号整形数组。

**主函数**

代码清单:文件系统-10 主函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id28 "永久链接至代码")

```C
int main(void)
{
    /* 初始化LED */
    LED_GPIO_Config();
    LED_BLUE;

    /* 初始化调试串口，一般为串口1 */
    USART_Config();
    printf("****** 这是一个SPI FLASH 文件系统实验 ******\r\n");

    //在外部SPI Flash挂载文件系统，文件系统挂载时会对SPI设备初始化
    //初始化函数调用流程如下
    //f_mount()->find_volume()->disk_initialize->SPI_FLASH_Init()
    res_flash = f_mount(&fs,"1:",1);

    /*----------------------- 格式化测试 -----------------*/
    /* 如果没有文件系统就格式化创建创建文件系统 */
    if (res_flash == FR_NO_FILESYSTEM)
    {
        printf("》FLASH还没有文件系统，即将进行格式化...\r\n");
        /* 格式化 */
        res_flash=f_mkfs("1:",0,0);

        if (res_flash == FR_OK)
        {
            printf("》FLASH已成功格式化文件系统。\r\n");
            /* 格式化后，先取消挂载 */
            res_flash = f_mount(NULL,"1:",1);
            /* 重新挂载 */
            res_flash = f_mount(&fs,"1:",1);
        }
        else
        {
            LED_RED;
            printf("《《格式化失败。》》\r\n");
            while (1);
        }
    }
    else if (res_flash!=FR_OK)
    {
        printf("！！外部Flash挂载文件系统失败。(%d)\r\n",res_flash);
        printf("！！可能原因：SPI Flash初始化不成功。\r\n");
        while (1);
    }
    else
    {
        printf("》文件系统挂载成功，可以进行读写测试\r\n");
    }

    /*----------------------- 文件系统测试：写测试 -------------------*/
    /* 打开文件，每次都以新的形式打开，属性为可写 */
    printf("\r\n****** 即将进行文件写入测试... ******\r\n");
    res_flash = f_open(&fnew, "1:FatFs读写测试文件.txt",
                    FA_CREATE_ALWAYS | FA_WRITE );
    if ( res_flash == FR_OK )
    {
        printf("》打开/创建FatFs读写测试文件.txt文件成功，向文件写入数据。\r\n");
        /* 将指定存储区内容写入到文件内 */
        res_flash=f_write(&fnew,WriteBuffer,sizeof(WriteBuffer),&fnum);
        if (res_flash==FR_OK)
        {
            printf("》文件写入成功，写入字节数据：%d\n",fnum);
            printf("》向文件写入的数据为：\r\n%s\r\n",WriteBuffer);
        }
        else
        {
            printf("！！文件写入失败：(%d)\n",res_flash);
        }
        /* 不再读写，关闭文件 */
        f_close(&fnew);
    }
    else
    {
        LED_RED;
        printf("！！打开/创建文件失败。\r\n");
    }

    /*------------------- 文件系统测试：读测试 --------------------------*/
    printf("****** 即将进行文件读取测试... ******\r\n");
    res_flash = f_open(&fnew, "1:FatFs读写测试文件.txt",
                    FA_OPEN_EXISTING | FA_READ);
    if (res_flash == FR_OK)
    {
        LED_GREEN;
        printf("》打开文件成功。\r\n");
        res_flash = f_read(&fnew, ReadBuffer, sizeof(ReadBuffer), &fnum);
        if (res_flash==FR_OK)
        {
            printf("》文件读取成功,读到字节数据：%d\r\n",fnum);
            printf("》读取得的文件数据为：\r\n%s \r\n", ReadBuffer);
        }
        else
        {
            printf("！！文件读取失败：(%d)\n",res_flash);
        }
    }
    else
    {
        LED_RED;
        printf("！！打开文件失败。\r\n");
    }
    /* 不再读写，关闭文件 */
    f_close(&fnew);

    /* 不再使用文件系统，取消挂载文件系统 */
    f_mount(NULL,"1:",1);

    /* 操作完成，停机 */
    while (1)
    {
    }
}
```
首先，初始化RGB彩灯和调试串口，用来指示程序进程。

FatFs的第一步工作就是使用f_mount函数挂载工作区。f_mount函数有三个形参，第一个参数是指向FATFS变量指针，如果赋值为NULL可以取消物理设备挂载。 第二个参数为逻辑设备编号，使用设备根路径表示，与物理设备编号挂钩，在 [代码清单:文件系统-1](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id17) 中我们定义SPI Flash芯片物理编号为1，所以这里使用“1：”。 第三个参数可选0或1，1表示立即挂载，0表示不立即挂载，延迟挂载。 f_mount函数会返回一个FRESULT类型值，指示运行情况。

如果f_mount函数返回值为FR_NO_FILESYSTEM，说明没有FAT文件系统，比如新出厂的SPI Flash芯片就没有FAT文件系统。 我们就必须对物理设备进行格式化处理。使用f_mkfs函数可以实现格式化操作。f_mkfs函数有三个形参， 第一个参数为逻辑设备编号；第二参数可选0或者1，0表示设备为一般硬盘，1表示设备为软盘。第三个参数指定扇区大小，如果为0， 表示通过 [代码清单:文件系统-6](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id22) 中disk_ioctl函数获取。格式化成功后需要先取消挂载原来设备，再重新挂载设备。

在设备正常挂载后，就可以进行文件读写操作了。使用文件之前，必须使用f_open函数打开文件，不再使用文件必须使用f_close函数关闭文件， 这个跟电脑端操作文件步骤类似。f_open函数有三个形参，第一个参数为文件对象指针。第二参数为目标文件，包含绝对路径的文件名称和后缀名。 第三个参数为访问文件模式选择，可以是打开已经存在的文件模式、读模式、写模式、新建模式、总是新建模式等的或运行结果。比如对于写测试， 使用FA_CREATE_ALWAYS和FA_WRITE组合模式，就是总是新建文件并进行写模式。

f_close函数用于不再对文件进行读写操作关闭文件，f_close函数只要一个形参，为文件对象指针。f_close函数运行可以确保缓冲区完全写入到文件内。

成功打开文件之后就可以使用f_write函数和f_read函数对文件进行写操作和读操作。这两个函数用到的参数是一致的，只不过一个是数据写入， 一个是数据读取。f_write函数第一个形参为文件对象指针，使用与f_open函数一致即可。第二个参数为待写入数据的首地址， 对于f_read函数就是用来存放读出数据的首地址。第三个参数为写入数据的字节数，对于f_read函数就是欲读取数据的字节数。 第四个参数为32位无符号整形指针，这里使用fnum变量地址赋值给它，在运行读写操作函数后，fnum变量指示成功读取或者写入的字节个数。

最后，不再使用文件系统时，使用f_mount函数取消挂载。

### 26.3.7. 下载验证
保证开发板相关硬件连接正确，用USB线连接开发板“USB TOUART”接口跟电脑，在电脑端打开串口调试助手，把编译好的程序下载到开发板。 程序开始运行后，RGB彩灯为蓝色，在串口调试助手可看到格式化测试、 写文件检测和读文件检测三个过程；最后如果所有读写操作都正常，RGB彩灯会指示为绿色，如果在运行中FatFs出现错误RGB彩灯指示为红色。

虽然我们通过RGB彩灯指示和串口调试助手信息打印方法来说明FatFs移植成功，并顺利通过测试，但心底总是很踏实，所谓眼见为实， 虽然我们创建了“FatFs读写测试文件.txt”这个文件，却完全看不到实体。这个确实是个问题，因为我们这里使用SPI Flash芯片作为物理设备， 并不像SD卡那么方便直接用读卡器就可以在电脑端打开验证。另外一个问题，就目前来说， 在SPI Flash芯片上挂载FatFs好像没有实际意义，无法发挥文件系统功能。

实际上，这里归根到底就是我们目前没办法在电脑端查看SPI Flash芯片内FatFs的内容，没办法非常方便拷贝、删除文件。我们当然不会做无用功， STM32控制器还有一个硬件资源可以解决上面的问题，就是USB！我们可以通过编程把整个开发板变成一个U盘，而U盘存储空间就是SPI Flash芯片的空间。 这样非常方便实现文件读写。至于USB内容将在USB相关章节讲解。

## 26.4. FatFs功能使用实验
上个实验我们实现了FatFs的格式化、读文件和写文件功能，这个已经满足很多部分的运用需要。有时，我们需要更多的文件操作功能， FatFs还是提供了不少的功能的，比如设备存储空间信息获取、读写文件指针定位、创建目录、文件移动和重命名、文件或目录信息获取等等功能。 我们接下来这个实验内容就是展示FatFs众多功能，提供一个很好了范例，以后有用到相关内容，参考使用非常方便。

### 26.4.1. 硬件设计

本实验主要使用FatFs软件功能，不需要其他硬件模块，使用与FatFs移植实验相同硬件配置即可。

### 26.4.2. 软件设计
上个实验我们已经移植好了FatFs，这个例程主要是应用，所以简单起见，直接拷贝上个实验的工程文件，保持FatFs底层驱动程序， 我们只改main.c文件内容，实现应用程序。

**FatFs多项功能测试**

代码清单:文件系统-11 FatFs多项功能测试[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id33 "永久链接至代码")

```C
/* FatFs多项功能测试 */
static FRESULT miscellaneous(void)
{
    DIR dir;
    FATFS *pfs;
    DWORD fre_clust, fre_sect, tot_sect;

    printf("\n*************** 设备信息获取 ***************\r\n");
    /* 获取设备信息和空簇大小 */
    res_flash = f_getfree("1:", &fre_clust, &pfs);

    /* 计算得到总的扇区个数和空扇区个数 */
    tot_sect = (pfs->n_fatent - 2) * pfs->csize;
    fre_sect = fre_clust * pfs->csize;

    /* 打印信息(4096 字节/扇区) */
    printf("》设备总空间：%10lu KB。\n》可用空间：  %10lu KB。\n",
        tot_sect *4, fre_sect *4);

    printf("\n******** 文件定位和格式化写入功能测试 ********\r\n");
    res_flash = f_open(&fnew, "1:FatFs功能测试文件.txt",
                    FA_CREATE_ALWAYS|FA_WRITE|FA_READ );
    res_flash=f_write(&fnew,"欢迎使用野火STM32开发板",50,&fnum);
    if ( res_flash == FR_OK )
    {
        /*  文件定位，定位到文件的末尾 */
        res_flash = f_lseek(&fnew,f_size(&fnew)-1);
        if (res_flash == FR_OK)
        {
            /* 格式化写入，参数格式类似printf函数 */
            f_printf(&fnew,"\n在原来文件新添加一行内容\n");
            f_printf(&fnew,"》设备总空间：%10lu KB。\n》可用空间;%10lu KB。\n",
                    tot_sect *4, fre_sect *4);
            /*  文件定位到文件起始位置 */
            res_flash = f_lseek(&fnew,0);
            /* 读取文件所有内容到缓存区 */
            res_flash = f_read(&fnew,readbuffer,f_size(&fnew),&fnum);
            if (res_flash == FR_OK)
            {
                printf("》文件内容：\n%s\n",readbuffer);
            }
        }
        f_close(&fnew);

        printf("\n********** 目录创建和重命名功能测试 **********\r\n");
        /* 尝试打开目录 */
        res_flash=f_opendir(&dir,"1:TestDir");
        if (res_flash!=FR_OK)
        {
            /* 打开目录失败，就创建目录 */
            res_flash=f_mkdir("1:TestDir");
        }
        else
        {
            /* 如果目录已经存在，关闭它 */
            res_flash=f_closedir(&dir);
            /* 删除文件 */
            f_unlink("1:TestDir/testdir.txt");
        }
        if (res_flash==FR_OK)
        {
            /* 重命名并移动文件 */
            res_flash=f_rename("1:FatFs功能测试文件.txt",
                            "1:TestDir/testdir.txt");
            if (res_flash==FR_OK)
            {
                printf("》重命名并移动文件操作成功\n");
            }
            else
            {
                printf("》重命名并移动文件操作失败：%d\n",res_flash);
            }
        }
    }
    else
    {
        printf("!! 打开文件失败：%d\n",res_flash);
        printf("!! 或许需要再次运行“FatFs移植与读写测试”工程\n");
    }
    return res_flash;
}
```
首先是设备存储信息获取，目的是获取设备总容量和剩余可用空间。f_getfree函数是设备空闲簇信息获取函数，有三个形参，第一个参数为逻辑设备编号； 第二个参数为返回空闲簇数量，这里1簇等于1个扇区；第三个参数为返回指向文件系统对象的指针。通过计算可得到设备总的扇区个数以及空闲扇区个数， 对于SPI Flash芯片我们设置每个扇区为4096字节大小，即4KB。这样很容易就算出设备存储信息。

接下来是文件读写指针定位和格式化输入功能测试。文件定位在一些场合非常有用，比如我们需要记录多项数据，但每项数据长度不确定， 但有个最长长度，我们就可以使用文件定位lseek函数功能把数据存放在规定好的地址空间上。当我们需要读取文件内容时就使用文件定位函数定位到对应地址读取。

使用文件读写操作之前都必须使用f_open函数打开文件，开始的时候读写指针是在文件起始位置的，马上写入数据的话会覆盖原来文件内容。 这里，我们使用f_lseek函数定位到文件末尾位置，再写入内容。f_lseek函数有两个形参，第一个参数为文件对象指针，第二个参数为需要定位的字节数， 这个字节数是相对文件起始位置的，比如设置为0，则将文件读写指针定位到文件起始位置。

f_printf函数是格式化写入函数，需要把ffconf.h文件中的_USE_STRFUNC配置为1才支持。f_printf函数用法类似C库函数printf函数， 只是它将数据直接写入到文件中。

最后是目录创建和文件移动和重命名功能。使用f_opendir函数可以打开路径(这里不区分目录和路径概念，下同)，如果路径不存在则创建， 如果存在则使用f_closedir函数关闭已经打开的路径，并把以前创建的文件删除。新版的FatFs支持相对路径功能，使路径操作更加灵活。 f_opendir函数有两个形参，第一个参数为指向路径对象的指针，第二个参数为路径。f_closedir函数只需要指向路径对象的指针一个形参。

f_mkdir函数用于创建路径，如果指定的路径不存在就创建它，创建的路径存在形式就是文件夹。f_mkdir函数只要一个形参，就是指定路径。

f_rename函数是带有移动功能的重命名函数，它有两个形参，第一个参数为源文件名称，第二个参数为目标名称。目标名称可附带路径， 如果路径与源文件路径不同则移动文件到目标路径下。

**文件信息获取**

代码清单:文件系统-12 文件信息获取[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id34 "永久链接至代码")

```C
static FRESULT file_check(void)
{
    static FILINFO fno;

    /* 获取文件信息，必须确保文件存在*/
    res_flash=f_stat("1:TestDir/testdir.txt",&fno);
    if (res_flash==FR_OK) {
        printf("“testdir.txt”文件信息：\n");
        printf("》文件大小: %ld(字节)\n", fno.fsize);
        printf("》时间戳: %u/%02u/%02u, %02u:%02u\n",
            (fno.fdate >> 9) + 1980, fno.fdate >> 5 & 15, fno.fdate & 31,
            fno.ftime >> 11, fno.ftime >> 5 & 63);
        printf("》属性: %c%c%c%c%c\n\n",
            (fno.fattrib & AM_DIR) ? 'D' : '-',      // 是一个目录
            (fno.fattrib & AM_RDO) ? 'R' : '-',      // 只读文件
            (fno.fattrib & AM_HID) ? 'H' : '-',      // 隐藏文件
            (fno.fattrib & AM_SYS) ? 'S' : '-',      // 系统文件
            (fno.fattrib & AM_ARC) ? 'A' : '-');     // 档案文件
    }
    return res_flash;
}
```
f_stat函数用于获取文件的属性，有两个形参，第一个参数为文件路径，第二个参数为返回指向文件信息结构体变量的指针。 文件信息结构体变量包含文件的大小、最后修改时间和日期、文件属性、短文件名以及长文件名等信息。

路径扫描

代码清单:文件系统-13 路径扫描[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id35 "永久链接至代码")

```C
static FRESULT scan_files (char* path)
{
    FRESULT res;    //部分在递归过程被修改的变量，不用全局变量
    FILINFO fno;
    DIR dir;
    int i;
    char *fn;        // 文件名

#if _USE_LFN
    /* 长文件名支持 */
    /* 简体中文需要2个字节保存一个“字”*/
    static char lfn[_MAX_LFN*2 + 1];
    fno.lfname = lfn;
    fno.lfsize = sizeof(lfn);
#endif
    //打开目录
    res = f_opendir(&dir, path);
    if (res == FR_OK) {
        i = strlen(path);
        for (;;) {
            //读取目录下的内容，再读会自动读下一个文件
            res = f_readdir(&dir, &fno);
            //为空时表示所有项目读取完毕，跳出
            if (res != FR_OK | fno.fname[0] == 0) break;
#if _USE_LFN
            fn = *fno.lfname ? fno.lfname : fno.fname;
#else
            fn = fno.fname;
#endif
            //点表示当前目录，跳过
            if (*fn == '.') continue;
            //目录，递归读取
            if (fno.fattrib & AM_DIR) {
                //合成完整目录名
                sprintf(&path[i], "/%s", fn);
                //递归遍历
                res = scan_files(path);
                path[i] = 0;
                //打开失败，跳出循环
                if (res != FR_OK)
                    break;
            } else {
                printf("%s/%s\r\n", path, fn);              //输出文件名
                /* 可以在这里提取特定格式的文件路径 */
            }//else
        } //for
    }
    return res;
}
```
scan_files函数用来扫描指定路径下的文件。比如我们设计一个mp3播放器，我们需要提取mp3格式文件，诸如*.txt、_.c文件我们统统不可要的， 这时我们就必须扫描路径下所有文件并把_.mp3或*.MP3格式文件提取出来。这里我们不提取特定格式文件，而是把所有文件名称都通过串口打印出来。

我们在ffconf.h文件中定义了长文件名称支持(_USE_LFN=2)，一般有用到简体中文文件名称的都要长文件名支持。短文件名称是8.3格式，即名称是8个字节， 后缀名是3个字节，对于使用英文名称还可以，使用中文名称就很容易长度不够了。使能了长文件名支持后，使用之前需要指定文件名的存储区还有存储区的大小。

接下来就是使用f_opendir函数打开指定的路径。如果路径存在就使用f_readdir函数读取路径下内容，f_readdir函数可以读取路径下的文件或者文件夹， 并保存信息到文件信息对象变量内。f_readdir函数有两个形参，第一个参数为指向路径对象变量的指针，第二个参数为指向文件信息对象的指针。 f_readdir函数另外一个特性是自动读取下一个文件对象，即循序运行该函数可以读取该路径下的所有文件。所以，在程序中， 我们使用for循环让f_readdir函数读取所有文件，并在读取所有文件之后退出循环。

在f_readdir函数成功读取到一个对象时，我们还不清楚它是一个文件还是一个文件夹，此时我们就可以使用文件信息对象变量的文件属性来判断了， 如果判断得出是个文件那我们就直接通过串口打印出来就好了。如果是个文件夹，我们就要进入该文件夹扫描，这时就重新调用扫描函数scan_files就可以了， 形成一个递归调用结构，只是我们这次用的参数与最开始时候是不同的，现在是使用子文件夹名称。

**主函数**

代码清单:文件系统-14 主函数[](https://doc.embedfire.com/mcu/stm32/f103zhinanzhe/std/zh/latest/book/FLASH_FatFs.html#id36 "永久链接至代码")

```C
int main(void)
{
    /* 初始化调试串口，一般为串口1 */
    USART_Config();
    printf("******** 这是一个SPI FLASH 文件系统实验 *******\r\n");

    //在外部SPI Flash挂载文件系统，文件系统挂载时会对SPI设备初始化
    res_flash = f_mount(&fs,"1:",1);
    if (res_flash!=FR_OK) {
        printf("！！外部Flash挂载文件系统失败。(%d)\r\n",res_flash);
        printf("！！可能原因：SPI Flash初始化不成功。\r\n");
        while (1);
    } else {
        printf("》文件系统挂载成功，可以进行测试\r\n");
    }

    /* FatFs多项功能测试 */
    res_flash = miscellaneous();

    printf("\n*************** 文件信息获取测试 **************\r\n");
    res_flash = file_check();

    printf("***************** 文件扫描测试 ****************\r\n");
    strcpy(fpath,"1:");
    scan_files(fpath);

    /* 不再使用文件系统，取消挂载文件系统 */
    f_mount(NULL,"1:",1);

    /* 操作完成，停机 */
    while (1) {
    }
}
```
串口在程序调试中经常使用，可以把变量值直观打印到串口调试助手，这个信息非常重要，同样在使用之前需要调用Debug_USART_Config函数完成调试串口初始化。

使用FatFs进行文件操作之前都使用f_mount函数挂载物理设备，这里我们使用SPI Flash芯片上的FAT文件系统。

接下来我们直接调用miscellaneous函数进行FatFs设备信息获取、文件定位和格式化写入功能以及目录创建和重命名功能测试。 调用file_check函数进行文件信息获取测试。

scan_files函数用来扫描路径下的所有文件，fpath是我们定义的一个包含100个元素的字符型数组， 并将其赋值为SPI Flash芯片物理编号对于的根目录。 这样允许scan_files函数见打印SPIFlash芯片内FatFs所有文件到串口调试助手。注意，这里的定义fpaht数组是必不可少的， 因为scan_files函数本身是个递归函数，要求实际参数有较大空间的缓存区。

### 26.4.3. 下载验证

保证开发板相关硬件连接正确，用USB线连接开发板“USB TO UART”接口跟电脑，在电脑端打开串口调试助手， 把编译好的程序下载到开发板。程序开始运行，在串口调试助手可看到每个阶段测试相关信息情况。