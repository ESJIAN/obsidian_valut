[零基础开胃菜 - C语言中文网 (biancheng.net)](https://c.biancheng.net/c/10/)



# 3. 变量




# 5. 逻辑

## 5.1 设计模式
按照代码的执行顺序，或者执行流程，我们可以将C语言程序分成三种基本结构，分别是顺序结构、选择结构和循环结构：

- 顺序结构就是按照从头到尾的顺序依次执行每一条C语言代码，不重复执行任何代码，也不跳过任何代码。
- 选择结构也称分支结构，就是程序出现了“岔路口”，会有选择性的执行部分代码，而忽略其它代码；换句话说，程序可以跳过没用的代码，只执行有用的代码。
- 循环结构就是让程序“杀个回马枪”，不断地重复执行同一段代码。

  
除了这三种基本结构，C语言其实还有第四种结构，就是跳转结构（通过 [goto](https://c.biancheng.net/view/ol0crux.html) 语句实现），它允许程序跳转到任意一条代码，然后从此处开始执行。不过，频繁使用跳转结构会使得程序的逻辑变得复杂难懂，调试费劲，所以现在已经不推荐使用跳转结构了。  
  
在大学教材，或者考试题目中，通常只会提到“三种基本结构”，很少涉及第四种结构。  

### 5.1.1 顺序结构

顺序结构是最简单的程序结构，也是代码默认的执行顺序。在程序结构中，程序会按照代码的书写顺序从上到下、从左到右依次执行每一条语句。顺序结构的代码就是傻瓜式执行，没有任何拐弯抹角。  
  
本教程前面的代码都是顺序结构，这是初学者最先接触的程序结构。  
  
下面是一个顺序结构的示例，展示了如何计算长方形的面积：

```c
1. #include <stdio.h>

3. int main() {
4.     float length, width, area;

6.     length = 5.0;
7.     width = 3.0;
8.     area = length * width;

10.     printf("长方形的面积是：%.2f\n", area);

12.     return 0;
13. }
```
输出结果：

长方形的面积是：15.00

在这个例子中，程序按照顺序执行以下步骤：声明变量、赋值、计算面积、打印结果。每一步都依次执行，不忽略任何代码，也不重复任何代码。

### 5.1.2 分支结构

在C语言中，我们可以设置一个条件，让程序根据不同的条件执行不同的代码块，这就是分支结构。分支结构就像岔路口，你可以往左走，也可以往右走；具体要怎么走，得根据给出的条件来判断。  
  
C语言有三种方式来实现分支结构，分别是 [if else](https://c.biancheng.net/view/40tjdob.html) 语句、[switch case](https://c.biancheng.net/view/1808.html) 语句、[三目运算符](https://c.biancheng.net/view/296.html)`? :`。  
  
下面的例子使用了 if else 分支结构，用来判断一个数是否是偶数：

```c
1. #include <stdio.h>

3. int main() {
4.     int number;

6.     printf("请输入一个整数：");
7.     scanf("%d", &number);

9.     if (number % 2 == 0) {
10.         //这是第一个代码块
11.         printf("%d 是偶数。\n", number);
12.     } else {
13.         //这是第二个代码块
14.         printf("%d 是奇数。\n", number);
15.     }

17.     return 0;
18. }
```
输出结果（假设输入为 7）：
```bash
请输入一个整数：7↙
7 是奇数。
```

在这个例子中，程序根据「输入的数字是否能被 2 整除」来决定执行哪个代码块，也即`{ }`中的代码。if 语句检查条件`number % 2 == 0`，如果它的结果为真，则执行第一个代码块，否则执行 else 后的代码块。

### 5.1.3 循环结构

C语言循环结构允许程序重复地执行某个代码块，直到满足特定的条件才会终止。循环结构非常适合处理需要重复执行的任务，比如遍历数组、计算累加的和、分析每一条日志等。  
  
C语言提供了三种主要的循环结构，分别是 [for](https://c.biancheng.net/view/1811.html) 循环、[while](https://c.biancheng.net/view/4t0wijh.html) 循环和 do while 循环。  
  
下面的例子使用 for 循环来计算从 1 加到 100 的和：

```c
1. #include <stdio.h>

3. int main() {
4.     int sum = 0;

6.     for (int i = 1; i <= 100; i++) {
7.         //这是重复执行的代码块
8.         sum += i;
9.     }

11.     printf("1 到 100 的和是：%d\n", sum);

13.     return 0;
14. }
```

输出结果：
```bash
1 到 100 的和是：5050
```

在这个例子中，for 循环初始化变量 i 为 1，每次循环 i 增加 1，直到 i 大于 100 时停止。循环体内将每次的 i 值加到 sum 中，最终得到 1 到 100 的和。

### 5.1.4 跳转结构

跳转结构通过 goto 语句实现，它允许程序无条件地跳转到代码中的任意位置，然后从此处开始执行。虽然 goto 语句用起来非常灵活，但是它往往使得程序的逻辑变得混乱难懂，所以现在已经不推荐使用了。  
  
下面的例子中，我们使用 goto 语句跳出嵌套循环：

```c
1. #include <stdio.h>

3. int main() {
4.     int i, j;

6.     for (i = 1; i < 5; i++) {
7.         for (j = 1; j < 5; j++) {
8.             if (i == 2 && j == 2) {
9.                 goto end_loop;
10.             }
11.             printf("i = %d, j = %d\n", i, j);
12.         }
13.     }

15. end_loop:
16.     printf("跳出循环\n");

18.     return 0;
19. }
```

输出结果：

```bash
i = 1, j = 1
i = 1, j = 2
i = 1, j = 3
i = 1, j = 4
i = 2, j = 1
跳出循环
```

在这个例子中，当 i 和 j 都等于 2 时，会执行 goto 语句，直接跳到 end_loop 标签处，然后执行它后面的代码。这意味着，整个循环被跳过了，不再执行了。

```ad-note
title:总结
本文介绍了C语言程序的三种基本结构（顺序结构、选择结构和循环结构），以及一种不常用、不推荐的结构（跳转结构）；对于每种结构，笔者还提供了示例，让大家有一个更加直观的认识。  
  
对于初学者来说，本文中的示例大概率看不懂，不过别着急，接下来的章节我会详细介绍它们的用法，let's go。

```


## 5.2 If else
if else 是C语言中最常用的一种选择结构（分支结构），它会根据不同的条件执行不同的代码块。  
 

在C语言中，我们可以设置一个条件，让程序根据不同的条件执行不同的代码块，这就是分支结构。分支结构就像岔路口，你可以往左走，也可以往右走；具体要怎么走，得根据给出的条件来判断。

### 5.2.1 简介

C语言 if else 语句的基本语法如下：
```c
if(条件){
    //代码块1
    //如果条件为真，执行这里的代码
}else{
    //代码块2
    //如果条件为假，执行这里的代码
}
```

if 语句中`条件`可以是任何有效的C语言表达式，常见的包括比较表达式、逻辑表达式，甚至是简单的变量或者函数调用。  
  
`条件`中的表达式有一个计算结果：

- 如果表达式的结果为非零值（真），则条件成立，执行 if 后面的代码块1；
- 如果表达式的结果为零值（假），则条件不成立，执行 else 后面的代码块2。

所谓代码块，就是由`{ }`包围的一条或者多条语句的集合。

if else 语句的执行流程可以用下图表示：

![C语言if else语句执行流程](https://c.biancheng.net/uploads/allimg/241202/1-2412021F3422F.png)

  

让我们通过一个简单的例子来演示 if else 语句的用法：

```c
1. #include <stdio.h>

3. int main() {
4.     int age;

6.     printf("请输入你的年龄：");
7.     scanf("%d", &age);

9.     if (age >= 18) {
10.         printf("你已经成年了。\n");
11.     } else {
12.         printf("你还未成年。\n");
13.     }

15.     return 0;
16. }
```

这段代码中，`age>=18`是需要判断的条件，`>=`表示“大于等于”，等价于数学中的`≥`。

  
如果条件成立，也即 age 大于或者等于 18，那么执行 if 后面的代码块，打印`"你已经成年了"`；如果条件不成立，也即 age 小于 18，那么执行 else 后面的代码块，打印`"你还未成年"`。  
 

可能的运行结果：

请输入你的年龄：14
你还未成年。

或者：

请输入你的年龄：24
你已经成年了。



### 5.2.2 使用

#### 5.2.2.1 省略大括号

if 和 else 后面的代码块中，如果只有一条语句，那么可以省略`{ }`，例如：

1. if (age >= 18) 
2.     printf("你已经成年了。\n");
3. else
4.     printf("你还未成年。\n");

这种写法虽然从语法上讲是正确的，但是从可读性和规范性上讲，还是强烈建议加上`{ }`，这也是很多公司的编码规范所要求的。

#### 5.2.2.2 省略else

有的时候，我们需要在满足某种条件时进行一些操作，而不满足条件时就不进行任何操作，这个时候我们可以只使用 if 语句，而不使用 else 语句。也就是说，if else 不必同时出现。  
  
单独使用 if 语句的语法如下：

if (条件) {
    //代码块
    // 如果条件为真，执行这里的代码
}

条件是一个有效的C语言表达式，如果表达式的结果为非零值（真），则大括号内的代码块将被执行；如果表达式的结果为零值（假），程序将跳过这个代码块，继续执行 if 语句之后的代码。  
  
if 语句的执行流程可以用下图表示：

![C语言if语句执行流程](https://c.biancheng.net/uploads/allimg/241202/1-2412021I231607.png)

  

让我们通过一个简单的例子来演示 if 语句的用法：

```c
#include <stdio.h>

int main() {
    int age;

    printf("请输入你的年龄：");
    scanf("%d", &age);

    if (age >= 18) {
        printf("你已经成年了\n");
    }

    return 0;
}
```

在这个例子中，我们检查变量 age 是否大于或等于 18：如果条件成立，程序将输出`"你已经成年了"`的消息；如果条件不成立，程序什么也不输出。  
  
可能的输出结果：

请输入你的年龄：24
你已经成年了

或者：

请输入你的年龄：14

#### 5.2.2.3 多重 if else 语句

对于更复杂的条件判断，我们可以使用多重 if else 语句来进行处理。多重 if else 语句的基本语法如下：

if(条件1){
    // 如果条件1成立，执行这里的代码
}else if(条件2){
    // 如果条件2成立，执行这里的代码
}else if(条件3){
    // 如果条件3成立，执行这里的代码
}else{
    // 如果以上所有条件都为假，执行这里的代码
}

在这个结构中，程序会从上到下依次检查每个条件，一旦遇到一个成立的条件，就会执行对应的代码块，然后跳出整个 if else 结构。如果所有条件都不成立，那么最后的 else 块（如果有的话）将被执行。

  
让我们通过一个具体的例子来演示多重 if else 语句的用法：

```c
#include <stdio.h>

int main() {
    int score;
    printf("请输入学生的成绩（0-100）：");
    scanf("%d", &score);

    if (score >= 90 && score <= 100) {
        printf("优秀\n");
    } else if (score >= 80 && score < 90) {
        printf("良好\n");
    } else if (score >= 70 && score < 80) {
        printf("中等\n");
    } else if (score >= 60 && score < 70) {
        printf("及格\n");
    } else if (score >= 0 && score < 60) {
        printf("不及格\n");
    } else {
        printf("输入的成绩无效\n");
    }

    return 0;
}
```

在这个例子中，我们使用多重 if else 语句来输出学生成绩的评级。程序会从上到下检查每个条件，直到找到一个匹配的条件。例如，如果输入的成绩是 85，程序会执行`printf("良好\n");`，然后结束整个 if else 结构。

  
运行这段代码，可能会得到如下输出：

请输入学生的成绩（0-100）：85
良好

使用多重 if else 语句时，有几点需要注意：

- 条件的顺序很重要。由于C语言会按顺序检查条件，一旦找到一个成立的条件就会执行对应的代码块，并跳出整个 if else 结构，所以更具体或更严格的条件应该放在前面。
- else if 的数量没有限制，你可以根据需要添加任意多个 else if 分支。
- 最后的 else 语句是可选的。如果所有条件都不满足，并且没有 else 语句，那么整个 if else 结构将不执行任何操作。

#### 5.2.3.4 嵌套 if else 语句

C语言允许我们在一个条件语句内部再放置另一个条件语句，形成嵌套 if else。这种结构使得我们能够处理更复杂的逻辑判断，实现多层次的决策过程。嵌套 if else 语句的基本思想是：在外层 if 或 else 块的内部再放置一个完整的 if else 语句。  
 

嵌套 if else 语句的一般语法如下：

```c
if (条件1) {
    //当条件1成立时执行这里的代码
    if (条件2) {
        //当条件2成立时执行这里的代码
    } else {
        //当条件2不成立时执行这里的代码
    }
} else {
    //当条件1不成立时执行这里的代码
    if (条件3) {
        //当条件3成立时执行这里的代码
    } else {
        //当条件3不成立时执行这里的代码
    }
}
```

这种结构允许我们创建复杂的决策逻辑，根据多个条件的组合来执行不同的代码块。每一层的 if else 语句都可以根据特定的条件来细分程序的执行路径。

  
让我们通过一个具体的例子来理解嵌套 if else 语句的用法。编写一个程序，根据学生的成绩和出勤率来决定他们是否能够获得奖学金：

```c
1. #include <stdio.h>

3. int main() {
4.     float grade, attendance;

6.     printf("请输入学生的成绩（0-100）：");
7.     scanf("%f", &grade);

9.     printf("请输入学生的出勤率（0-100）：");
10.     scanf("%f", &attendance);

12.     if (grade >= 85) {
13.         if (attendance >= 90) {
14.             printf("恭喜！你获得了一等奖学金！\n");
15.         } else {
16.             printf("很遗憾，虽然你的成绩达标，但出勤率不足。你获得了二等奖学金。\n");
17.         }
18.     } else {
19.         if (attendance >= 95) {
20.             printf("虽然你的成绩未达到一等奖学金标准，但由于出色的出勤率，你获得了三等奖学金。\n");
21.         } else {
22.             printf("很抱歉，你没有获得奖学金的资格。继续努力！\n");
23.         }
24.     }

26.     return 0;
27. }
```

在这个例子中，我们使用嵌套的 if else 语句来处理不同的情况：

- 外层 if 语句检查学生的成绩是否达到 85 分或以上。
- 如果成绩达标，我们进入内层 if 语句，检查出勤率是否达到 90% 或以上。
- 如果成绩未达标，我们进入 else 块，其中包含另一个 if 语句，检查出勤率是否达到 95% 或以上。

  
这段代码使得我们根据成绩和出勤率的不同组合，来决定学生获得的奖学金等级。让我们看几个可能的输出结果：

请输入学生的成绩（0-100）：88
请输入学生的出勤率（0-100）：92
恭喜！你获得了一等奖学金！

请输入学生的成绩（0-100）：90
请输入学生的出勤率（0-100）：85
很遗憾，虽然你的成绩达标，但出勤率不足。你获得了二等奖学金。

请输入学生的成绩（0-100）：80
请输入学生的出勤率（0-100）：96
虽然你的成绩未达到一等奖学金标准，但由于出色的出勤率，你获得了三等奖学金。

请输入学生的成绩（0-100）：75
请输入学生的出勤率（0-100）：88
很抱歉，你没有获得奖学金的资格。继续努力！

虽然嵌套 if else 允许我们处理复杂的条件组合，但需要注意以下几点：

- 过度嵌套可能导致代码难以阅读和维护，一般建议嵌套不要超过三层。
- 对于非常复杂的条件判断，可以考虑使用 switch 语句或者将逻辑拆分为单独的函数。
- 正确的缩进对于提高嵌套 if else 语句的可读性至关重要。

```ad-note
title:总结

if else 语句是C语言中最常用的选择结构（分支结果），它可以根据不同的条件执行不同的代码块，是初学者必须掌握的。

```


## 5.3 关系运算符
在上节《[C语言if else语句的用法](https://c.biancheng.net/view/40tjdob.html)》中看到，if 的判断条件中使用了`>=`、`<=`、`<`等符号，它们专门用在判断条件中，让程序决定下一步的操作，称为关系运算符（Relational Operators）。  
  
C语言关系运算符用来比较两个值之间大小，例如是否相等、大于或小于等。  
  
关系运算符在使用时，它的的两边都会有一个表达式，比如变量、数值、加减乘除运算等，关系运算符的作用就是判明这两个表达式的大小关系。注意，是判明大小关系，不是其他关系。  
  
C语言提供了以下 6 种关系运算符：  

|关系运算符|含  义|数学中的表示|优先级|结合性|
|---|---|---|---|---|
|<|小于|<|高|从左到右|
|<=|小于或等于|≤|
|>|大于|>|
|>=|大于或等于|≥|
|==|等于|=|低|
|!=|不等于|≠|

  
关系运算符都是双目运算符，其结合性均为左结合。关系运算符的优先级低于算术运算符，高于赋值运算符。在六个关系运算符中，<、<=、>、>= 的优先级相同，但是高于 == 和 !=，== 和 != 的优先级相同。

在C语言中，有的运算符有两个操作数，例如 10+20，10 和 20 都是操作数，+ 是运算符。我们将这样的运算符称为双目运算符。同理，将有一个操作数的运算符称为单目运算符，将有三个操作数的运算符称为[三目运算符](https://c.biancheng.net/view/296.html)。  
  
常见的双目运算符有 +、-、*、/ 等，单目运算符有 ++、--  等，三目运算符只有一个，就是`? :`，我们将在《[C语言条件运算符](https://c.biancheng.net/view/1809.html)》中详细介绍。

关系运算符的两边可以是变量、数据或者表达式，例如：  
```
1) a+b > c-d  
2) x > 3/2  
3) 'a'+1 < c  
4) -i-5*j == k+1  
```
  
关系运算符也可以嵌套使用，例如：  
```
1) a > (b > c)  
2) a != (c == d)  
```
  
关系运算符的运算结果只有 0（假）或 1（真）。当条件成立时结果为 1，条件不成立结果为 0。例如：

- 5>0 成立，其值为 1；
- 34-12>100 不成立，其值为 0；
- (a=3)>(b=5) 由于3>5不成立，故其值为 0。

  
在C语言中，我们将零值称为“假”，表示条件不成立；相反，我们将非零值称为“真”，表示条件成立。关系运算符的结果要么是真，要么是假。  
  
下面的代码会将关系运算符的结果输出：

```c
1. #include <stdio.h>
2. int main(){
3.     char c='k';
4.     int i=1, j=2, k=3;
5.     float x=3e+5, y=0.85;
6.     int result_1 = 'a'+5<c, result_2 = x-5.25<=x+y;
7.     printf( "%d, %d\n", result_1, -i-2*j>=k+1 );
8.     printf( "%d, %d\n", 1<j<5, result_2 );
9.     printf( "%d, %d\n", i+j+k==-2*j, k==j==i+5 );
10.     return 0;
11. }
```

运行结果：  
1, 0  
1, 1  
0, 0  
  
对于含多个关系运算符的表达式，如 k==j==i+5，根据运算符的左结合性，先计算 k==j，该式不成立，其值为 0，再计算 0==i+5，也不成立，故表达式值为 0。  
  
关于[条件运算符](https://c.biancheng.net/view/296.html)的更多例子，我们已经在《[C语言if else语句的用法](https://c.biancheng.net/view/40tjdob.html)》中提到，感兴趣的读者请猛击链接查看。  
  
需要提醒的是，`==`才表示等于，而`=`表示赋值，它们是两个不同的运算符，大家要注意区分，切勿混淆。  


> **再谈 if 语句的判断条件**


if 语句的判断条件可以是任何有效的C语言表达式，它的写法是非常灵活的，不一定非要包含条件运算符。判断条件可以是一个赋值语句，或者一个变量，或者一个函数调用，例如：
```c
1. //情况①：判断条件是一个变量
2. if(a){
3.     //TODO:
4. }
5. //情况②：判断条件是一个赋值语句
6. if(b=5){
7.     //TODO:
8. }
9. //情况③：判断条件是一个函数调用
10. char c = 'B';
11. if(isupper(c)){
12.     //TODO:
13. }
```
以上写法都是允许的。只要整个表达式的值为非零，条件就成立；否则，条件就不成立。  
  
在情况①中，变量 a 的值是整个表达式的结果，如果 a 的值为非零，那么条件成立，否则就不成立。  
  
在情况②中，判断条件是一个赋值语句，变量 b 的值是整个表达式的结果。我们把整数 5 赋值给变量 b，那么 b 的值就是 5，整个表达式的值也是 5，它是一个非零值，所以条件成立。  
  
在情况③中，issupper() 函数用来判断字符是否是大写，它的返回值是整个表达式的结果。字符`'B'`是大写，issupper() 返回非零值，条件成立。




## 5.4 逻辑运算符

顾名思义，C语言逻辑运算符是用来处理逻辑运算的。逻辑运算又称布尔运算，它主要用来处理“真值（非零值）”和“假值（零值）”之间的关系。

  
在高中数学中，我们就学过逻辑运算，例如 p 为真命题，q 为假命题，那么“p且q”为假，“p或q”为真，“非q”为真。在C语言中，也有类似的逻辑运算：  
 

|运算符|说明|优先级|结合性|举例|
|---|---|---|---|---|
|!|非运算，单目，对应数学中的“非”。! 右边的表达式为真时，结果为假；! 右边的表达式为假时，结果为真。|高|右结合|!a、!(2<5)|
|&&|与运算，双目，对应数学中的“且”。&& 两边的表达式都为真时，结果为真，否则结果为假。|中|左结合|1&&0、(9>3)&&(b>a)|
|\||或运算，双目，对应数学中的“或”。\| 两边的表达式有一个为真时，结果为真，否则结果为假。|低|左结合|1\|0、(9>3)\|(b>a)|

  

逻辑运算符和[关系运算符](https://c.biancheng.net/view/1806.html)的结果都是布尔类型；布尔类型只有两个取值，分别是真（true）和假（false）；在C语言中，用 1 表示真，用 0 表示假。

  

同时，在逻辑运算或者条件判断的过程中，任何非零值（比如 10、926、-5）都会被视为真，只有零值（比如 0、'\0'）才会被视为假。

  

在《[C语言布尔类型 bool 用法](https://c.biancheng.net/view/rb04id4.html)》一节中提到，支持 [C99](https://c.biancheng.net/view/vip_1742.html) 以及更高标准的编译器，可以用 bool 表示布尔类型，用 true 表示真（非 0 值），用 false 表示假（0 值）。下面的写法都是正确的：

```
1. int age = 20;
2. float score = 95.5;

4. bool isOK = true;
5. bool isAllowEnter = age>=18;
6. bool isExcellentStudent = isAllowEnter && score>90;
```



#### 5.4.1 与运算（&&）

参与运算的两个表达式都为真时，结果才为真，否则为假。例如：

```
5 && 0
```

5 为真，0 为假，相与的结果为假，也就是 0。再如：

```
(5>0) && (4>2)
```

5>0 的结果是 1，为真，4>2 结果是1，也为真，所以相与的结果为真，也就是1 。

#### 5.4.2 或运算（||）

参与运算的两个表达式只要有一个为真，结果就为真；两个表达式都为假时结果才为假。例如：

```
10 || 0 //注意：在二元逻辑运算中除了0之外的数都视为1
```

10 为真，0 为假，相或的结果为真，也就是 1。再如：

```
(5>0) || (5>8)
```

5>0 的结果是1，为真，5>8 的结果是0，为假，所以相或的结果为真，也就是 1。

#### 5.4.3 非运算(!)

参与运算的表达式为真时，结果为假；参与运算的表达式为假时，结果为真。例如：

!0

0 为假，非运算的结果为真，也就是 1。再如：

!(5>0)

5>0 的结果是 1，为真，非运算的结果为假，也就是 0。  
 

输出逻辑运算的结果：

```c
1. #include <stdio.h>
2. int main(){
3.     int a = 0, b = 10, c = -6;
4.     int result_1 = a&&b, result_2 = c||0;
5.     [printf](https://c.biancheng.net/view/ublxqif.html)("%d, %d\n", result_1, !c);
6.     printf("%d, %d\n", 9&&0, result_2);
7.     printf("%d, %d\n", b||100, 0&&0);
8.     return 0;
9. }
```

运行结果：

```c
0, 0  
0, 1  
1, 0
```

### 5.4.4 运算优先级

如果只谈三个逻辑运算符，它们的优先级从低到高依次是：

```c
|| < && < !
```

也就是说，! 的优先级最高，&& 次之，|| 最低。  
  
但是在实际的C语言编程中，逻辑运算符还会和关系运算符、算术运算符、赋值运算符等一起使用，所以我们有必要从整体上比较它们的优先级。逻辑运算符和其它运算符优先级从低到高依次为：

```
赋值运算符`=` < 逻辑运算符`||` < 逻辑运算符`&&` < 关系运算符 < 算术运算符 < 逻辑运算符`!`
```

如果你想知道C语言中所有运算符的优先级和结合性，请转到：[C语言运算符的优先级和结合性一览表](https://c.biancheng.net/view/oblaq24.html)  
   
按照运算符的优先级顺序可以得出：

- a>b && c>d  等价于  (a>b) && (c>d)
- !b==c||d<a  等价于  ( (!b) == c ) || (d<a)
- a+b>c&&x+y<b  等价于  ( (a+b) > c ) && ( (x+y) < b )

  
另外，逻辑表达式也可以嵌套使用，例如`a>b && b || 9>c`，`a || c>d &&  !p`。  
  
结合优先级，再来看一下逻辑运算符的用法：
```c
1. #include <stdio.h>
2. int main(){
3.     char c='k';
4.     int i=1, j=2, k=3;
5.     float x=3e+5, y=0.85;
6.     printf( "%d, %d\n", !x*!y, !!!x );
7.     printf( "%d, %d\n", x||i&&j-3, i<j&&x<y );
8.     printf( "%d, %d\n", i==5&&c&&(j=8), x+y||i+j+k );
9.     return 0;
10. }
```

运行结果：

```bash
0, 0
1, 0
0, 1
```
  
对于!x*!y，! 的优先级高于 *，所以先进行逻辑非运算，再进行乘法运算。x 和 y 分别为非 0，所以 !x 和 !y 分别为 0，所以 !x*!y 的结果为 0。  
 

对于 !!!x，x 为非 0，所以 !x 为 0，!!x 为 1，!!!x 为 0。  
 

对于 x||i&&j-3：先进行减法运算，计算 j-3 的值为非 0；然后进行逻辑与`&&`运算，计算 i&&(j-3) 的结果为 1；最后进行逻辑或`||`运算，计算 x||(i&&j-3) 的结果为 1。  
 

对于 i<j&&x<y：先进行关系运算，求得 i<j 的值为 1，x<y 的值为 0；然后进行逻辑与运算，求得 (i<j) && (x<y) 的结果为 0。  
 

对于 i==5&&c&&(j=8)。先进行比较运算和赋值运算，i==5 不成立，结果 0；而 (j=8) 赋值后的结果为 8，转换成布尔值后为 1。然后再进行逻辑运算，此时 && 是右结合性，所以先计算右边的 &&，得到 c&&(j=8) 的结果为 1；接着再计算左边的 &&，得到 (i==5) && (c&&(j=8)) 的结果为 0。  
 

对于 x+ y||i+j+k：先进行算术运算，得到 x+y 和 i+j+k 的值都是非 0；然后再进行逻辑非`||`运算，得到整个表达式的结果为 1。

### 5.4.5 短路求值

C语言中的逻辑运算符使用短路求值，这意味着：

- 在 && 运算中，如果第一个表达式的结果为假，就不会再计算第二个表达式，因为不管第二个表达式的结果是什么，都不会影响整个 && 运算的结果。
- 在 || 运算中，如果第一个表达式的结果为真，就不会再计算第二个表达式，原理同上。

  
请看下面的例子：
```c
1. #include <stdio.h>

3. int main() {
4.     int x = 5;
5.     int y = 0;

7.     // 由于 x > 10 为假，y != 0 不会被评估
8.     if (x > 10 && y != 0) {
9.         printf("This won't be printed\n");
10.     }

12.     // 由于 x > 0 为真，y != 0 不会被评估
13.     if (x > 0 || y != 0) {
14.         printf("This will be printed\n");
15.     }

17.     return 0;
18. }
```

输出结果：

This will be printed

### 5.4.6 综合示例

逻辑运算符在C语言中有很多应用场景，这里不妨举几个例子。

#### 5.4.6.1 判断闰年

一个年份是闰年的条件是：能被 4 整除但不能被 100 整除，或者能被 400 整除。这个条件被翻译成C语言的逻辑表达式就是：

(year % 4 == 0 && year % 100 != 0) || year % 400 == 0

完整的实现代码如下：

```c
1. #include <stdio.h>

3. int main() {
4.     int year = 0;

6.     printf("请输入年份：");
7.     scanf("%d", &year);

9.     if( (year % 4 == 0 && year % 100 != 0) || year % 400 == 0 ){
10.         printf("%d 是闰年\n", year);
11.     }
12.     else {
13.         printf("%d 不是闰年\n", year);
14.     }

16.     return 0;
17. }
```

运行结果：

请输入年份：2024
2024 是闰年

#### 5.4.6.2 判断元音字母

26 个字母中的元音字母只有 a、e、i、o 和 u 六个，只要输入的字符是其中之一，就是元音字母。请看下面的代码：

```c
1. #include 
2. #include 

4. int main() {
5.     char ch = 0;

7.     printf("请输入一个英文字母：");
8.     scanf("%c", &ch);
9.     ch = tolower(ch);  // 转换为小写字母

11.     if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {
12.         printf("%c 是元音字母\n", ch);
13.     }else {
14.         printf("%c 不是元音字母\n", ch);
15.     }

17.     return 0;
18. }
```

输出结果：

```bash
请输入一个英文字母：U
u 是元音字母
```

## 5.5 Swith case

除了 [if else](https://c.biancheng.net/view/40tjdob.html)，switch case 也是一种常用的选择结构，它会根据一个表达式的不同值，执行不同的代码块。C语言 switch case 语句的用法如下：
```c
switch (表达式) {
    case 整形常量1:
        //代码块 1
        break;
    case 整形常量2:
        //代码块 2
        break;
    ......
    case 整形常量n:
        //代码块n
        break;
    default:
        //默认代码块
}
```
switch case 语句的执行流程如下：  
  
1) 先计算`表达式`的结果，然后将该结果与各个 case 后面的`整形常量`进行比较，看它们的值是否相等。  
  
2) 从第一个 case 开始，依次挨着往后比较，一旦遇到某个相等的`整形常量`，就停止比较，并执行当前 case 后面的`代码块`。  
  
每个`代码块`的后面都有一个 break 语句，用来“跳出”整个 switch 结构，防止继续执行下一个 case 分支；换句话说，一旦遇到 break 语句，整个 switch 结构就执行结束了。  
  
3) 如果比较到最后也没有找到相等的`整形常量`，那么就执行 default 后面的`默认代码块`。default 是“默认”的意思，也就是当没有匹配的 case 分支时，默认执行的一个分支。换句话说，default 分支用来处理所有 case 都不匹配的情况，是负责“兜底”的。  
  
default 是可选择，你可以不写。如果没有 default 分支，也没有匹配的 case 分支，那么 switch 将什么都不执行。  
  
注意，switch case 只能用来匹配整型值（包括 char 类型），不能匹配其它类型的值。虽然`表达式`的写法很灵活，可以是变量、常量、加减乘除运算、函数调用等，但它必须能够得到一个整型值。  
  
在实际开发中，switch case 常用来替代简单的、拥有多个分支的 if else 语句。C语言虽然没有限制 if else 能够处理的分支数量，但当分支过多时，用 if else 处理会不太方便，而且容易出现 if else 配对出错的情况，此时就可以尝试 switch case。  
  
例如，输入一个整数，输出该整数对应的星期几的英文表示，我们可以用 if else 来实现：

```c
1. #include <stdio.h>
2. int main() {
3.     int a;
4.     [printf](https://c.biancheng.net/view/ublxqif.html)("Input integer number:");
5.     [scanf](https://c.biancheng.net/view/yt053k4.html)("%d", &a);

7.     if (a == 1) {
8.         printf("Monday\n");
9.     }else if (a == 2) {
10.         printf("Tuesday\n");
11.     }else if (a == 3) {
12.         printf("Wednesday\n");
13.     }else if (a == 4) {
14.         printf("Thursday\n");
15.     }else if (a == 5) {
16.         printf("Friday\n");
17.     }else if (a == 6) {
18.         printf("Saturday\n");
19.     }else if (a == 7) {
20.         printf("Sunday\n");
21.     }else {
22.         printf("error\n");
23.     }

25.     return 0;
26. }
```

这段代码看起来有点乱糟糟，如果用 switch case 语句来替换，就清晰多了：
```c
1. #include <stdio.h>
2. int main() {
3.     int a;
4.     printf("Input integer number:");
5.     scanf("%d", &a);

7.     switch (a) {
8.     case 1:
9.         printf("Monday\n");
10.         break;
11.     case 2:
12.         printf("Tuesday\n");
13.         break;
14.     case 3:
15.         printf("Wednesday\n");
16.         break;
17.     case 4:
18.         printf("Thursday\n");
19.         break;
20.     case 5:
21.         printf("Friday\n");
22.         break;
23.     case 6:
24.         printf("Saturday\n");
25.         break;
26.     case 7:
27.         printf("Sunday\n");
28.         break;
29.     default:
30.         printf("error\n");
31.     }

33.     return 0;
34. }
```
可能的运行结果：

```bash
Input integer number:4↙
Thursday
```

或者：

```bash
Input integer number:9↙
error
```

### 5.5.1 关于 break

break 是C语言中的一个关键字，专门用来跳出 switch 语句（也可以跳出 [for](https://c.biancheng.net/view/1811.html) 循环和 [while](https://c.biancheng.net/view/4t0wijh.html) 循环）。所谓“跳出”，是指一旦遇到 break，就不再执行 switch 中的任何语句，包括当前分支中的语句，以及其它分支中的语句。也就是说，整个 switch 执行结束了，接下来会执行整个 switch 后面的代码。  
  
为什么要使用 break 呢？因为 switch 有一个坏毛病，就是一旦发现`表达式`的值和某个`整形常量`匹配了，就会执行后面的所有代码，包括当前 case 分支的代码，以及它后面的其它 case 分支的代码。这种现象称为贯穿（fall through）。  
  
也就是说，switch 只会匹配一次，一旦匹配成功了，就会不管不顾地执行后面的代码，而不管其它 case 是否匹配。只有到达 switch 末尾，或者遇到 break 关键字，才会结束整个 switch 的执行。  
  
贯穿往往不是我们所期望的，所以才在每个 case 的后面都加一个 break，这样在执行完当前分支以后就能强制跳出 switch 了。  
  
至于 default 分支最后，加不加 break 都无所谓，因为它往往是 switch 的最后一个分支，有没有 break 都会结束整个 switch 的执行。  
  
修改上面的代码，去掉 break 关键字，看看会发生什么情况：

```c
1. #include <stdio.h>
2. int main() {
3.     int a;
4.     printf("Input integer number:");
5.     scanf("%d", &a);

7.     switch (a) {
8.     case 1:
9.         printf("Monday\n");
10.     case 2:
11.         printf("Tuesday\n");
12.     case 3:
13.         printf("Wednesday\n");
14.     case 4:
15.         printf("Thursday\n");
16.     case 5:
17.         printf("Friday\n");
18.     case 6:
19.         printf("Saturday\n");
20.     case 7:
21.         printf("Sunday\n");
22.     default:
23.         printf("error\n");
24.     }

26.     return 0;
27. }
```

运行结果：
```bash
Input integer number:3↙
Wednesday
Thursday
Friday
Saturday
Sunday
error
```

或者：
```bash
Input integer number:6↙
Saturday
Sunday
error
```

显然，这不是我们想要的输出结果。  
  
不过，贯穿现象也不完全是坏事，我们也可以巧妙地利用贯穿现象，让多个 case 执行相同的代码。例如：

```c
1. switch (grade) {
2.     case 'A':
3.     case 'B':
4.     case 'C':
5.         printf("及格\n");
6.         break;
7.     case 'D':
8.     case 'F':
9.         printf("不及格\n");
10.         break;
11.     default:
12.         printf("无效的成绩\n");
13. }
```

### 5.5.2 关于 case

case 后面除了可以跟整形常量，还可以跟结果是整型的常量表达式，这意味着表达式的值在编译期间就能确定，而不用等到运行时计算得出。  
  
另外，虽然普通变量不能用在 case 后面，但是由 const 修饰的常量是可以的，这是因为 const 常量的值不能修改，在编译期间就能确定。  
  
请看下面的例子：

```c
1. int a = 60;
2. const int b = 5;

4. case 10: printf("..."); break;  //正确
5. case 8+9: printf("..."); break;  //正确,8+9 的值在编译期间就能算出
6. case 'A': printf("..."); break;  //正确，字符和整数可以相互转换
7. case 'A'+19: printf("..."); break;  //正确，字符和整数可以相互转换
8. case 9.5: printf("..."); break;  //错误，不能为小数
9. case a: printf("..."); break;    //错误，不能包含变量
10. case a+10: printf("..."); break;  //错误，不能包含变量
11. case b+2: printf("..."); break;  //正确，b+2 的值在编译期间就能算出
```

### 5.5.3 综合示例

我们通过两个综合的例子，全面地展示一下 switch case 语句的用法。  
  
示例1：使用 switch case 语句实现一个简单的加法器。
```c
1. #include <stdio.h>

3. int main() {
4.     char symbol;
5.     double num1, num2, result;

7.     printf("输入一个运算符 (+, -, *, /): ");
8.     scanf("%c", &symbol);
9.     printf("输入两个数字: ");
10.     scanf("%lf %lf", &num1, &num2);

12.     switch (symbol) {
13.     case '+':
14.         result = num1 + num2;
15.         printf("%.2lf + %.2lf = %.2lf\n", num1, num2, result);
16.         break;
17.     case '-':
18.         result = num1 - num2;
19.         printf("%.2lf - %.2lf = %.2lf\n", num1, num2, result);
20.         break;
21.     case '*':
22.         result = num1 * num2;
23.         printf("%.2lf * %.2lf = %.2lf\n", num1, num2, result);
24.         break;
25.     case '/':
26.         if (num2 != 0) {
27.             result = num1 / num2;
28.             printf("%.2lf / %.2lf = %.2lf\n", num1, num2, result);
29.         }
30.         else {
31.             printf("错误！除数不能为零。\n");
32.         }
33.         break;
34.     default:
35.         printf("错误！无效的运算符。\n");
36.     }

38.     return 0;
39. }
```
运行结果：
```bash
输入一个运算符 (+, -, *, /): +
输入两个数字: 20 837
20.00 + 837.00 = 857.00
```

  
>示例2：输入月份，输出季节。

```c
1. #include <stdio.h>

3. int main() {
4.     int month = 0;
5.     printf("输入月份：");
6.     scanf("%d", &month);

8.     switch (month) {
9.         case 12:
10.         case 1:
11.         case 2:
12.             printf("冬季\n");
13.             break;
14.         case 3:
15.         case 4:
16.         case 5:
17.             printf("春季\n");
18.             break;
19.         case 6:
20.         case 7:
21.         case 8:
22.             printf("夏季\n");
23.             break;
24.         case 9:
25.         case 10:
26.         case 11:
27.             printf("秋季\n");
28.             break;
29.         default:
30.             printf("无效的月份\n");
31.     }

33.     return 0;
34. }
```

运行结果：

```bash
输入月份：9
秋季
```

```ad-note
title:总结

switch case 是C语言中常用的分支结构，特别适合处理有多个离散值的情况。相比编写多个 if else 语句，switch case 通常看起来更加清晰和直观。

```






# 6. 数组


## 6.1 简介
在《[C语言数据输出大汇总以及轻量进阶](https://c.biancheng.net/view/1793.html)》一节中我们举了一个例子，是输出一个 4×4 的整数矩阵，代码如下：

```c
1. #include <stdio.h>
2. #include <stdlib.h>
3. int main()
4. {
5.     int a1=20, a2=345, a3=700, a4=22;
6.     int b1=56720, b2=9999, b3=20098, b4=2;
7.     int c1=233, c2=205, c3=1, c4=6666;
8.     int d1=34, d2=0, d3=23, d4=23006783;

10.     printf("%-9d %-9d %-9d %-9d\n", a1, a2, a3, a4);
11.     printf("%-9d %-9d %-9d %-9d\n", b1, b2, b3, b4);
12.     printf("%-9d %-9d %-9d %-9d\n", c1, c2, c3, c4);
13.     printf("%-9d %-9d %-9d %-9d\n", d1, d2, d3, d4);

15.     system("pause");
16.     return 0;
17. }
```

运行结果：

```c
20        345       700       22
56720     9999      20098     2
233       205       1         6666
34        0         23        23006783
```

矩阵共有 16 个整数，我们为每个整数定义了一个变量，也就是 16 个变量。那么，为了减少变量的数量，让开发更有效率，能不能为多个数据定义一个变量呢？比如，把每一行的整数放在一个变量里面，或者把 16 个整数全部都放在一个变量里面。答案当然是肯定的，办法就是使用数组（Array）。


>**总结**：数组就是多个同一变量类型构成的有序变量，常见的字符串变量全称应该叫做字符串数组变量。其实质是由多个单字符变量组成的一个排列，在内存空间上看：就是把单个字符变量（元素）地址从左到右依次排列在内存空间上，并且给这个字符串数组（集合）分配了一个内存地址，这样你既能够访问大的整体也能够访问这个整体中的元素了。之所以要访问，那是因为访问是读取和修改值的前提。


## 6.2 概念和定义

我们知道，要想把数据放入内存，必须先要分配内存空间。放入4个整数，就得分配4个`int`类型的内存空间：  

```
int a[4];
```

这样，就在内存中分配了4个`int`类型的内存空间，共 4×4=16 个字节，并为它们起了一个名字，叫`a`。  
  
我们把这样的一组数据的集合称为**数组（Array）**，它所包含的每一个数据叫做数组元素（Element），所包含的数据的个数称为数组长度（Length），例如`int a[4];`就定义了一个长度为4的整型数组，名字是`a`。  
  
数组中的每个元素都有一个序号，这个序号从0开始，而不是从我们熟悉的1开始，称为下标（Index）。使用数组元素时，指明下标即可，形式为：

```
arrayName[index]
```
arrayName 为数组名称，index 为下标。例如，a[0] 表示第0个元素，a[3] 表示第3个元素。  
  
接下来我们就把第一行的4个整数放入数组：

```
a[0]=20;
a[1]=345;
a[2]=700;
a[3]=22;
```

这里的0、1、2、3就是数组下标，a[0]、a[1]、a[2]、a[3] 就是数组元素。  
  
在学习过程中，我们经常会使用循环结构将数据放入数组中（也就是为数组元素逐个赋值），然后再使用循环结构输出（也就是依次读取数组元素的值），下面我们就来演示一下如何将 1~10 这十个数字放入数组中：

```c
1. #include <stdio.h>
2. int main(){
3.     int nums[10];
4.     int i;

6.     //将1~10放入数组中
7.     for(i=0; i<10; i++){
8.         nums[i] = (i+1);
9.     }

11.     //依次输出数组元素
12.     for(i=0; i<10; i++){
13.         printf("%d ", nums[i]);
14.     }

16.     return 0;
17. }
```

运行结果：
```bash
1 2 3 4 5 6 7 8 9 10 
```

变量 i 既是数组下标，也是循环条件；将数组下标作为循环条件，达到最后一个元素时就结束循环。数组 nums 的最大下标是 9，也就是不能超过 10，所以我们规定循环的条件是 i<10，一旦 i 达到 10 就得结束循环。  
  
更改上面的代码，让用户输入 10 个数字并放入数组中：

```c
1. #include <stdio.h>
2. int main(){
3.     int nums[10];
4.     int i;

6.     //从控制台读取用户输入
7.     for(i=0; i<10; i++){
8.         scanf("%d", &nums[i]);  //注意取地址符 &，不要遗忘哦
9.     }

11.     //依次输出数组元素
12.     for(i=0; i<10; i++){
13.         printf("%d ", nums[i]);
14.     }

16.     return 0;
17. }
```
运行结果：

```bash
22 18 928 5 4 82 30 10 666 888↙
22 18 928 5 4 82 30 10 666 888 
```

第 8 行代码中，scanf() 读取数据时需要一个地址（地址用来指明数据的存储位置），而 nums[i] 表示一个具体的数组元素，所以我们要在前边加 & 来获取地址。  
  
最后我们来总结一下数组的定义方式：  

```c
dataType  arrayName[length];
```

dataType 为数据类型，arrayName 为数组名称，length 为数组长度。例如：

```
1. float m[12];  //定义一个长度为 12 的浮点型数组
2. char ch[9];  //定义一个长度为 9 的字符型数组
```

  
需要注意的是：  
1) 数组中每个元素的数据类型必须相同，对于`int a[4];`，每个元素都必须为 int。  
  
2) 数组长度 length 最好是整数或者常量表达式，例如 10、20*4 等，这样在所有编译器下都能运行通过；如果 length 中包含了变量，例如 n、4*m 等，在某些编译器下就会报错，我们将在《[C语言变长数组：使用变量指明数组的长度](https://c.biancheng.net/view/vip_1837.html)》一节专门讨论这点。  
  
3) 访问数组元素时，下标的取值范围为 0 ≤ index < length，过大或过小都会越界，导致数组溢出，发生不可预测的情况，我们将在《[C语言数组的越界和溢出](https://c.biancheng.net/view/vip_1836.html)》一节重点讨论，请大家务必要引起注意。

## 6.3 特性

### 6.3.1 内存连续


数组是一个整体，它的内存是连续的；也就是说，数组元素之间是相互挨着的，彼此之间没有一点点缝隙。下图演示了`int a[4];`在内存中的存储情形：  
![](https://c.biancheng.net/uploads/allimg/190102/101402I50-0.png)  
「数组内存是连续的」这一点很重要，所以我使用了一个大标题来强调。连续的内存为[指针](https://c.biancheng.net/c/80/)操作（通过指针来访问数组元素）和内存处理（整块内存的复制、写入等）提供了便利，这使得数组可以作为缓存（临时存储数据的一块内存）使用。大家暂时可能不理解这句话是什么意思，等后边学了指针和内存自然就明白了。  





## 6.4 操作

### 6.4.1 定义
定义一个数组首先得明确一件事，你想要一个什么类型的数组，因为数组是连续元素构成的集合，考虑组建这个大的集合首先我们要考虑小的元素是什么样子的。其次我们再来考虑要多少个元素、这些元素按照什么样的方式排布（一维、二维...）

例：`int a[4]`中的`int`表示每一个小元素（数组元素）的类型，这些小元素决定了这个大集合（数组）的类型，`[4]`表示这个大集合（数组）有四个元素（数组元素）。





### 6.4.2 赋值


- **定义与赋值先后进行**






- **定义与赋值同时进行**

上面的代码是先定义数组再给数组赋值，我们也可以在定义数组的同时赋值，例如：

```
int a[4] = {20, 345, 700, 22};
```

数组元素的值由`{ }`包围，各个值之间以`,`分隔。  
  
**对于数组的初始化需要注意以下几点：**  
1) 可以只给部分元素赋值。当`{ }`中值的个数少于元素个数时，只给前面部分元素赋值。例如：

```
int a[10]={12, 19, 22 , 993, 344};
```

表示只给 a[0]~a[4] 5个元素赋值，而后面 5 个元素自动初始化为 0。  
  
当赋值的元素少于数组总体元素的时候，剩余的元素自动初始化为 0：

- 对于short、int、long，就是整数 0；
- 对于char，就是字符 '\0'；
- 对于float、double，就是小数 0.0。

  
我们可以通过下面的形式将数组的所有元素初始化为 0：

```
int nums[10] = {0};
char str[10] = {0};
float scores[10] = {0.0};
```
由于剩余的元素会自动初始化为 0，所以只需要给第 0 个元素赋值为 0 即可。  
  
2) 只能给元素逐个赋值，不能给数组整体赋值。例如给 10 个元素全部赋值为 1，只能写作：
```
int a[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
```

而不能写作：

```
int a[10] = 1;
```

  
3) 如给全部元素赋值，那么在定义数组时可以不给出数组长度。例如：

```
int a[] = {1, 2, 3, 4, 5};
```

等价于
```
int a[5] = {1, 2, 3, 4, 5};
```

  
最后，我们借助数组来输出一个 4×4 的矩阵：


```c
1. #include <stdio.h>
2. int main()
3. {
4.     int a[4] = {20, 345, 700, 22};
5.     int b[4] = {56720, 9999, 20098, 2};
6.     int c[4] = {233, 205, 1, 6666};
7.     int d[4] = {34, 0, 23, 23006783};

9.     printf("%-9d %-9d %-9d %-9d\n", a[0], a[1], a[2], a[3]);
10.     printf("%-9d %-9d %-9d %-9d\n", b[0], b[1], b[2], b[3]);
11.     printf("%-9d %-9d %-9d %-9d\n", c[0], c[1], c[2], c[3]);
12.     printf("%-9d %-9d %-9d %-9d\n", d[0], d[1], d[2], d[3]);

14.     return 0;
15. }
```



- **从其他变量中获取**




### 6.4.3 修改

- 索引数组




- 单个修改




- 多个修改





### 6.4.4 转化

>**注意**：原生库函数中是没有类似于强制把整形数组转换成字符串的函数的，原因见[链接](https://kimi.moonshot.cn/share/ctcgj54stj633hgut4m0)
- 整形类转化为字符类



# 7. 函数

## 7.1 简介


### 7.1.1 引例


从表面上看，函数在使用时必须带上括号，有必要的话还要传递参数，函数的执行结果也可以赋值给其它变量。例如，strcmp() 是一个用来比较字符串大小的函数，它的用法如下：

```c
1. #include <stdio.h>
2. #include <string.h>
3. int main(){
4.     char str1[] = "http://c.biancheng.net";
5.     char str2[] = "http://www.baidu.com";
6.     //比较两个字符串大小
7.     int result = strcmp(str1, str2);
8.     printf("str1  - str2 = %d\n", result);

10.     return 0;
11. }
```

str1 和 str2 是传递给 strcmp() 的参数，strcmp() 的处理结果赋值给了变量 result。  
  
我们不妨设想一下，如果没有 strcmp() 函数，要想比较两个字符串的大小该怎么写呢？请看下面的代码：
```c
1. #include <stdio.h>
2. #include <string.h>
3. int main(){
4.     char str1[] = "http://c.biancheng.net";
5.     char str2[] = "http://www.baidu.com";
6.     int result, i;
7.     //比较两个字符串大小
8.     for(i=0; (result = str1[i] - str2[i]) == 0; i++){
9.         if(str1[i] == '\0' || str2[i] == '\0'){
10.             break;
11.         }
12.     }

14.     printf("str1  - str2 = %d\n", result);
15.     return 0;
16. }
```

比较字符串大小是常用的功能，一个程序可能会用到很多次，如果每次都写这样一段重复的代码，不但费时费力、容易出错，而且交给别人时也很麻烦，所以C语言提供了一个功能，允许我们将常用的代码以固定的格式封装（包装）成一个独立的模块，只要知道这个模块的名字就可以重复使用它，这个模块就叫做**函数（Function）**。  
  
函数的本质是一段可以重复使用的代码，这段代码被提前编写好了，放到了指定的文件中，使用时直接调取即可。下面我们就来演示一下如何封装 strcmp() 这个函数。

```c
1. #include <stdio.h>

3. //将比较字符串大小的代码封装成函数，并命名为strcmp_alias
4. int strcmp_alias(char *s1, char *s2){
5.     int i, result;
6.     for(i=0; (result = s1[i] - s2[i]) == 0; i++){
7.         if(s1[i] == '\0' || s2[i] == '\0'){
8.             break;
9.         }
10.     }

12.     return result;
13. }

15. int main(){
16.     char str1[] = "http://c.biancheng.net";
17.     char str2[] = "http://www.baidu.com";
18.     char str3[] = "http://data.biancheng.net";
19.     //重复使用strcmp_alias()函数
20.     int result_1_2 = strcmp_alias(str1, str2);
21.     int result_1_3 = strcmp_alias(str1, str3);
22.     printf("str1  - str2 = %d\n", result_1_2);
23.     printf("str1  - str3 = %d\n", result_1_3);

25.     return 0;
26. }
```

为了避免与原有的 strcmp 产生命名冲突，我将新函数命名为 strcmp_alias。  
  
这是我们自己编写的函数，放在了当前源文件中（函数封装和函数使用在同一个源文件中），所以不需要引入头文件；而C语言自带的 strcmp() 放在了其它的源文件中（函数封装和函数使用不在同一个源文件中），并在 string.h 头文件中告诉我们如何使用，所以我们必须引入 string.h 头文件。  
  
我们自己编写的 strcmp_alias() 和原有的 strcmp() 在功能和格式上都是一样的，只是存放的位置不同，所以一个需要引入头文件，一个不需要引入。  
  
本章我们重点讲解的内容就是如何将一段代码封装成函数，以及封装以后如何使用。



### 7.1.2 参数

函数的一个明显特征就是使用时带括号`( )`，有必要的话，括号中还要包含数据或变量，称为参数（Parameter）。参数是函数需要处理的数据，例如：

- `strlen(str1)`用来计算字符串的长度，`str1`就是参数。
- `puts("C语言中文网")`用来输出字符串，`"C语言中文网"`就是参数。

### 7.1.3 返回值

既然函数可以处理数据，那就有必要将处理结果告诉我们，所以很多函数都有返回值（Return Value）。所谓返回值，就是函数的执行结果。例如：

char str1[] = "C Language";
int len = strlen(str1);

strlen() 的处理结果是字符串 str1 的长度，是一个整数，我们通过 len 变量来接收。  
  
函数返回值有固定的数据类型（int、char、float等），用来接收返回值的变量类型要一致。



### 7.1.4 种类

#### 7.1.4.1 库函数

C语言在发布时已经为我们封装好了很多函数，它们被分门别类地放到了不同的头文件中（暂时先这样认为），使用函数时引入对应的头文件即可。这些函数都是专家编写的，执行效率极高，并且考虑到了各种边界情况，各位读者请放心使用。  
  
C语言自带的函数称为库函数（Library Function）。库（Library）是编程中的一个基本概念，可以简单地认为它是一系列函数的集合，在磁盘上往往是一个文件夹。C语言自带的库称为标准库（Standard Library），其他公司或个人开发的库称为第三方库（Third-Party Library）。

> 关于库的概念，我们已在《[不要这样学习C语言，这是一个坑！](https://c.biancheng.net/view/vip_1732.html)》中进行了详细介绍。


#### 7.1.4.2 自定义函数

除了库函数，我们还可以编写自己的函数，拓展程序的功能。自己编写的函数称为自定义函数。自定义函数和库函数在编写和使用方式上完全相同，只是由不同的机构来编写。  



### 与数学中的函数关联

美国人将函数称为“Function”。Function 除了有“函数”的意思，还有“功能”的意思，中国人将 Function 译为“函数”而不是“功能”，是因为C语言中的函数和数学中的函数在使用形式上有些类似，例如：

- C语言中有 length = strlen(str)
- 数学中有 y = f(x)

  
你看它们是何其相似，都是通过一定的操作或规则，由一份数据得到另一份数据。  
  
不过从本质上看，将 Function 理解为“功能”或许更恰当，C语言中的函数往往是独立地实现了某项功能。一个程序由多个函数组成，可以理解为「一个程序由多个小的功能叠加而成」。  
  
本教程重在实践，不咬文嚼字，不死扣概念，大家理解即可，不必在此深究。  

## 7.2 函数定义
函数是一段可以重复使用的代码，用来独立地完成某个功能，它可以接收用户传递的数据，也可以不接收。接收用户数据的函数在定义时要指明参数，不接收用户数据的不需要指明，根据这一点可以将函数分为有参函数和无参函数。  
  
将代码段封装成函数的过程叫做**函数定义**。  

### 7.2.1 无参函数的定义

如果函数不接收用户传递的数据，那么定义时可以不带参数。如下所示：

```c
dataType  functionName(){  
    //body  
}
```
- dataType 是返回值类型，它可以是C语言中的任意数据类型，例如 int、float、char 等。
- functionName 是函数名，它是[标识符](https://c.biancheng.net/view/1770.html)的一种，命名规则和标识符相同。函数名后面的括号`( )`不能少。
- body 是函数体，它是函数需要执行的代码，是函数的主体部分。即使只有一个语句，函数体也要由`{ }`包围。
- 如果有返回值，在函数体中使用 return 语句返回。return 出来的数据的类型要和 dataType 一样。

  
例如，定义一个函数，计算从 1 加到 100 的结果：

```c
1. int sum(){
2.     int i, sum=0;
3.     [for](https://c.biancheng.net/view/1811.html)(i=1; i<=100; i++){
4.         sum+=i;
5.     }
6.     return sum;
7. }
```

累加结果保存在变量`sum`中，最后通过`return`语句返回。sum 是 int 型，返回值也是 int 类型，它们一一对应。  
  
`return`是C语言中的一个关键字，只能用在函数中，用来返回处理结果。  
  
将上面的代码补充完整：
```c
1. #include <stdio.h>

3. int sum(){
4.     int i, sum=0;
5.     for(i=1; i<=100; i++){
6.         sum+=i;
7.     }
8.     return sum;
9. }

11. int main(){
12.     int a = sum();
13.     printf("The sum is %d\n", a);
14.     return 0;
15. }
```

运行结果：  
```bash
The sum is 5050  
```
  
函数不能嵌套定义，main 也是一个函数定义，所以要将 sum 放在 main 外面。函数必须先定义后使用，所以 sum 要放在 main 前面。

> 注意：main 是函数定义，不是函数调用。当可执行文件加载到内存后，系统从 main 函数开始执行，也就是说，系统会调用我们定义的 main 函数。

### 7.2.2 无返回值函数定义

有的函数不需要返回值，或者返回值类型不确定（很少见），那么可以用 void 表示，例如：
```c
1. void hello(){
2.     printf ("Hello,world \n");
3.     //没有返回值就不需要 return 语句
4. }
```

`void`是C语言中的一个关键字，表示“空类型”或“无类型”，绝大部分情况下也就意味着没有 return 语句。

### 7.2.3 有参函数的定义

如果函数需要接收用户传递的数据，那么定义时就要带上参数。如下所示：

```c
dataType  functionName( dataType1 param1, dataType2 param2 ... ){  
    //body  
}
```
`dataType1 param1, dataType2 param2 ...`是参数列表。函数可以只有一个参数，也可以有多个，多个参数之间由`,`分隔。参数本质上也是变量，定义时要指明类型和名称。与无参函数的定义相比，有参函数的定义仅仅是多了一个参数列表。  
  
数据通过参数传递到函数内部进行处理，处理完成以后再通过返回值告知函数外部。  
  
更改上面的例子，计算从 m 加到 n 的结果：
```c
1. int sum(int m, int n){
2.     int i, sum=0;
3.     for(i=m; i<=n; i++){
4.         sum+=i;
5.     }
6.     return sum;
7. }
```

参数列表中给出的参数可以在函数体中使用，使用方式和普通变量一样。  
  
调用 sum() 函数时，需要给它传递两份数据，一份传递给 m，一份传递给 n。你可以直接传递整数，例如：

```c
int result = sum(1, 100);  //1传递给m，100传递给n
```

也可以传递变量：

```c
int begin = 4;  
int end = 86;  
int result = sum(begin, end);  //begin传递给m，end传递给n
```

也可以整数和变量一起传递：

```c
int num = 33;  
int result = sum(num, 80);  //num传递给m，80传递给n
```

函数定义时给出的参数称为形式参数，简称形参；函数调用时给出的参数（也就是传递的数据）称为实际参数，简称实参。函数调用时，将实参的值传递给形参，相当于一次赋值操作。  
  
原则上讲，实参的类型和数目要与形参保持一致。如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型，例如将 int 类型的实参传递给 float 类型的形参就会发生自动类型转换。  
  
将上面的代码补充完整：

```c
1. #include <stdio.h>

3. int sum(int m, int n){
4.     int i, sum=0;
5.     for(i=m; i<=n; i++){
6.         sum+=i;
7.     }
8.     return sum;
9. }

11. int main(){
12.     int begin = 5, end = 86;
13.     int result = sum(begin, end);
14.     printf("The sum from %d to %d is %d\n", begin, end, result);
15.     return 0;
16. }
```
运行结果：  
The sum from 5 to 86 is 3731  
  
定义 sum() 时，参数 m、n 的值都是未知的；调用 sum() 时，将 begin、end 的值分别传递给 m、n，这和给变量赋值的过程是一样的，它等价于：

```
m = begin;
n = end;
```
### 7.2.4 嵌套定义非法

强调一点，C语言不允许函数嵌套定义；也就是说，不能在一个函数中定义另外一个函数，必须在所有函数之外定义另外一个函数。main() 也是一个函数定义，也不能在 main() 函数内部定义新函数。  
  
下面的例子是错误的：

```c
1. #include <stdio.h>

3. void func1(){
4.     printf("http://c.biancheng.net");

6.     void func2(){
7.         printf("C语言小白变怪兽");
8.     }
9. }

11. int main(){
12.     func1();
13.     return 0;
14. }
```
有些初学者认为，在 func1() 内部定义 func2()，那么调用 func1() 时也就调用了 func2()，这是错误的。  
  
正确的写法应该是这样的：

```c
1. #include <stdio.h>

3. void func2(){
4.     printf("C语言小白变怪兽");
5. }

7. void func1(){
8.     printf("http://c.biancheng.net");
9.     func2();
10. }

12. int main(){
13.     func1();
14.     return 0;
15. }
```
func1()、func2()、main() 三个函数是平行的，谁也不能位于谁的内部，要想达到「调用 func1() 时也调用 func2()」的目的，必须将 func2() 定义在 func1() 外面，并在 func1() 内部调用 func2()。

> 有些编程语言是允许函数嵌套定义的，例如 [JavaScript](https://c.biancheng.net/js/)，在 [Java](https://c.biancheng.net/java/)Script 中经常会使用函数的嵌套定义。






## 7.3 形参和实参

如果把函数比喻成一台机器，那么参数就是原材料，返回值就是最终产品；从一定程度上讲，函数的作用就是根据不同的参数产生不同的返回值。  
  
这一节我们先来讲解C语言函数的参数，下一节再讲解C语言函数的返回值。  
  
C语言函数的参数会出现在两个地方，分别是函数定义处和函数调用处，这两个地方的参数是有区别的。  

### 7.3.1 形参

在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为**形式参数**，简称**形参**。

### 7.3.2 实参

函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为**实际参数**，简称**实参**。  
  
形参和实参的功能是传递数据，发生函数调用时，实参的值会传递给形参。

### 7.3.3 区分

1) 形参变量只有在函数被调用时才会分配内存，调用结束后，立刻释放内存，所以形参变量只有在函数内部有效，不能在函数外部使用。  
  
2) 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参，所以应该提前用赋值、输入等办法使实参获得确定值。  
  
3) 实参和形参在数量上、类型上、顺序上必须严格一致，否则会发生“类型不匹配”的错误。当然，如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型。  
  
4) 函数调用中发生的数据传递是单向的，只能把实参的值传递给形参，而不能把形参的值反向地传递给实参；换句话说，**一旦完成数据的传递，实参和形参就再也没有瓜葛了，所以，在函数调用过程中，形参的值发生改变并不会影响实参**(除非传递的是实参数的内存地址，改变了实参变量的地址指向)。  
  
请看下面的例子：

```c
1. #include <stdio.h>

3. //计算从m加到n的值
4. int sum(int m, int n) {
5.     int i;
6.     for(i = m+1; i <= n; ++i)
7.     {
8.         m += i;
9.     }
10.     return m;
11. }

12. int main() {
13.     int a, b, total;
14.     printf("Input two numbers: ");
15.     scanf("%d %d", &a, &b);
16.     total = sum(a, b);
17.     printf("a=%d, b=%d\n", a, b);
18.     printf("total=%d\n", total);

19.     return 0;
20. }
```
运行结果：  
```bash
Input two numbers: 1 100↙  
a=1, b=100  
total=5050  
```
  
在这段代码中，函数定义处的 m、n 是形参，函数调用处的 a、b 是实参。通过 scanf() 可以读取用户输入的数据，并赋值给 a、b，在调用 sum() 函数时，这份数据会传递给形参 m、n。  
  
从运行情况看，输入 a 值为 1，即实参 a 的值为 1，把这个值传递给函数 sum() 后，形参 m 的初始值也为 1，在函数执行过程中，形参 m 的值变为 5050。函数运行结束后，输出实参 a 的值仍为 1，可见实参的值不会随形参的变化而变化。  
  
以上调用 sum() 时是将变量作为函数实参，除此以外，你也可以将常量、表达式、函数返回值作为实参，如下所示：

```c
1. total = sum(10, 98);  //将常量作为实参
2. total = sum(a+10, b-3);  //将表达式作为实参
3. total = sum( pow(2,2), abs(-100) );  //将函数返回值作为实参
```
  
5) 形参和实参虽然可以同名，但它们之间是相互独立的，互不影响，因为实参在函数外部有效，而形参在函数内部有效。  
  
更改上面的代码，让实参和形参同名：

```c
1. #include <stdio.h>

3. //计算从m加到n的值
4. int sum(int m, int n) {
5.     int i;
6.     for (i = m + 1; i <= n; ++i) {
7.         m += i;
8.     }
9.     return m;
10. }

12. int main() {
13.     int m, n, total;
14.     printf("Input two numbers: ");
15.     scanf("%d %d", &m, &n);
16.     total = sum(m, n);
17.     printf("m=%d, n=%d\n", m, n);
18.     printf("total=%d\n", total);

20.     return 0;
21. }
```
运行结果：  
```bash
Input two numbers: 1 100  
m=1, n=100  
total=5050  
  
```
调用 sum() 函数后，函数内部的形参 m 的值已经发生了变化，而函数外部的实参 m 的值依然保持不变，可见它们是相互独立的两个变量，除了传递参数的一瞬间，其它时候是没有瓜葛的。




# 8. 结构体



# 9. 指针

## 9.1 简介
计算机中所有的数据都必须放在内存中，不同类型的数据占用的字节数不一样，例如 int 占用 4 个字节，char 占用 1 个字节。为了正确地访问这些数据，必须为每个字节都编上号码，就像门牌号、身份证号一样，每个字节的编号是唯一的，根据编号可以准确地找到某个字节。  


下图是 4G 内存中每个字节的编号（以十六进制表示）：  
![4G 内存中每个字节的编号](https://c.biancheng.net/uploads/allimg/190114/1I3043925-0.png)  
  
我们将内存中字节的编号称为**地址（Address）或[指针](https://c.biancheng.net/c/80/)（Pointer）**。地址从 0 开始依次增加，对于 32 位环境，程序能够使用的内存为 4GB，最小的地址为 0，最大的地址为 0XFFFFFFFF。  
  
下面的代码演示了如何输出一个地址：
```c
1. #include <stdio.h>

3. int main(){
4.     int a = 100;
5.     char str[20] = "c.biancheng.net";
6.     printf("%#X, %#X\n", &a, str);
7.     return 0;
8. }
```
运行结果：  
```bash
0X28FF3C, 0X28FF10  
```
  
`%#X`表示以十六进制形式输出，并附带前缀`0X`。a 是一个变量，用来存放整数，需要在前面加`&`来获得它的地址；str 本身就表示字符串的首地址，不需要加`&`。

> C语言中有一个控制符`%p`，专门用来以十六进制形式输出地址，不过 %p 的输出格式并不统一，有的编译器带`0x`前缀，有的不带，所以此处我们并没有采用。




---

> 为什么会产生这种现象？从计算机的角度来讲，一切编程操作都是地址操作


C语言用变量来存储数据，用函数来定义一段可以重复使用的代码，它们最终都要放到内存中才能供 CPU 使用。  
  
数据和代码都以二进制的形式存储在内存中，**计算机无法从格式上区分某块内存到底存储的是数据还是代码**。当程序被加载到内存后，操作系统会给不同的内存块指定不同的权限，**拥有读取和执行权限的内存块就是代码**，而拥有**读取**和**写入权限**（也可能只有读取权限）的内存块就是数据。  
  
CPU 只能通过地址来取得内存中的代码和数据，程序在执行过程中会告知 CPU 要执行的代码以及要读写的数据的地址。如果程序不小心出错，或者开发者有意为之，在 CPU 要写入数据时给它一个代码区域的地址，就会发生内存访问错误。这种内存访问错误会被硬件和操作系统拦截，强制程序崩溃，程序员没有挽救的机会。  
  
CPU 访问内存时需要的是地址，而不是变量名和函数名！**变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址**。**编译和链接过程的一项重要任务就是找到这些名称所对应的地址**。  
  
假设变量 a、b、c 在内存中的地址分别是 0X1000、0X2000、0X3000，那么加法运算`c = a + b;`将会被编译步骤转换成类似下面的形式（汇编分析的角度）：

0X3000 = (0X1000) + (0X2000);

`( )`表示取值操作，整个表达式的意思是，取出地址 0X1000 和 0X2000 上的值，将它们相加，把相加的结果赋值给地址为 0X3000 的内存  
  
变量名和函数名为我们提供了方便，让我们在编写代码的过程中可以使用易于阅读和理解的英文字符串，不用直接面对二进制地址，那场景简直让人崩溃。  
  
需要注意的是，虽然变量名、函数名、字符串名和数组名在本质上是一样的，它们都是**地址的助记符**，但在编写代码的过程中，我们认为变量名表示的是数据本身，而**函数名、字符串名和数组名表示的是代码块或数据块的首地址**。
## 9.2 概念


## 9.3 特性



## 9.4 操作

数据在内存中的地址也称为[指针](https://c.biancheng.net/c/80/)，如果一个变量存储了一份数据的指针，我们就称它为**指针变量**。  
  
在C语言中，允许用一个变量来存放指针，这种变量称为指针变量。指针变量的值就是某份数据的地址，这样的一份数据可以是数组、字符串、函数，也可以是另外的一个普通变量或指针变量。  
  
现在假设有一个 char 类型的变量 c，它存储了字符 'K'（[ASCII](https://c.biancheng.net/c/ascii/)码为十进制数 75），并占用了地址为 0X11A 的内存（地址通常用十六进制表示）。另外有一个指针变量 p，它的值为 0X11A，正好等于变量 c 的地址，这种情况我们就称 p 指向了 c，或者说 p 是指向变量 c 的指针。

![](https://c.biancheng.net/uploads/allimg/190114/1IG34354-0.png)

### 9.2.1 定义

定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号`*`，格式为：

```c
datatype *name;
```

或者

```c
datatype *name = value;
```

`*`表示这是一个指针变量，`datatype`表示该指针变量所指向的数据的类型 。例如：

1. int *p1;

p1 是一个指向 int 类型数据的指针变量，至于 p1 究竟指向哪一份数据，应该由赋予它的值决定。再如：

```c
1. int a = 100;
2. int *p_a = &a;
```

在定义指针变量 p_a 的同时对它进行初始化，并将变量 a 的地址赋予它，此时 p_a 就指向了 a。值得注意的是，p_a 需要的一个地址，a 前面必须要加取地址符`&`，否则是不对的。  
  
和普通变量一样，指针变量也可以被多次写入，只要你想，随时都能够改变指针变量的值，请看下面的代码：

```c
1. //定义普通变量
2. float a = 99.5, b = 10.6;
3. char c = '@', d = '#';
4. //定义指针变量
5. float *p1 = &a;
6. char *p2 = &c;
7. //修改指针变量的值
8. p1 = &b;
9. p2 = &d;
```
`*`是一个特殊符号，表明一个变量是指针变量，定义 p1、p2 时必须带`*`。而给 p1、p2 赋值时，因为已经知道了它是一个指针变量，就没必要多此一举再带上`*`，后边可以像使用普通变量一样来使用指针变量。也就是说，定义指针变量时必须带`*`，给指针变量赋值时不能带`*`。  
  
假设变量 a、b、c、d 的地址分别为 0X1000、0X1004、0X2000、0X2004，下面的示意图很好地反映了 p1、p2 指向的变化：

![](https://c.biancheng.net/uploads/allimg/190114/1IG3J50-1.jpg)

需要强调的是，p1、p2 的类型分别是`float*`和`char*`，而不是`float`和`char`，它们是完全不同的数据类型，读者要引起注意。  
  
指针变量也可以连续定义，例如：

```c
1. int *a, *b, *c;  //a、b、c 的类型都是 int*
```

注意每个变量前面都要带`*`。如果写成下面的形式，那么只有 a 是指针变量，b、c 都是类型为 int 的普通变量：
```c
1. int *a, b, c;
```

### 9.2.3 访问

指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为：

```c
*pointer;
```

这里的`*`称为指针运算符，用来取得某个地址上的数据，请看下面的例子：

```c
1. #include <stdio.h>

3. int main(){
4.     int a = 15;
5.     int *p = &a;
6.     [printf](https://c.biancheng.net/view/ublxqif.html)("%d, %d\n", a, *p);  //两种方式都可以输出a的值
7.     return 0;
8. }
```
运行结果：  
```bash
15, 15  
```
  
假设 a 的地址是 0X1000，p 指向 a 后，p 本身的值也会变为 0X1000，*p 表示获取地址 0X1000 上的数据，也即变量 a 的值。从运行结果看，*p 和 a 是等价的。  
  
上节我们说过，CPU 读写数据必须要知道数据在内存中的地址，普通变量和指针变量都是地址的助记符，虽然通过 *p 和 a 获取到的数据一样，但它们的运行过程稍有不同：a 只需要一次运算就能够取得数据，而 *p 要经过两次运算，多了一层“间接”。  
  
假设变量 a、p 的地址分别为 0X1000、0XF0A0，它们的指向关系如下图所示：

![](https://c.biancheng.net/uploads/allimg/190114/1IG3MJ-2.jpg)

程序被编译和链接后，a、p 被替换成相应的地址。使用 *p 的话，要先通过地址 0XF0A0 取得变量 p 本身的值，这个值是变量 a 的地址，然后再通过这个值取得变量 a 的数据，前后共有两次运算；而使用 a 的话，可以通过地址 0X1000 直接取得它的数据，只需要一步运算。  
  
也就是说，使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高。  
  
指针除了可以获取内存上的数据，也可以修改内存上的数据，例如：

```c
1. #include <stdio.h>

3. int main(){
4.     int a = 15, b = 99, c = 222;
5.     int *p = &a;  //定义指针变量
6.     *p = b;  //通过指针变量修改内存上的数据
7.     c = *p;  //通过指针变量获取内存上的数据
8.     printf("%d, %d, %d, %d\n", a, b, c, *p);
9.     return 0;
10. }
```

运行结果：  
```c
99, 99, 99, 99  
```
  
*p 代表的是 a 中的数据，它等价于 a，可以将另外的一份数据赋值给它，也可以将它赋值给另外的一个变量。  
  
`*`在不同的场景下有不同的作用：`*`可以用在指针变量的定义中，表明这是一个指针变量，以和普通变量区分开；使用指针变量时在前面加`*`表示获取指针指向的数据，或者说表示的是指针指向的数据本身。  
  
也就是说，定义指针变量时的`*`和使用指针变量时的`*`意义完全不同。以下面的语句为例：
```c
1. int *p = &a;
2. *p = 100;
```

第1行代码中`*`用来指明 p 是一个指针变量，第2行代码中`*`用来获取指针指向的数据。  
  
需要注意的是，给指针变量本身赋值时不能加`*`。修改上面的语句：

```c
1. int *p;
2. p = &a;
3. *p = 100;
```

第2行代码中的 p 前面就不能加`*`。  
  
指针变量也可以出现在普通变量能出现的任何表达式中，例如：

```c
1. int x, y, *px = &x, *py = &y;
2. y = *px + 5;  //表示把x的内容加5并赋给y，*px+5相当于(*px)+5
3. y = ++*px;  //px的内容加上1之后赋给y，++*px相当于++(*px)
4. y = *px++;  //相当于y=*(px++)
5. py = px;  //把一个指针的值赋给另一个指针
```

  
【示例】通过指针交换两个变量的值。

```c
1. #include <stdio.h>

3. int main(){
4.     int a = 100, b = 999, temp;
5.     int *pa = &a, *pb = &b;
6.     printf("a=%d, b=%d\n", a, b);
7.     /*****开始交换*****/
8.     temp = *pa;  //将a的值先保存起来
9.     *pa = *pb;  //将b的值交给a
10.     *pb = temp;  //再将保存起来的a的值交给b
11.     /*****结束交换*****/
12.     printf("a=%d, b=%d\n", a, b);
13.     return 0;
14. }
```

运行结果：  
```bash
a=100, b=999  
a=999, b=100  
  
```
从运行结果可以看出，a、b 的值已经发生了交换。需要注意的是临时变量 temp，它的作用特别重要，因为执行`*pa = *pb;`语句后 a 的值会被 b 的值覆盖，如果不先将 a 的值保存起来以后就找不到了。  

## 9.4 总结

### 9.4.1 关于 * 和 & 

假设有一个 int 类型的变量 a，pa 是指向它的指针，那么`*&a`和`&*pa`分别是什么意思呢？  
  
`*&a`可以理解为`*(&a)`，`&a`表示取变量 a 的地址（等价于 pa），`*(&a)`表示取这个地址上的数据（等价于 *pa），绕来绕去，又回到了原点，`*&a`仍然等价于 a。  
  
`&*pa`可以理解为`&(*pa)`，`*pa`表示取得 pa 指向的数据（等价于 a），`&(*pa)`表示数据的地址（等价于 &a），所以`&*pa`等价于 pa。

### 9.4.2 对星号`*`的总结

在我们目前所学到的语法中，星号`*`主要有三种用途：

- 表示乘法，例如`int a = 3, b = 5, c;  c = a * b;`，这是最容易理解的。
- 表示定义一个指针变量，以和普通变量区分开，例如`int a = 100;  int *p = &a;`。
- 表示获取指针指向的数据，是一种间接操作，例如`int a, b, *p = &a;  *p = 100;  b = *p;`。





# 10. IO

## 10.1 文件操作



## 10.2 媒体流




## 10.3 网络流



# 11. 预处理





# 12. 调试



# 13. 补充

