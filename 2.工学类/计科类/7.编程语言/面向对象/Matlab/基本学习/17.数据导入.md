# MATLAB 数据导入（ImportData）

在MATLAB中导入数据意味着从外部文件加载数据。该**importdata**功能允许加载不同格式的各种数据文件。它具有以下五种形式-

|序号|功能说明|
|---|---|
|1|**A = importdata(filename)**<br><br>从_filename_表示的_文件_中将数据加载到数组A中。|
|2|**A = importdata('-pastespecial')**<br><br>从系统剪贴板而不是文件加载数据。|
|3|**A = importdata(___, delimiterIn)**<br><br>将 delimiterIn 解释为 ASCII 文件、文件名或剪贴板数据中的列分隔符。可以对上述语法中的任何输入参数使用 delimiterIn。|
|4|**A = importdata(___, delimiterIn, headerlinesIn)**<br><br>从ASCII文件，文件名或剪贴板中加载数据，并从行_headerlinesIn + 1_开始读取数字数据。|
|5|**[A, delimiterOut, headerlinesOut] = importdata(___)**<br><br>使用前面语法中的任何输入参数，返回delimiterOut中输入ASCII文件的检测到的分隔符字符和headerlinesOut中检测到的头行数。|

> 默认情况下，Octave不支持该_importdata()_功能，因此您必须搜索并安装此软件包才能使以下示例适用于Octave安装。

## 实例1

让我们加载并显示图像文件。创建一个脚本文件并在其中键入以下代码-

filename = 'smile.jpg';
A = importdata(filename);
image(A);

运行文件时，MATLAB将显示图像文件。但是，必须将其存储在当前目录中。

![导入Imange文件](https://www.cainiaojc.com/static/upload/210417/1106480.jpg)

## 实例2

在此示例中，我们导入一个文本文件并指定Delimiter和Column Header。让我们创建一个以空格分隔的ASCII文件，其中包含标题为_weeklydata.txt的_列标题。

我们的文本文件weeklydata.txt看起来像这样-

SunDay  MonDay  TuesDay  WednesDay  ThursDay  FriDay  SaturDay
95.01   76.21   61.54    40.57       55.79    70.28   81.53
73.11   45.65   79.19    93.55       75.29    69.87   74.68
60.68   41.85   92.18    91.69       81.32    90.38   74.51
48.60   82.14   73.82    41.03       0.99     67.22   93.18
89.13   44.47   57.63    89.36       13.89    19.88   46.60

创建一个脚本文件并在其中键入以下代码-

filename = 'weeklydata.txt';
delimiterIn = ' ';
headerlinesIn = 1;
A = importdata(filename,delimiterIn,headerlinesIn);

% View data
for k = [1:7]
   disp(A.colheaders{1, k})
   disp(A.data(:, k))
   disp(' ')
end

运行文件时，它显示以下结果-

SunDay
   95.0100
   73.1100
   60.6800
   48.6000
   89.1300
 
MonDay
   76.2100
   45.6500
   41.8500
   82.1400
   44.4700
 
TuesDay
   61.5400
   79.1900
   92.1800
   73.8200
   57.6300

WednesDay
   40.5700
   93.5500
   91.6900
   41.0300
   89.3600
 
ThursDay
   55.7900
   75.2900
   81.3200
   0.9900
   13.8900
 
FriDay
   70.2800
   69.8700
   90.3800
   67.2200
   19.8800

SaturDay
   81.5300
   74.6800
   74.5100
   93.1800
   46.6000

## 实例3

在此示例中，让我们从剪贴板导入数据。

将以下行复制到剪贴板-

**Mathematics is simple**

创建一个脚本文件并输入以下代码-

A = importdata('-pastespecial')

运行文件时，它显示以下结果-

A = 
   'Mathematics is simple'

## 底层文件I / O

importdata函数是一个高级函数。MATLAB中的底层文件I/O函数允许对文件的读写数据进行最大程度的控制。但是，这些函数需要更详细的文件信息才能有效地工作。

MATLAB为字节或字符级别的读写操作提供以下函数-

|函数|描述|
|---|---|
|fclose|关闭一个或所有打开的文件|
|feof|文件结尾测试|
|ferror|有关文件I/O错误的信息|
|fgetl|从文件中读取行，删除换行符|
|fgets|从文件中读取行，保留换行符|
|fopen|打开文件，或获取有关打开文件的信息|
|fprintf|将数据写入文本文件|
|fread|从二进制文件读取数据|
|frewind|将文件位置指示器移动到打开文件的开头|
|fscanf|从文本文件读取数据|
|fseek|移动到文件中的指定位置|
|ftell|在打开文件中的位置|
|fwrite|将数据写入二进制文件|

## 导入具有底层I / O的文本数据文件

MATLAB提供以下功能用于文本数据文件的底层导入-

- **fscanf**函数读取文本或ASCII文件中的格式化数据。
    
- **fgetl**和**fgets**的时间，其中，一个换行字符的每一行分离功能读取的文件的一行。
    
- **fread**函数读取字节或位级别的数据流。
    

## 在线示例

我们在工作目录中保存了一个文本数据文件“ myfile.txt”。该文件存储了三个月的降雨数据；2012年的六月，七月和八月。

myfile.txt数据文件包含五个地点的时间、月份和降雨量的重复测量集。头数据存储月数M；因此我们有M组度量。

该文件看起来像这样-

Rainfall Data
Months: June, July, August
 
M = 3
12:00:00
June-2012
17.21  28.52  39.78  16.55 23.67
19.15  0.35   17.57  NaN   12.01
17.92  28.49  17.40  17.06 11.09
9.59   9.33   NaN    0.31  0.23 
10.46  13.17  NaN    14.89 19.33
20.97  19.50  17.65  14.45 14.00
18.23  10.34  17.95  16.46 19.34
09:10:02
July-2012
12.76  16.94  14.38  11.86 16.89
20.46  23.17  NaN    24.89 19.33
30.97  49.50  47.65  24.45 34.00
18.23  30.34  27.95  16.46 19.34
30.46  33.17  NaN    34.89  29.33
30.97  49.50  47.65  24.45 34.00
28.67  30.34  27.95  36.46 29.34
15:03:40
August-2012
17.09  16.55  19.59  17.25 19.22
17.54  11.45  13.48  22.55 24.01
NaN    21.19  25.85  25.05 27.21
26.79  24.98  12.23  16.99 18.67
17.54  11.45  13.48  22.55 24.01
NaN    21.19  25.85  25.05 27.21
26.79  24.98  12.23  16.99 18.67

我们将从该文件导入数据并显示此数据。采取以下步骤-

- 使用**fopen**函数打开文件并获取文件标识符。
    
- 用来描述文件中的数据**格式说明符**，例如' **%s**'表示字符串，' **%d**'表示整数，或' **%f**'表示浮点数。
    
- 要跳过文件中的文字字符，请在格式说明中包括它们。要跳过数据字段，请在说明符中使用星号（'*'）。
    
    例如，要读取标头并返回M的单个值，我们这样写-
    
    M = fscanf(fid, '%*s %*s\n%*s %*s %*s %*s\nM=%d\n\n', 1);
    
- 默认情况下，**fscanf**根据我们的格式说明读取数据，直到找不到与数据匹配的内容，或者到达文件末尾为止。在这里，我们将使用for循环读取3组数据，并且每次将读取7行和5列。
    
- 我们将在工作区中创建一个名为_mydata_的结构，以存储从文件中读取的数据。这种结构有三个字段-_time_, _month_, and _raindata_数组。
    

创建一个脚本文件并在其中键入以下代码-

filename = '/data/myfile.txt';
rows = 7;
cols = 5;
 
%打开文件
fid = fopen(filename);
 
%读取文件头，找到M（月数）
M = fscanf(fid, '%*s %*s\n%*s %*s %*s %*s\nM=%d\n\n', 1);
 
%读取每一组测量数据
for n = 1:M
   mydata(n).time = fscanf(fid, '%s', 1);
   mydata(n).month = fscanf(fid, '%s', 1);
 
   %fscanf按列顺序填充数组，
   %把结果转置
   mydata(n).raindata  = ...
      fscanf(fid, '%f', [rows, cols]);
end
for n = 1:M
   disp(mydata(n).time), disp(mydata(n).month)
   disp(mydata(n).raindata)
end
 
%关闭文件
fclose(fid);

运行文件时，它显示以下结果-

12:00:00
June-2012
   17.2100   17.5700   11.0900   13.1700   14.4500
   28.5200       NaN    9.5900       NaN   14.0000
   39.7800   12.0100    9.3300   14.8900   18.2300
   16.5500   17.9200       NaN   19.3300   10.3400
   23.6700   28.4900    0.3100   20.9700   17.9500
   19.1500   17.4000    0.2300   19.5000   16.4600
   0.3500   17.0600   10.4600   17.6500   19.3400

09:10:02
July-2012
   12.7600       NaN   34.0000   33.1700   24.4500
   16.9400   24.8900   18.2300       NaN   34.0000
   14.3800   19.3300   30.3400   34.8900   28.6700
   11.8600   30.9700   27.9500   29.3300   30.3400
   16.8900   49.5000   16.4600   30.9700   27.9500
   20.4600   47.6500   19.3400   49.5000   36.4600
   23.1700   24.4500   30.4600   47.6500   29.3400

15:03:40
August-2012
   17.0900   13.4800   27.2100   11.4500   25.0500
   16.5500   22.5500   26.7900   13.4800   27.2100
   19.5900   24.0100   24.9800   22.5500   26.7900
   17.2500       NaN   12.2300   24.0100   24.9800
   19.2200   21.1900   16.9900       NaN   12.2300
   17.5400   25.8500   18.6700   21.1900   16.9900
   11.4500   25.0500   17.5400   25.8500   18.6700


# XLSX操作

## 创建XLSX

## 导入XLSX

## 索引XLSX

### 筛选列

对返回列值进行唯一化处理

### 筛选行


## 修改XLSX

## 保存XLSX
