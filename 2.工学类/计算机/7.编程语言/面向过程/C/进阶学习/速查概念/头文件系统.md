> 本文假定读者已具备基本的C编译知识。如非特殊说明，文中“源文件”指 * .c文件，“头文件”指 *.h文件，“引用”指包含头文件。

### 一、头文件作用

C语言里，每个源文件是一个模块，头文件为使用该模块的用户提供接口。接口指一个功能模块暴露给其他模块用以访问具体功能的方法。

使用源文件实现模块的功能，使用头文件暴露单元的接口。用户只需包含相应的头文件就可使用该头文件中暴露的接口。

**通过头文件包含的方法将程序中的各功能模块联系起来有利于模块化程序设计：**

**1）通过头文件调用库功能。在很多场合，源代码不便(或不准)向用户公布，只要向用户提供头文件和二进制库即可。用户只需按照头文件中的接口声明来调用库功能，而不必关心接口如何实现。编译器会从库中提取相应的代码。

**2）头文件能加强类型安全检查。若某个接口的实现或使用方式与头文件中的声明不一致，编译器就会指出错误。这一简单的规则能大大减轻程序员调试、改错的负担。

> 在预处理阶段，编译器将源文件包含的头文件内容复制到包含语句(#include)处。在源文件编译时，连同被包含进来的头文件内容一起编译，生成目标文件(.obj)。

如果所包含的头文件非常庞大，则会严重降低编译速度(使用GCC的-E选项可获得并查看最终预处理完的文件)。因此，在源文件中应仅包含必需的头文件，且尽量不要在头文件中包含其它头文件。

  >**注意**：#字符不是C语言的关键字，准确来讲其是给编译器看的

### 二、 头文件组织原则

源文件中实现变量、函数的定义，并指定链接范围。头文件中书写外部需要使用的全局变量、函数声明及数据类型和宏的定义。

**建议组织头文件内容时遵循以下原则：**

**1）**头文件划分原则：类型定义、宏定义尽量与函数声明相分离，分别位于不同的头文件中。内部函数声明头文件与外部函数声明头文件相分离，内部类型定义头文件与外部类型定义头文件相分离。

> 注意，类型和宏定义有时无法分拆为不同文件，比如结构体内数组成员的元素个数用常量宏表示时。因此仅分离类型宏定义与函数声明，且分别置于*.th和*.fh文件(并非强制要求)。

**2）**头文件的语义层次化原则：头文件需要有语义层次。不同语义层次的类型定义不要放在一个头文件中，不同层次的函数声明不要放在一个头文件中。

**3）**头文件的语义相关性原则：同一头文件中出现的类型定义、函数声明应该是语义相关的、有内部逻辑关系的，避免将无关的定义和声明放在一个头文件中。

**4）**头文件名应尽量与实现功能的源文件相同，即module.c和module.h。但源文件不一定要包含其同名的头文件。

**5）**头文件中不应包含本地数据，以降低模块间耦合度。

> 即只有源文件自己使用的类型、宏定义和变量、函数声明，不应出现在头文件里。作用域限于单文件的私有变量和函数应声明为static，以防止外部调用。将私有类型置于源文件中，会提高聚合度，并减少不必要的格式外漏。

**6）**头文件内不允许定义变量和函数，只能有宏、类型(typedef/struct/union/enum等)及变量和函数的声明。

> 特殊情况下可extern基本类型的全局变量，源文件通过包含该头文件访问全局变量。但头文件内不应extern自定义类型(如结构体)的全局变量，否则将迫使本不需要访问该变量的源文件包含自定义类型所在头文件[1]。

**7）**说明性头文件不需要有对应的源文件。此类头文件内大多包含大量概念性宏定义或枚举类型定义，不包含任何其他类型定义和变量或函数声明。此类头文件也不应包含任何其他头文件。

**8）**使用#pragma once或header guard(亦称include guard或macro guard)避免头文件重复包含。#pragma once是一种非标准但已被现代编译器广泛支持的技巧，它明确告知预处理器“不要重复包含当前头文件”。而header guard则通过预处理命令模拟类似行为：

  

![](https://pic2.zhimg.com/v2-818f30ce44f290ef2d9c7b86bc20d3db_1440w.jpg)

  

**使用#pragma once相比header guard具有两个优点：**

**① 更快。**编译器不会第二次读取标记#pragma once的文件，但却会读若干遍使用header guard 的文件(寻找#endif)；

**② 更简单。**不再需要为每个文件的header guard取名，避免宏名重名引发的“找不到声明”问题。

**缺点则是：**

> `#pragma once`保证物理上的同一个文件不会被包含多次，无法对头文件中的一段代码作# pragma once声明。若某个头文件具有多份拷贝(内容相同的多个文件)，pragma不能保证它们不被重复包含。当然，这种重复包含很容易被发现并修正。

**9）** C++中要引用C函数时，函数所在头文件内应包含extern "C"。

  

![](https://picx.zhimg.com/v2-4d1f112caa2a243f1722f6bba54af655_1440w.jpg)

  

被extern "C"修饰的变量和函数将按照C语言方式编译和连接，否则编译器将无法找到C函数定义，从而导致链接失败。

**10）**头文件内要有面向用户的充足注释，从应用角度描述接口暴露的内容。

  

### 三、 头文件包含原则

在实际编程中，常常因头文件包含不当而引发编译时报告符号未定义的错误或重复定义的警告。

要消除符号未定义的编译错误，只需在引用符号(变量、函数、数据类型及宏等)前确保它已被声明或定义[4]。要消除重复定义的警告，则需合理设计头文件包含顺序和层次。

**建议包含头文件时遵循以下原则：**

**1）源文件内的头文件包含顺序应从最特殊到一般，**

**如：**

  

![](https://picx.zhimg.com/v2-ac8e85c0d8d1dc0f671c9c42d3fe2e59_1440w.jpg)

  

优点是每个头文件必须include需要的关联头文件，否则会报错。

同时，源文件同名头文件置于包含列表前端便于检查该头文件是否自完备，以及类型或函数声明是否与标准库冲突。

**2）减少头文件的嵌套和交叉引用，头文件仅包含其真正需要显式包含的头文件。**

> 例如，头文件A中出现的类型定义在头文件B中，则头文件A应包含头文件B，除此以外的其他头文件不允许包含。

头文件的嵌套和交叉引用会使程序组织结构和文件组织变得混乱，同时造成潜在的错误。大型工程中，原有头文件可能会被多个其他(源或头)文件包含，在原有头文件中添加新的头文件往往牵一发而动全身。若头文件中类型定义需要其他头文件时，可将其提出来单独形成一个全局头文件。

**3）头文件应包含哪些头文件仅取决于自身，而非包含该头文件的源文件。**

> 例如，编译源文件时需要用到头文件B，且源文件已包含头文件A，而索性将头文件B包含在头文件A中，这是错误的做法。

**4）尽量保证用户使用此头文件时，无需手动包含其他前提头文件，即此头文件内已包含前提头文件。**

> 例如，面积相关操作的头文件Area.h内已包含关于点操作的头文件Point.h，则用户包含Area.h后无需再手动包含Point.h。这样用户就不必了解头文件的内在依赖关系。

**5）**头文件应是自完备的，即在任一源文件中包含任一头文件而不会产生编译错误。

**6）**源文件中包含的头文件尽量不要有顺序依赖。

**7）**尽量在源文件中包含头文件，而非在头文件中。且源文件仅包含所需的头文件。

**8）**头文件中若能前置声明(亦称前向声明[5])，就不要包含另一头文件。仅当前置声明不能满足或过于麻烦时才使用include，如此可减少依赖性方面的问题。

**示例如下：**

  

![](https://pic4.zhimg.com/v2-8259506626bb53396053caf9e45dfed5_1440w.jpg)

  

如上，在OmciChkFunc函数的实现源文件内包含T_MeInfoMap和T_OmciMsg所在头文件即可。

**另举一例如下：**

  

![](https://pic4.zhimg.com/v2-34a9d2c04f7ab297c12c1750ca32a1b3_1440w.jpg)

  

如上，CompareRecFunc函数原型由其他头文件提供，此处为避免头文件交叉引用定义其异名同构原型CmpRecFunc。

> 在不会引起歧义的前提下，头文件内尽可能使用VOID指针代替非基本类型的值变量或指针，以避免再包含类型定义所在的头文件。但这将影响代码可读性并降低程序执行效率，应权衡利弊。

**9）**避免包含重量级的平台头文件，如windows.h或d3d9.h等。若仅使用该头文件少量函数，可extern函数到源文件内。如下：

  

![](https://pic1.zhimg.com/v2-97f757a92ed130a85658bde2a4215f60_1440w.jpg)

  

若还使用该头文件某些类型和宏定义，可创建适配性源文件。在该源文件内包含平台头文件，封装新的接口并将其声明在同名头文件内，其他源文件将通过适配头文件间接访问平台接口。如下：

  

![](https://pic1.zhimg.com/v2-0664ceb1a54e72d40dd87890324da430_1440w.jpg)

  

**10）**对于函数库(包括标准库和自定义的公共宏及接口)的头文件，可将其加入到一个通用头文件中。需要控制该头文件的体积(主要是该头文件所包含的所有头文件内容大小)，并确保所有源文件首先包含该通用头文件。示例如下：

  

![](https://picx.zhimg.com/v2-1899b46bf7adc542903af8facb7723e9_1440w.jpg)

  

> 注意，示例头文件内包含C库文件虽能简化包含，但却与规则1冲突。也可另外增加包含库文件列表的通用头文件。

**11）**若不确定类型、宏定义或函数声明所在头文件具体路径，可在源文件中再次定义或声明，编译器会以redefined警告或conflicting错误给出类型、宏定义或函数声明所在头文件路径。

  

### 四、代码文件组织原则

**建议C语言项目中代码文件组织遵循以下原则：**

**1）**使用层次化和模块化的软件开发模型。每个模块只能使用所在层和下一层模块提供的接口。

**2）**每个模块的文件(可能多个)保存在一个独立文件夹中。

> 模块文件较多时可采用子目录的方式，物理上隔离不同层次的文件。子目录下源文件和头文件应分开存放，如分别置入include和source目录。

**3）**用于模块裁减的条件编译宏保存在一个独立文件中，便于软件裁减。

**4）**硬件相关代码和操作系统相关代码与工程代码相对独立保存，以便于软件移植。

**5）**按相同功能或相关性组织源文件和头文件。同一文件内的聚合度要高，不同文件中的耦合度要低。

> 在对既有工程做单元测试时，耦合度低的文件布局非常便于搭建环境。

**6）**声明和定义分开，使用头文件暴露模块需要提供给外部的类型、宏、变量和函数。尽量做到模块对外部透明，用户在使用模块功能时无需了解具体的实现。

**7）作为对外接口的头文件一经发布，应保持稳定。修改时一定要慎重。

**8）文件夹和文件命名要能够反映出模块的功能。

**9）正式版本和测试版本使用统一文件，使用宏控制是否产生测试输出。

**10）必要的注释不可缺少。


# 五、利用头文件模块化编程


下面是一个简单的示例，展示如何使用头文件进行模块化编程：

### 步骤 1: 创建头文件

假设我们有一个数学库，我们想要创建一个模块来处理基本的数学运算。我们可以创建一个头文件`mathops.h`，其中包含我们想要提供的函数的声明。

```c
// mathops.h


#ifndef MATHOPS_H
#define MATHOPS_H  
//上面两句是防止多次重复定义头文件所用的



// 函数声明
int add(int a, int b);
int subtract(int a, int b);
int multiply(int a, int b);
int divide(int a, int b);

#endif // MATHOPS_H
```


**注意：** 内联函数可以作为特殊函数声明说明，可以直接插入到头文件中直接调用


内联函数是一种特殊的函数，编译器在编译时会将其代码直接插入到每个调用点，而不是生成函数调用的代码。这可以通过在函数声明前加上 `inline` 关键字来实现。

内联函数的声明和定义通常放在头文件中，因为：

- **减少函数调用开销**：内联函数可以减少函数调用的开销，尤其是在函数体较小的情况下。
- **代码可见性**：内联函数的实现对使用它的代码是可见的，这有助于调试和理解代码的行为。


```c

// mathops.h
#ifndef MATHOPS_H
#define MATHOPS_H

// inline关键字
inline int add(int a, int b) {
    return a + b;
}

#endif // MATHOPS_H
```



### 步骤 2: 实现函数

接下来，我们在另一个源文件`mathops.c`中实现这些函数。

```c
// mathops.c
#include "mathops.h"  // 注意实现函数这一端也要包含该头文件

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

int divide(int a, int b) {
    if (b != 0) {
        return a / b;
    } else {
        return 0; // 这里简化处理，实际应用中应该处理除以零的情况
    }
}
```

```ad-note
title:思考

- 这样main.c函数和mathops.c函数双方通过包含#include "mathops.h"操作完成**函数模块映射绑定**



```





### 步骤 3: 使用模块

现在，我们可以在主程序或其他模块中使用这个数学库。我们只需要包含头文件，并链接相应的源文件。

```c
// main.c
#include <stdio.h>
#include "mathops.h"

int main() {
    int result = add(10, 5);
    printf("10 + 5 = %d\n", result);

    result = subtract(10, 5);
    printf("10 - 5 = %d\n", result);

    result = multiply(10, 5);
    printf("10 * 5 = %d\n", result);

    result = divide(10, 5);
    printf("10 / 5 = %d\n", result);

    return 0;
}
```

### 步骤 4: 编译程序

在编译时，你需要确保编译器知道所有的源文件。例如，如果你使用的是GCC编译器，你可以这样编译程序：

```bash
gcc main.c mathops.c -o program
```

这将生成一个可执行文件`program`，你可以运行它来看到结果。

通过这种方式，你可以将程序分解成多个模块，每个模块都有自己的头文件和源文件。这样做的好处是代码更加组织化，易于维护和重用。

