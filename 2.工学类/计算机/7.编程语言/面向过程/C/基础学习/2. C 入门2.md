
**第一部分：准备与基础**

1. **计算机编程基础概念**
    
    - 什么是计算机程序？
    - 什么是计算机语言？
    - 常见的计算机语言类型有哪些？ (简要提及，作为C的上下文)
2. **C语言概述**
    
    - 什么是C语言？ (定义与特点)
    - C语言历史 (简要介绍发展历程)
    - C语言标准 (ANSI C, C99, C11, C18 等)
    - C语言现状 (在哪些领域仍被广泛使用)
    - 为什么要学习C语言？ (C语言的优势，对理解底层、学习后续语言的帮助)
3. **开发环境准备**
    
    - 工欲善其事必先利其器 (强调工具重要性)
    - 编写C语言程序用什么工具？ (编译器、集成开发环境 IDE)
    - 什么是Qt Creator？ (作为IDE的介绍)
    - Qt Creator安装 (提供安装指导或链接)
    - 什么是环境变量？ (简要解释PATH等)
    - 为什么要配置系统变量，不配置用户变量 (解释作用域和优先级)
    - Qt Creator快捷键 (常用快捷键介绍)
4. **第一个C程序**
    
    - 如何创建C语言程序 (项目创建流程)
    - 如何创建C语言文件 (.c 文件)
    - C语言程序组成 (基本结构)
    - 如何运行编写好的程序 (编译、链接、执行过程)
    - `main` 函数
        - `main` 函数注意点及其它写法 (int main(), void main()等规范与非规范)
5. **程序基本要素**
    
    - 什么是注释？ (作用与目的)
    - 为什么要使用注释？ (提高可读性)
    - 注释的分类 (单行 `//`, 多行 `/* */`)
    - 注释的注意点
    - 注释的应用场景
    - 使用注释的好处 (总结)
    - 什么是关键字？ (定义)
    - 关键字分类 (简要提及)
    - 什么是标识符？ (定义)
    - 标识符命名规则 (硬性规定)
    - 标识符命名规范 (推荐风格)
    - 练习 (标识符识别与命名)

**第二部分：数据与运算**

6. **数据与数据类型**
    
    - 什么是数据？
    - 数据分类 (数值、字符等概念)
    - C语言数据类型 (基本类型：int, float, double, char 等)
    - 类型说明符 (short, long, signed, unsigned)
    - `short` 和 `long` (长度修饰)
    - `signed` 和 `unsigned` (符号修饰)
7. **常量与变量**
    
    - 什么是常量？ (定义)
    - 常量的类型 (字面常量，`const` 常量)
    - 什么是变量？ (定义)
    - 如何定义变量 (语法)
    - 如何使用变量？ (读写)
    - 变量的初始化 (定义时赋值)
    - 如何修改变量值？ (赋值操作)
    - 变量之间的值传递 (赋值的本质)
    - 如何查看变量的值？ (调试或打印输出)
8. **运算符与表达式**
    
    - 运算符基本概念
    - 运算符分类 (算术、关系、逻辑、赋值等)
    - 算数运算符 (+, -, *, /, %)
    - 赋值运算符 (=, +=, -= 等)
    - 自增自减运算符 (++, --)
    - `sizeof` 运算符 (计算类型或变量的大小)
    - 逗号运算符 (,)
    - 关系运算符 (>, <, >=, <=, ==, !=)
    - 逻辑运算符 (&&, ||, !)
    - 三目运算符 (?:)
    - 运算符的优先级和结合性
    - 类型转换 (隐式转换，强制转换)
    - 阶段练习 (综合运用变量、常量、运算符)
9. **输入输出 (I/O)**
    
    - `printf` 函数 (格式化输出)
    - `scanf` 函数 (格式化输入)
    - `scanf` 运行原理 (简要解释缓冲区概念)
    - `putchar` 和 `getchar` (字符输入输出)
10. **内存初步了解**
    
    - 变量内存分析（简单版）(变量存储在内存中)
    - `char` 类型内存存储细节 (ASCII 码)

**第三部分：流程控制**

11. **流程控制基本概念** (顺序、选择、循环)
    
12. **选择结构**
    
    - `if` 语句 (单分支、双分支、多分支)
    - 选择结构 `switch` (多分支选择)
13. **循环结构**
    
    - 循环结构 `while`
    - 循环结构 `do while`
    - 循环结构 `for`
    - 四大跳转 (`break`, `continue`, `goto`, `return` - `goto` 了解即可)
14. **循环的应用**
    
    - 循环的嵌套
    - 图形打印 (利用嵌套循环打印星号图等)
    - C语言程序练习 (综合运用选择和循环)

**第四部分：函数**

15. **函数基本概念**
    
    - 什么是函数？ (模块化)
    - 函数的分类 (库函数，自定义函数)
    - 函数的定义 (语法)
    - 函数的参数和返回值 (形参、实参、return 语句)
    - 函数的声明 (提前告知编译器)
    - 如何执行定义好的函数 (函数调用)
    - `main` 函数分析 (作为程序入口)
    - 递归函数 (了解概念，简单示例)
16. **作用域与存储类别**
    
    - 全局变量和局部变量 (作用域)
    - 变量的作用域 (块作用域、函数作用域、文件作用域)
    - `auto` 和 `register` 关键字
    - `static` 关键字 (修饰局部变量、全局变量、函数)
    - `extern` 关键字 (引用外部变量或函数)
    - `static` 与 `extern` 对函数的作用

**第五部分：数组与字符串**

17. **数组**
    
    - 数组的基本概念 (同类型元素的集合)
    - 定义数组 (语法)
    - 初始化数组
    - 数组的使用 (通过下标访问元素)
    - 数组的遍历 (循环访问所有元素)
    - 数组长度计算方法 (`sizeof` 应用)
    - 练习 (数组基本操作)
    - 数组内部存储细节 (内存是连续的)
    - 数组的越界问题 (常见错误)
    - 数组注意事项
18. **数组与函数**
    
    - 数组元素作为函数参数 (值传递)
    - 数组名作为函数参数 (地址传递)
    - 数组名作函数参数的注意点 (退化为指针)
19. **二维数组**
    
    - 二维数组的基本概念
    - 二维数组的定义
    - 二维数组的初始化
    - 二维数组的遍历和存储 (行主序)
    - 二维数组的遍历
    - 二维数组的存储
    - 二维数组与函数 (作为函数参数)
    - 二维数组作为函数参数注意点
20. **字符串**
    
    - 字符串的基本概念 (字符数组)
    - 字符串的初始化
    - 字符串输出 (`printf`, `puts`)
    - 字符串常用方法 (引入 `string.h` 库函数，如 `strlen`, `strcpy`, `strcat`, `strcmp` 等)
    - 练习 (字符串操作)
    - 字符串数组基本概念 (存储多个字符串)
21. **查找与排序** (作为数组应用的实例)
    
    - 折半查找 (二分查找)
    - 选择排序
    - 冒泡排序
    - 插入排序
    - 希尔排序 (了解)
    - 计数排序（Counting Sort）(了解)

**第六部分：指针**

22. **指针基本概念**
    
    - 什么是指针？ (内存地址)
    - 什么是指针变量？ (存放地址的变量)
    - 定义指针变量的格式
    - 指针变量的初始化方法
    - 访问指针所指向的存储空间 (解引用 `*`)
    - 指针类型 (决定步长)
    - 二级指针 (指向指针的指针)
    - 练习 (指针基础操作)
23. **指针与数组/字符串**
    
    - 指针访问数组元素 (指针算术运算)
    - 指针与字符串 (字符串字面量、字符数组与指针的关系)
24. **更高级的指针应用**
    
    - 指向函数指针 (函数地址)

**第七部分：复合数据类型**

25. **结构体 (Struct)**
    
    - 什么是结构体？ (不同类型数据的集合)
    - 定义结构体类型
    - 定义结构体变量
    - 结构体成员访问 (. 和 -> 运算符)
    - 结构体变量的初始化
    - 结构体类型作用域
    - 结构体数组
    - 结构体指针
    - 结构体内存分析 (对齐问题简述)
    - 结构体变量占用存储空间大小
    - 结构体嵌套定义
    - 结构体和函数 (作为参数和返回值)
26. **共用体 (Union)**
    
    - 共用体基本概念 (内存共享)
27. **枚举 (Enum)**
    
    - 枚举基本概念 (定义命名常量集)

**第八部分：内存管理**

28. **内存区域**
    
    - 进程空间 (简要划分)
    - 栈内存 (Stack) (局部变量、函数调用)
    - 堆内存 (Heap) (动态分配)
29. **动态内存分配**
    
    - `malloc` 函数 (分配内存)
    - `free` 函数 (释放内存)
    - `calloc` 函数 (分配并清零)
    - `realloc` 函数 (重新分配内存)
30. **链表** (作为动态内存和指针的综合应用)
    
    - 链表基本概念 (与数组的对比)
    - 静态链表 (了解，不常用)
    - 动态链表 (核心)
    - 动态链表头插法
    - 动态链表尾插法
    - 动态链优化 (例如双向链表，此处可不深入)
    - 链表销毁 (释放所有节点内存)
    - 链表长度计算
    - 链表查找
    - 链表删除
    - 作业 (链表操作练习)

**第九部分：文件操作**

31. **文件基本概念** (文件、文件指针FILE)
    - 文件的打开和关闭 (`fopen`, `fclose`)
    - 一次读写一个字符 (`fgetc`, `fputc`)
    - 一次读写一行字符 (`fgets`, `fputs`)
    - 一次读写一块数据 (`fread`, `fwrite`)
    - 读写结构体 (应用 `fread`, `fwrite`)
    - 其它文件操作函数 (`fseek`, `ftell`, `rewind`, `feof`, `ferror` 等)

**第十部分：预处理与杂项**

32. **预处理指令**
    
    - 预处理指令的概念 (编译前处理)
    - 宏定义 (`##define` 简单宏)
    - 带参数的宏定义
    - 条件编译 (`##ifdef`, `##ifndef`, `##if`, `##elif`, `##else`, `##endif`)
33. **其他关键字**
    
    - `typedef` 关键字 (类型重命名)
    - 宏定义与函数以及`typedef`区别
    - `const` 关键字 (定义只读变量，与常量的区别)
    - 如何使用 `const`?
34. **计算机底层概念回顾**
    
    - 进制基本概念 (二进制、八进制、十进制、十六进制)
    - 进制转换 (各进制互转方法)
    - 十进制小数转换为二进制小数
    - 二进制小数转换为十进制小数
    - 原码反码补码 (整数在计算机中的表示)
    - 位运算符 (&, |, ^, ~, <<, >>)
    - 变量内存分析 (结合原码反码补码，更深入理解整数存储)
35. **编译过程**
    
    - Qt Creator编译过程做了什么? (预处理、编译、汇编、链接)
    - 计算机是运算过程分析 (简要理解CPU执行指令过程)
36. **学习方法与实践**
    
    - 初学者如何避免程序出现BUG (调试技巧、代码风格、逐步测试)
    - C语言程序练习 (贯穿各章节的综合练习)

# **第一部分：准备与基础**

## 1. 计算机编程基础概念

_**什么是计算机 ?**_
    
- 顾名思义，就是能够进行数据运算的机器(台式电脑、笔记本电脑、平板电脑、智能手机)
- [计算机_百度百科](https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338?fr=aladdin)

_**计算机的发明者是谁 ?**_
    
- 关于电子计算机的发明者是谁这一问题，有好几种答案:
    - 1936年***英国数学家图灵***首先提出了一种以程序和输入数据相互作用产生输出的计算机***构想***，后人将这种机器命名为通用图灵计算机
    - 1938年***克兰德·楚泽***发明了首台采用***继电器***进行工作的计算机,这台计算机命名为***Z1***，但是继电器是机械式的，并不是完全的电子器材
    - 1942年***阿坦那索夫和贝利***发明了首台采用***真空管***的计算机，这台计算机命名为***ABC***
    - 1946年ENIAC诞生,它拥有了今天计算机的主要结构和功能，是通用计算机

> - 现在世界上***公认***的第一台现代电子计算机是1946年在美国宾夕法尼亚大学诞生的ENIAC(Electronic Numerical Integrator And Calculator)

_**计算机特点是什么 ?**_
- 计算机是一种电器, 所以计算机只能识别两种状态, _**一种是通电一种是断电**_
        
    - 正是因为如此, 最初ENIAC的程序是由很多开关和连接电线来完成的。但是这样导致***改动一次程序要花很长时间***(需要人工重新设置很多开关的状态和连接线)
        
    - ![](https://i-blog.csdnimg.cn/blog_migrate/8c500024dd4bd5feac55680c3c89f4f4.jpeg)
        
    - 为了提高效率,工程师们想能不能把程序和数据都放在存储器中, 数学家冯·诺依曼将这个思想以数学语言系统阐述，提出了存储程序计算机模型(这是所谓的冯·诺依曼机)
        
    - 那利用数学语言如何表示计算机能够识别的通电和断电两种状态呢?
        
        - 非常简单用0和1表示即可
        - _**所以计算机能识别的所有指令都是由0和1组成的**_
        - _**所以计算机中存储和操作的数据也都是由0和1组成的**_

> 0和1更准确的是应该是高电平和低电平, 但是这个不用了解, 只需要知道计算机只能识别0和1以及存储的数据都是由0和1组成的即可。

---

#### 1.1. 什么是计算机程序？
- 计算机程序是为了告诉计算机"做某件事或解决某个问题"而用"***计算机语言***编写的命令集合(语句)
    
- 只要让计算机执行这个程序,计算机就会自动地、有条不紊地进行工作,计算机的一切操作都是由程序控制的,离开程序,计算机将一事无成
    
- 现实生活中你如何告诉别人如何做某件事或者解决某个问题?
    
    - 通过人能听懂的语言: 张三你去楼下帮我买一包烟, 然后顺便到快递箱把我的快递也带上来
    - 其实我们通过人能听懂的语言告诉别人做某件事就是在发送一条条的指令
    - 计算机中也一样, 我们可以通过计算机语言告诉计算机我们想做什么, 每做一件事情就是一条指令, 一条或多条指令的集合我们就称之为一个计算机程序

---

#### 1.2. 什么是计算机语言？
- _**在日常生活、工作中, 语言是人们交流的工具**_
    - 中国人和中国人交流,使用中文语言
    - 美国人和美国人交流,使用英文语言
    - 人想要和计算机交流,使用计算机语言
- _**可以看出在日常生活、工作中,人们使用的语言种类很多**_
    - 如果一个很牛人可能同时掌握了中文语言和英文语言, 那么想要和这个人交流既可以使用中文语言,也可以使用英文语言
    - 计算机其实就是一个很牛的人, 计算机同时掌握了几十门甚至上百门语言, 所以我们只要使用任何一种计算机已经掌握的语言就可以和计算机交流

---

#### 1.3. 常见的计算机语言类型有哪些？
- _**机器语言**_
    - 所有的代码里面只有0和1, 0表示不加电,1表示加电(纸带存储时 1有孔,0没孔)
    - 优点：直接对硬件产生作用，程序的执行效率非常非常高
    - 缺点：指令又多又难记、可读性差、无可移植性
- _**汇编语言**_
    - 符号化的机器语言，用一个符号（英文单词、数字）来代表一条机器指令
    - 优点：直接对硬件产生作用，程序的执行效率非常高、可读性稍好
    - 缺点：符号非常多和难记、无可移植性
- _**高级语言**_
    - 非常接近自然语言的高级语言，语法和结构类似于普通英文
    - 优点：简单、易用、易于理解、远离对硬件的直接操作、有可移植性
    - 缺点：有些高级语言写出的程序执行效率并不高
- _**对比(利用3种类型语言编写1+1)**_
    - 机器语言
        - `10111000 00000001 00000000 00000101 00000001 00000000`
    - 汇编语言
        - `MOV AX, 1 ADD AX, 1`
    - 高级语言
        - `1 + 1`

---

## 2. C语言概述
#### 2.1. 什么是C语言？
- _**C语言是一种用于和计算机交流的高级语言, 它既具有高级语言的特点，又具有汇编语言的特点**_
    - 非常接近自然语言
    - 程序的执行效率非常高
- C语言是所有编程语言中的经典，很多高级语言都是从C语言中衍生出来的，
    - 例如:C++、C##、Object-C、Java、Go等等
- C语言是所有编程语言中的经典，很多著名的系统软件也是C语言编写的
    - 几乎所有的操作系统都是用C语言编写的
    - 几乎所有的计算机底层软件都是用C语言编写的
    - 几乎所有的编辑器都是C语言编写的

---

#### 2.2. C语言历史
![](https://i-blog.csdnimg.cn/blog_migrate/340661a96441de8c2cb4855b1a7aec93.png)

- 最早的高级语言:FORTRAN–>ALGOL–>CPL–>BCPL–>C–>C++等

> “初,世间无语言,仅电路与连线。及大牛出,天地开,始有 FORTRAN、 LISP、ALGOL 随之, 乃有万种语”

- 1963年英国剑桥大学推出了CPL(Combined Programming Langurage)语言。 CPL语言在ALGOL 60的基础上接近硬件一些,但规模比较大,难以实现
- 1967年英国剑桥大学的 Matin Richards(理查兹)对CPL语言做了简化,推出了 BCPL (Base Combined Programming Langurage)语言
- 1970年美国贝尔实验室的 Ken Thompson(肯·汤普逊) 以 BCPL 语言为基础,又作了进一步的简化,设计出了很简单的而且很接近硬件的 B 语言(取BCPL的第一个字母),并用B语言写出了第一个 UNIX 操作系统。但B语言过于简单,功能有限
- 1972年至1973年间,贝尔实验室的 Dennis.Ritchie(丹尼斯·里奇) 在 B语言的基础上设计出了C语言(取BCPL的第二个字母)。C语言即保持 BCPL 语言和B语言的优点(精练、接近硬件),又克服了他们的缺点(过于简单,数据无类型等)  
    ![](https://i-blog.csdnimg.cn/blog_migrate/47ead88e6cde25385b502c4f5d96e481.png)

#### 2.3. C语言标准
- 1983年美国国家标准局(American National Standards Institute，_**简称ANSI**_)成立了一个委员会，开始制定C语言标准的工作
- 1989年C语言标准被批准，这个版本的C语言标准通常被称为ANSI C(_**C89**_)
- 1999年，国际标准化组织ISO又对C语言标准进行修订，在基本保留原C语言特征的基础上，针对应该的需要，增加了一些功能，命名为***C99***
- 2011年12月，ANSI采纳了ISO/IEC 9899:2011标准。这个标准通常即***C11，它是C程序语言的现行标准***

---

#### 2.4. C语言现状
- 年度编程语言
    - 该奖项颁发给了一年中最热门的编程语言  
        ![](https://i-blog.csdnimg.cn/blog_migrate/974170c4a8a49f801084c5699f56fbf3.png)
- [编程语言排行榜查看](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html)

---

#### 2.5. 为什么要学习C语言？
- 40多年经久不衰
- 了解操作系统、编译原理、数据结构与算法等知识的最佳语言
- 了解其它语言底层实现原理必备语言
- 基础语法与其它高级语言类似,学会C语言之后再学习其它语言事半功倍,且知根知底

> 当你想了解底层原理时,你才会发现后悔当初没有学习C语言  
> 当你想学习一门新的语言时, 你才会发现后悔当初没有学习C语言  
> 当你使用一些高级框架、甚至系统框架时发现提供的API都是C语言编写的, 你才发现后悔当初没有学习C语言  
> 学好数理化,走遍天下都不拍  
> 学好C语言,再多语言都不怕

---

###### 如何学好C语言 
<!-- This content was under "###### 如何学好C语言" in the original, placed here as it relates to learning C -->
|学习本套课程之前|学习本套课程中|学习本套课程之后|
|---|---|---|
|![](https://i-blog.csdnimg.cn/blog_migrate/a5d66ef933020b4301aaf8bd427131f9.gif)|![](https://i-blog.csdnimg.cn/blog_migrate/ca972389658e6894ef24d05cf4552759.gif)|[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gHyaoC72-1623039894713)(https://upload-images.jianshu.io/upload_images/647982-c724f6cd01191121.png?imageMogr2/auto-orient/strip)]|

- 如何达到这样的效果  
    ![](https://i-blog.csdnimg.cn/blog_migrate/02351ffb8819b270ab13ad578ab9a90b.jpeg)

#### 2.6. 多语言对比
- C语言

```c
##include<stdio.h>
int main() {
    printf("南哥带你装B带你飞");
    return 0;
}
```

- C++语言

```cpp
##include<iostream>
using namespace std;
int main() {
    cout << "南哥带你装B带你飞" << endl;
    return 0;
}
```

- OC语言

```objc
##import <Foundation/Foundation.h>
int main() {
    NSLog(@"南哥带你装B带你飞");
    return 0;
}
```

- Java语言

```java
class Test
{
    public static void main(String[] args) // Corrected from viod to void and added String[] args
    {
        System.out.println("南哥带你装B带你飞");
    }
}
```

- Go语言

```go
package main
import  "fmt" //引入fmt库
func main() {
    fmt.Println("南哥带你装B带你飞")
}
```
---

## 3. 开发环境准备
#### 3.1. 工欲善其事必先利其器
<!-- This section was a heading in the original. Content is implicitly the importance of tools. -->

#### 3.2. 编写C语言程序用什么工具？
- 记事本(开发效率低)
- Vim(初学者入门门槛高)
- VSCode(不喜欢)
- eclipse(不喜欢)
- CLion(深爱, 但收费)
- Xcode(逼格高, 但得有苹果电脑)
- Qt Creator(开源免费,跨平台安装和运行)

---

#### 3.3. 什么是Qt Creator？
- Qt Creator 是一款新的轻量级[集成开发环境](https://baike.baidu.com/item/%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83)（IDE）。它能够跨平台运行，支持的系统包括 Windows、Linux（32 位及 64 位）以及 Mac OS X
- Qt Creator 的设计目标是使开发人员能够利用 Qt 这个应用程序框架更加快速及轻易的完成开发任务
- 开源免费, 简单易用, 能够满足学习需求

> 集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码[编辑器](https://baike.baidu.com/item/%E7%BC%96%E8%BE%91%E5%99%A8)、[编译器](https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8)、[调试](https://baike.baidu.com/item/%E8%B0%83%E8%AF%95)器和[图形用户界面](https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2)等工具。集成了代码编写功能、分析功能、[编译](https://baike.baidu.com/item/%E7%BC%96%E8%AF%91)功能、调试功能等一体化的开发软件服务套。

---

#### 3.4. Qt Creator安装
- _**切记囫囵吞枣, 不要纠结里面的东西都是什么含义, 初学者安装成功就是一种成功**_
    
- _**下载Qt Creator离线安装包:**_
    
    - http://download.qt.io/archive/qt/5.11/5.11.0/  
        ![](https://i-blog.csdnimg.cn/blog_migrate/e36c9c8525eea980c258a8928b1572a0.png)
- _**以管理身份运行离线安装包**_  
    ![](https://i-blog.csdnimg.cn/blog_migrate/10e1c1c22fce30db47aa18d035c8d3fc.png)
    
- _**下一步,下一步,下一步,等待ing…**_
    
    - ![](https://i-blog.csdnimg.cn/blog_migrate/4846be4cece1b7c70be94cd5fb087d5f.png)  
        +![](https://i-blog.csdnimg.cn/blog_migrate/cc1678dfcf9e1094bd6eba47829ef623.png)  
        +![](https://i-blog.csdnimg.cn/blog_migrate/a5bedb8bc3c975552f00ed4217fc5aa0.png)
- _**注意安装路径中最好不要出现中文**_
    
    - ![](https://i-blog.csdnimg.cn/blog_migrate/896377b75958a98fe71c138f89dc1417.png)
- _**对于初学者而言全选是最简单的方式(重点!!!)**_  
    ![](https://i-blog.csdnimg.cn/blog_migrate/a327529a02a6baa2140d5dc18747b23e.png)
    
    - ![](https://i-blog.csdnimg.cn/blog_migrate/7cdde33e05d5f31af60945a03f2533ed.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/64f17b59b41d1bad8cb56aa4198b752c.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/ef77ccbf84ac072e89b440e7d23b366c.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/9750feb5ed1a224e1a4c1e9a31661429.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/017ebee4941f2ac1c666fc4f9d89346b.png)
- _**配置Qt Creator开发环境变量**_
    
    - ![](https://i-blog.csdnimg.cn/blog_migrate/d0335d774213628ca5eb84de5679a915.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/cd0d40901e0e9376593914e59e538ee9.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/2da6d6095484f2461d07208d880560da.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/e494be87a60c9d912c4eb1a33a3d6add.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/e97803aa055393c45803195e9618f5da.png)

> 你的安装路径\5.11.0\mingw53_32\bin  
> 你的安装路径\Tools\mingw530_32\bin

- _**启动安装好的Qt Creator**_  
    ![](https://i-blog.csdnimg.cn/blog_migrate/aa351475dedc4daf0ea48432b1048d79.png)

---

- _**非全选安装到此为止, 全选安装继续往下看**_
    - _**出现这个错误, 忽略这个错误即可**_
    - ![](https://i-blog.csdnimg.cn/blog_migrate/c8cca09f59ca77fc17c3f1f36b4a70ad.png)
- _**等待安装完毕之后解决刚才的错误**_
    - _**找到安装目录下的strawberry.msi,双击运行**_  
        ![](https://i-blog.csdnimg.cn/blog_migrate/7e54cc5cc72c2db00b85a1757ce7c3dd.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/007156d1e7e00b5232a67767a1b6b348.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/63dfaf924ad57cf8f8fa8e780308cfd9.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/4e78d39d977aa6ba2a0392babbb0b969.png)

![](https://i-blog.csdnimg.cn/blog_migrate/d1d88565a3f9a21bd2b1568259205374.png)  
![](https://i-blog.csdnimg.cn/blog_migrate/d0797154e2e83dd62a2905ea3a257447.png)

#### 3.5. 什么是环境变量？
- 打开我们添加环境变量的两个目录, 不难发现里面大部分都是.exe的可执行程序
- 如果我们不配置环境变量, 那么每次我们想要使用这些"可执行程序"都必须"先找到这些应用程序对应的文件夹"才能使用
- 为了方便我们在电脑上"任何地方"都能够使用这些"可执行程序", 那么我们就必须添加环境变量, 因为Windows执行某个程序的时候, 会先到"环境变量中Path指定的路径中"去查找

---

#### 3.6. 为什么要配置系统变量，不配置用户变量
- 用户变量只针对使用这台计算机指定用户
    - 一个计算机可以设置多个用户, 不同的用户用不同的用户名和密码
    - 当给计算机设置了多个用户的时候,启动计算机的时候就会让你选择哪个用户登录
- 系统变量针对使用这台计算机的所有用户
    - 也就是说设置了系统变量, 无论哪个用户登录这台计算机都可以使用你配置好的工具

---

#### 3.7. Qt Creator快捷键
- [Qt Creator Keyboard Shortcuts(Documentation)](http://doc.qt.io/qtcreator/creator-keyboard-shortcuts.html "Qt Creator Keyboard Shortcuts(Documentation)")
- [Qt Creator Keyboard Shortcuts(Wiki)](http://wiki.qt.io/Qt_Creator_Keyboard_Shortcuts "Qt Creator Keyboard Shortcuts(Wiki)")

---

## 4. 第一个C程序
#### 4.1. 如何创建C语言程序
- 这个世界上, 几乎所有程序员入门的第一段代码都是Hello World.
- 原因是当年C语言的作者Dennis Ritchie(丹尼斯 里奇)在他的名著中第一次引入, 传为后世经典, 其它语言亦争相效仿, 以示敬意  
    ![](https://i-blog.csdnimg.cn/blog_migrate/f35c3506a9839d6447cdf909deb9b734.png)

#### 4.2. 如何创建C语言文件
![](https://i-blog.csdnimg.cn/blog_migrate/3ce88aec6a321fed07facfa61c6831d6.png)

![](https://i-blog.csdnimg.cn/blog_migrate/52c4905dda08fc1c4bea21cee271356d.png)  
![](https://i-blog.csdnimg.cn/blog_migrate/2de11280c60d3525e596af0ece548626.png)  
![](https://i-blog.csdnimg.cn/blog_migrate/ce58e4563a423e06d58838c3a65c812d.png)  
![](https://i-blog.csdnimg.cn/blog_migrate/8e7191fda8cd271a2b48422a1c4781f0.png)  
![](https://i-blog.csdnimg.cn/blog_migrate/cee3da33b35a6e74f6515861392adfe3.png)

#### 4.3. C语言程序组成
- 手机有很多功能, “开机”,“关机”,“打电话”,“发短信”,"拍照"等等
    
- 手机中的每一个功能就相当于C语言程序中的一个程序段(函数)
    
- 众多功能中总有一个会被先执行,不可能多个功能一起执行
    
- 想使用手机必须先执行手机的开机功能
    
- 所以C语言程序也一样,由众多功能、众多程序段组成, 众多C语言程序段中总有一个会被先执行, 这个先执行的程序段我们称之为"主函数"  
    ![](https://i-blog.csdnimg.cn/blog_migrate/f60d1bfdb71141b43cc1e5a0da24c2ed.jpeg)
    
- 一个C语言程序由多个"函数"构成,每个函数有自己的功能
    
- 一个程序***有且只有一个主函数***
    
- 如果一个程序没有主函数,则这个程序不具备运行能力
    
- 程序运行时系统会***自动调用***主函数,而其它函数需要开发者***手动调用***
    
- 主函数有固定书写的格式和范写  
    ![](https://i-blog.csdnimg.cn/blog_migrate/34264d2bfcffb8409af3162d6666917a.png)

###### 4.3.1. 函数定义格式 
<!-- Sub-section based on original content structure -->
- 主函数定义的格式:
    - int 代表函数执行之后会返回一个整数类型的值
    - main 代表这个函数的名字叫做main
    - () 代表这是一个函数
    - {} 代表这个程序段的范围
    - return 0; 代表函数执行完之后返回整数0

```c
int main() {
    // insert code here...
    return 0;
}
```

- 其它函数定义的格式
    - int 代表函数执行之后会返回一个整数类型的值
    - call 代表这个函数的名字叫做call
    - () 代表这是一个函数
    - {} 代表这个程序段的范围
    - return 0; 代表函数执行完之后返回整数0

```c
int call() {
    return 0;
}
```
---
###### 4.3.2. 如何执行定义好的函数 
<!-- Sub-section based on original content structure, relevant to program composition -->
- 主函数(main)会由系统自动调用, 但其它函数不会, 所以想要执行其它函数就必须在main函数中手动调用
    - call 代表找到名称叫做call的某个东西
    - () 代表要找到的名称叫call的某个东西是一个函数
    - ; 代表调用函数的语句已经编写完成
    - 所以call();代表找到call函数, 并执行call函数

```c
int main() {
    call();
    return 0;
}
```

- 如何往屏幕上输出内容
    - 输出内容是一个比较复杂的操作, 所以系统提前定义好了一个专门用于输出内容的函数叫做printf函数,我们只需要执行系统定义好的printf函数就可以往屏幕上输出内容
    - 但凡需要执行一个函数, 都是通过函数名称+圆括号的形式来执行
    - 如下代码的含义是: 当程序运行时系统会自动执行main函数, 在系统自动执行main函数时我们手动执行了call函数和printf函数
    - 经过对代码的观察, 我们发现两个问题
        - 并没有告诉printf函数,我们要往屏幕上输出什么内容
        - 找不到printf函数的实现代码

```c
int call(){
    return 0;
}

int main(){
    call();
    printf();
    return 0;
}
```

- 如何告诉printf函数要输出的内容
    - 将要输出的内容编写到printf函数后面的圆括号中即可
    - 注意: 圆括号中编写的内容必须用双引号引起来

```c
printf("hello world\n");
```

- 如何找到printf函数的实现代码
    - 由于printf函数是系统实现的函数, 所以想要使用printf函数必须在使用之前告诉系统去哪里可以找到printf函数的实现代码
    - ##include <stdio.h> 就是告诉系统可以去stdio这个文件中查找printf函数的声明和实现

```c
##include <stdio.h>

int call(){
    return 0;
}

int main(){
    call();
    printf("hello world\n");
    return 0;
}
```
---

#### 4.4. 如何运行编写好的程序
- 方式1:
    - 点击小榔头将"源代码"编译成"可执行文件"
    - 找到编译后的源代码, 打开终端(CMD)运行可执行文件  
        ![](https://i-blog.csdnimg.cn/blog_migrate/902862c835362157a152d412359c958e.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/5e739b3c2329be97e9fc9db0c4c9c6d1.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/463f815b92705f93c31beadecfa12991.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/4b7bf9ca7de744c1013b1844ee478d41.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/740b46de1687e32387eff2d6ccc9fe3f.png)
- 方式2
    - 直接点击Qt开发工具运行按钮  
        ![](https://i-blog.csdnimg.cn/blog_migrate/93849359671c9bae133e2877178718c2.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/2e0cc10369e638d7a4435b8f6f27798c.png)

---

#### 4.5. `main` 函数
###### 4.5.1. `main` 函数注意点及其它写法
- C语言中,每条完整的语句后面都必须以分号结尾

```c
int main(){
    printf("hello world\n") // 如果没有分号编译时会报错
    return 0;
}
```

```c
int main(){
    // 如果没有分号,多条语句合并到一行时, 系统不知道从什么地方到什么地方是一条完整语句
    printf("hello world\n") return 0;
}
```

- C语言中除了注释和双引号引起来的地方以外都不能出现中文

```c
int main(){
    printf("hello world\n"); // 这里的分号如果是中文的分号就会报错
    return 0;
}
```

- 一个C语言程序只能有一个main函数

```c
int main(){
    return 0;
}
int main(){ // 编译时会报错, 重复定义
    return 0;
}
```

- 一个C语言程序不能没有main函数

```c
int call(){ // 编译时报错, 因为只有call函数, 没有main函数
    return 0;
}
```

```c
int mian(){ // 编译时报错, 因为main函数的名称写错了,还是相当于没有main函数
    return 0;
}
```

- main函数前面的int可以不写或者换成void

```c
##include <stdio.h>
main(){ // 不会报错
    printf("hello world\n");
    return 0;
}
```

```c
##include <stdio.h>
void main(){  // 不会报错
    printf("hello world\n");
    return 0;
}
```

- main函数中的return 0可以不写

```c
int main(){ // 不会报错
    printf("hello world\n");
}
```

- 多种写法不报错的原因
    - C语言最早的时候只是一种规范和标准(例如C89, C11等)
    - 标准的推行需要各大厂商的支持和实施
    - 而在支持的实施的时候由于各大厂商利益、理解等问题,导致了实施的标准不同,发生了变化
        - Turbo C
        - Visual C(VC)
        - GNU C(GCC)
    - 所以大家才会看到不同的书上书写的格式有所不同, 有的返回int,有的返回void,有的甚至没有返回值
    - 所以大家只需要记住最标准的写法即可, no zuo no die

```c
##include <stdio.h>
int main(){
    printf("hello world\n");
    return 0;
}
```

> Tips:  
> 语法错误：编译器会直接报错  
> 逻辑错误：没有语法错误，只不过运行结果不正确

---
#### 4.6. C语言程序练习 
<!-- This is the heart shape practice -->
- 编写一个C语言程序,用至少2种方式在屏幕上输出以下内容

```
   *** ***
  *********
   *******
    ****
     **
```

- 普通青年实现

```c
printf(" *** *** \n");
printf("*********\n");
printf(" *******\n");
printf("  ****\n");
printf("   **\n");
```

- 2B青年实现

```c
printf(" *** *** \n*********\n *******\n  ****\n   **\n");
```

- 文艺青年实现(装逼的, 先不用理解)

```c
##include <stdio.h> // Added for printf
##include <unistd.h> // Added for sleep (Unix-like systems)
##include <stdlib.h> // Added for system (cls might be system("clear") on Unix)

int main() { // Added main function wrapper
    int  i = 0;
    while (1) {
        if (i % 2 == 0) {
            printf(" *** *** \n");
            printf("*********\n");
            printf(" *******\n");
            printf("  ****\n");
            printf("   **\n");
        }else
        {
            printf("\n");
            printf("   ** ** \n");
            printf("  *******\n");
            printf("   *****\n");
            printf("    **\n");
        }
        sleep(1);
        i++;
        system("cls"); // or system("clear")
    }
    return 0; // Added return
}
```

---

## 5. 程序基本要素
#### 5.1. 什么是注释？
- 注释是在所有计算机语言中都非常重要的一个概念，从字面上看，就是注解、解释的意思
- 注释可以用来解释某一段程序或者某一行代码是什么意思，方便程序员之间的交流沟通
- 注释可以是任何文字，也就是说可以写中文
- 被注释的内容在开发工具中会有特殊的颜色

---

#### 5.2. 为什么要使用注释？
- 没有编写任何注释的程序

```c
void printMap(char map[6][7] , int row, int col);
int main(int argc, const char * argv[])
{
    char map[6][7] = {
        {'##', '##', '##', '##', '##', '##', '##'},
        {'##', ' ', ' ', ' ', '##' ,' ', ' '},
        {'##', 'R', ' ', '##', '##', ' ', '##'},
        {'##', ' ', ' ', ' ', '##', ' ', '##'},
        {'##', '##', ' ', ' ', ' ', ' ', '##'},
        {'##', '##', '##', '##', '##', '##', '##'}
    };
    int row = sizeof(map)/sizeof(map[0]);
    int col = sizeof(map[0])/ sizeof(map[0][0]);
    printMap(map, row, col);
    int pRow = 2;
    int pCol = 1;
    int endRow = 1;
    int endCol = 6;
    while ('R' != map[endRow][endCol]) {
        printf("亲, 请输入相应的操作\n");
        printf("w(向上走) s(向下走) a(向左走) d(向右走)\n");
        char run;
        run = getchar();
        switch (run) {
            case 's':
                if ('##' != map[pRow + 1][pCol]) {
                    map[pRow][pCol] = ' ';
                    pRow++;//3
                    map[pRow][pCol] = 'R';
                }
                break;
            case 'w':
                if ('##' != map[pRow - 1][pCol]) {
                    map[pRow][pCol] = ' ';
                    pRow--;
                    map[pRow][pCol] = 'R';
                }
                break;
            case 'a':
                if ('##' != map[pRow][pCol - 1]) {
                    map[pRow][pCol] = ' ';
                    pCol--;
                    map[pRow][pCol] = 'R';
                }
                break;
            case 'd':
                if ('##' != map[pRow][pCol + 1]) {
                    map[pRow][pCol] = ' ';
                    pCol++;
                    map[pRow][pCol] = 'R';
                }
                break;
        }
        printMap(map, row, col);
    }
    printf("你太牛X了\n");
    printf("想挑战自己,请购买完整版本\n");
    return 0;
}
void printMap(char map[6][7] , int row, int col)
{
    system("cls");
    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; j++) {
            printf("%c", map[i][j]);
        }
        printf("\n");
    }
}
```

![](https://i-blog.csdnimg.cn/blog_migrate/2bf8575b4ddfb874eb42bbbef596b096.png)

- 编写了注释的程序

```c
/*
     R代表一个人
     ##代表一堵墙
//   0123456
     ############## // 0
     ##   ##   // 1
     ##R #### ## // 2
     ##   ## ## // 3
     ####    ## // 4
     ############## // 5

     分析:
     >1.保存地图(二维数组)
     >2.输出地图
     >3.操作R前进(控制小人行走)
      3.1.接收用户输入(scanf/getchar)
      w(向上走) s(向下走) a(向左走) d(向右走)
      3.2.判断用户的输入,控制小人行走
         3.2.1.替换二维数组中保存的数据
             (
                1.判断是否可以修改(如果不是##就可以修改)
                2.修改现有位置为空白
                3.修改下一步为R
             )
      3.3.输出修改后的二维数组
     4.判断用户是否走出出口
*/
##include <stdio.h>  // Added for printf, getchar
##include <stdlib.h> // Added for system

// 声明打印地图方法
void printMap(char map[6][7] , int row, int col);
int main(int argc, const char * argv[])
{
    // 1.定义二维数组保存迷宫地图
    char map[6][7] = {
        {'##', '##', '##', '##', '##', '##', '##'},
        {'##', ' ', ' ', ' ', '##' ,' ', ' '},
        {'##', 'R', ' ', '##', '##', ' ', '##'},
        {'##', ' ', ' ', ' ', '##', ' ', '##'},
        {'##', '##', ' ', ' ', ' ', ' ', '##'},
        {'##', '##', '##', '##', '##', '##', '##'}
    };
    // 2.计算地图行数和列数
    int row = sizeof(map)/sizeof(map[0]);
    int col = sizeof(map[0])/ sizeof(map[0][0]);
    // 3.输出地图
    printMap(map, row, col);
    // 4.定义变量记录人物位置
    int pRow = 2;
    int pCol = 1;
    // 5.定义变量记录出口的位置
    int endRow = 1;
    int endCol = 6;
    // 6.控制人物行走
    while ('R' != map[endRow][endCol]) {
        // 6.1提示用户如何控制人物行走
        printf("亲, 请输入相应的操作\n");
        printf("w(向上走) s(向下走) a(向左走) d(向右走)\n");
        char run;
        run = getchar();
        // 6.2根据用户输入控制人物行走
        switch (run) {
            case 's':
                if ('##' != map[pRow + 1][pCol]) {
                    map[pRow][pCol] = ' ';
                    pRow++;//3
                    map[pRow][pCol] = 'R';
                }
                break;
            case 'w':
                if ('##' != map[pRow - 1][pCol]) {
                    map[pRow][pCol] = ' ';
                    pRow--;
                    map[pRow][pCol] = 'R';
                }
                break;
            case 'a':
                if ('##' != map[pRow][pCol - 1]) {
                    map[pRow][pCol] = ' ';
                    pCol--;
                    map[pRow][pCol] = 'R';
                }
                break;
            case 'd':
                if ('##' != map[pRow][pCol + 1]) {
                    map[pRow][pCol] = ' ';
                    pCol++;
                    map[pRow][pCol] = 'R';
                }
                break;
        }
        // 6.3重新输出行走之后的地图
        printMap(map, row, col);
    }
    printf("你太牛X了\n");
    printf("想挑战自己,请购买完整版本\n");
    return 0;
}

/**
 * @brief printMap
 * @param map 需要打印的二维数组
 * @param row 二维数组的行数
 * @param col 二维数组的列数
 */
void printMap(char map[6][7] , int row, int col)
{
    // 为了保证窗口的干净整洁, 每次打印都先清空上一次的打印
    system("cls"); // or system("clear")
    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; j++) {
            printf("%c", map[i][j]);
        }
        printf("\n");
    }
}
```

---

#### 5.3. 注释的分类
- 单行注释
    
    - // 被注释内容
    - 使用范围:任何地方都可以写注释：函数外面、里面，每一条语句后面
    - 作用范围: 从第二个斜线到这一行末尾
    - 快捷键:Ctrl+/
- 多行注释
    
    - /* 被注释内容 */
    - 使用范围:任何地方都可以写注释：函数外面、里面，每一条语句后面
    - 作用范围: 从第一个/*到最近的一个*/

---

#### 5.4. 注释的注意点
- 单行注释可以嵌套单行注释、多行注释

```c
// 南哥 // it666.com
// /* 江哥 */
// 帅哥
```

- 多行注释可以嵌套单行注释

```c
/*
// 作者：LNJ
// 描述：第一个C语言程序作用：这是一个主函数，C程序的入口点
 */
```

- 多行注释***不能***嵌套多行注释

```c
/* 
哈哈哈
     /*嘻嘻嘻*/  // This will cause issues as the first */ will end the outer comment.
 呵呵呵 
*/
```

---

#### 5.5. 注释的应用场景
- 思路分析

```c
/*
     R代表一个人
     ##代表一堵墙
//   0123456
     ############## // 0
     ##   ##   // 1
     ##R #### ## // 2
     ##   ## ## // 3
     ####    ## // 4
     ############## // 5

     分析:
     >1.保存地图(二维数组)
     >2.输出地图
     >3.操作R前进(控制小人行走)
      3.1.接收用户输入(scanf/getchar)
      w(向上走) s(向下走) a(向左走) d(向右走)
      3.2.判断用户的输入,控制小人行走
         3.2.1.替换二维数组中保存的数据
             (
                1.判断是否可以修改(如果不是##就可以修改)
                2.修改现有位置为空白
                3.修改下一步为R
             )
      3.3.输出修改后的二维数组
     4.判断用户是否走出出口
*/
```

- 对变量进行说明

```c
// 2.计算地图行数和列数
int row = sizeof(map)/sizeof(map[0]);
int col = sizeof(map[0])/ sizeof(map[0][0]);
```

- 对函数进行说明

```c
/**
 * @brief printMap
 * @param map 需要打印的二维数组
 * @param row 二维数组的行数
 * @param col 二维数组的列数
 */
void printMap(char map[6][7] , int row, int col)
{
    system("cls"); // or system("clear")
    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; j++) {
            printf("%c", map[i][j]);
        }
        printf("\n");
    }
}
```

- 多实现逻辑排序

```c
    // 1.定义二维数组保存迷宫地图
    char map[6][7] = {
        {'##', '##', '##', '##', '##', '##', '##'},
        {'##', ' ', ' ', ' ', '##' ,' ', ' '},
        {'##', 'R', ' ', '##', '##', ' ', '##'},
        {'##', ' ', ' ', ' ', '##', ' ', '##'},
        {'##', '##', ' ', ' ', ' ', ' ', '##'},
        {'##', '##', '##', '##', '##', '##', '##'}
    };
    // 2.计算地图行数和列数
    int row = sizeof(map)/sizeof(map[0]);
    int col = sizeof(map[0])/ sizeof(map[0][0]);
    // 3.输出地图
    printMap(map, row, col);
    // 4.定义变量记录人物位置
    int pRow = 2;
    int pCol = 1;
    // 5.定义变量记录出口的位置
    int endRow = 1;
    int endCol = 6;
    // 6.控制人物行走
    while ('R' != map[endRow][endCol]) {
        // ... ... (rest of the while loop code)
    }
```

---

#### 5.6. 使用注释的好处
- 注释是一个程序员必须要具备的良好习惯
- 帮助开发人员整理实现思路
- 解释说明程序, 提高程序的可读性
    - 初学者编写程序可以养成习惯：先写注释再写代码
    - 将自己的思想通过注释先整理出来，在用代码去体现
    - 因为代码仅仅是思想的一种体现形式而已
- 初学者如何避免程序出现BUG (This was a separate heading in original, but fits well here as a benefit of good commenting/planning)

```
                          _ooOoo_
                         o8888888o
                         88" . "88
                         (| -_- |)
                          O\ = /O
                      ____/`---'\____
                    .   ' \\| |// `.
                     / \\||| : |||// \
                   / _||||| -:- |||||- \
                     | | \\\ - /// | |
                   | \_| ''\---/'' | |
                    \ .-\__ `-` ___/-. /
                 ___`. .' /--.--\ `. . __
              ."" '< `.___\_<|>_/___.' >'"".
             | | : `- \`.;`\ _ /`;.`/ - ` : | |
               \ \ `-. \_ __\ /__ _/ .-` / /
       ======`-.____`-.___\_____/___.-`____.-'======
                          `=---='

       .............................................
              佛祖保佑                   有无BUG
```

```
━━━━━━神兽出没━━━━━━
     　　  ┏┓　　　 ┏┓
      　　┏┛┻━━━━━━┛┻┓
      　　┃　　　     ┃
      　　┃　　　━    ┃
      　　┃　┳┛　  ┗┳ ┃
      　　┃　　　     ┃
      　　┃　　　┻    ┃
      　　┃          ┃
      　　┗━┓　　　 ┏━┛Code is far away from bug with the animal protecting
      　　  ┃　　 　┃    神兽保佑,代码无bug
      　  　┃　　 　┃
      　  　┃　　　 ┗━━━┓
      　  　┃　　　     ┣┓
      　　  ┃　　　  ┏━━┛┛
      　　  ┗┓┓┏━┳┓┏┛
      　　   ┃┫┫ ┃┫┫
      　　   ┗┻┛ ┗┻┛

      ━━━━━━感觉萌萌哒━━━━━━
```

```
        ´´´´´´´´██´´´´´´´
        ´´´´´´´████´´´´´´
        ´´´´´████████´´´´
        ´´`´███▒▒▒▒███´´´´´
        ´´´███▒●▒▒●▒██´´´
        ´´´███▒▒▒▒▒▒██´´´´´
        ´´´███▒▒▒▒██´                      项目：第一个C语言程序
        ´´██████▒▒███´´´´´                 语言： C语言
        ´██████▒▒▒▒███´´                   编辑器： Qt Creator 
        ██████▒▒▒▒▒▒███´´´´                版本控制：git-github
        ´´▓▓▓▓▓▓▓▓▓▓▓▓▓▒´´                 代码风格：江哥style
        ´´▒▒▒▒▓▓▓▓▓▓▓▓▓▒´´´´´              
        ´.▒▒▒´´▓▓▓▓▓▓▓▓▒´´´´´              
        ´.▒▒´´´´▓▓▓▓▓▓▓▒                   
        ..▒▒.´´´´▓▓▓▓▓▓▓▒                   
        ´▒▒▒▒▒▒▒▒▒▒▒▒                      
        ´´´´´´´´´███████´´´´´              
        ´´´´´´´´████████´´´´´´´
        ´´´´´´´█████████´´´´´´
        ´´´´´´██████████´´´´             大部分人都在关注你飞的高不高，却没人在乎你飞的累不累，这就是现实！
        ´´´´´´██████████´´´                     我从不相信梦想，我，只，相，信，自，己！
        ´´´´´´´█████████´´
        ´´´´´´´█████████´´´
        ´´´´´´´´████████´´´´´
        ________▒▒▒▒▒
        _________▒▒▒▒
        _________▒▒▒▒
        ________▒▒_▒▒
        _______▒▒__▒▒
        _____ ▒▒___▒▒
        _____▒▒___▒▒
        ____▒▒____▒▒
        ___▒▒_____▒▒
        ███____ ▒▒
        ████____███
        █ _███_ _█_███
——————————————————————————女神保佑，代码无bug——————————————————————
```

---

#### 5.7. 什么是关键字？
- 关键字,也叫作保留字。是指一些被C语言赋予了特殊含义的单词
- 关键字特征:
    - 全部都是小写
    - 在开发工具中会显示特殊颜色
- 关键字注意点:
    - 因为关键字在C语言中有特殊的含义, 所以不能用作变量名、函数名等
- C语言中一共有32个关键字

|1|2|3|4|5|6|7|8|
|---|---|---|---|---|---|---|---|
|char|short|int|long|float|double|if|else|
|return|do|while|for|switch|case|break|continue|
|default|goto|sizeof|auto|register|static|extern|unsigned|
|signed|typedef|struct|enum|union|void|const|volatile|

> 这些不用专门去记住,用多了就会了。在编译器里都是有特殊颜色的。 我们用到时候会一个一个讲解这个些关键字怎么用,现在浏览下,有个印象就OK了

---

#### 5.8. 关键字分类
![](https://i-blog.csdnimg.cn/blog_migrate/d831f445c5c09fb520f5870bfc1b673a.png)

#### 5.9. 什么是标识符？
- 从字面上理解,就是用来标识某些东西的符号，标识的目的就是为了将这些东西区分开来
- 其实标识符的作用就跟人类的名字差不多，为了区分每个人，就在每个人出生的时候起了个名字
- C语言是由函数构成的，一个C程序中可能会有多个函数，为了区分这些函数，就给每一个函数都起了个名称, 这个名称就是标识符
- 综上所述: 程序员在程序中给函数、变量等起名字就是标识符

---

#### 5.10. 标识符命名规则
- 只能由字母(a~z、 A~Z)、数字、下划线组成
- 不能包含除下划线以外的其它特殊字符串
- 不能以数字开头
- 不能是C语言中的关键字
- 标识符严格区分大小写, test和Test是两个不同的标识符

---

#### 5.11. 标识符命名规范
- 见名知意,能够提高代码的可读性
- 驼峰命名,能够提高代码的可读性
    - 驼峰命名法就是当变量名或函数名是由多个单词连接在一起,构成标识符时,第一个单词以小写字母开始;第二个单词的首字母大写.
    - 例如: myFirstName、myLastName这样的变量名称看上去就像驼峰一样此起彼伏
    - ![](https://i-blog.csdnimg.cn/blog_migrate/300fa54386d06936ca7629541b1c356d.png)
    - ![](https://i-blog.csdnimg.cn/blog_migrate/978c1be0284648fae0a64e394f950bea.png)

#### 5.12. 练习
- 下列哪些是合法的标识符

||||||||
|---|---|---|---|---|---|---|
|fromNo22|from##22|my_Boolean|my-Boolean|2ndObj|GUI|lnj|
|Mike2jack|江哥|_test|test!32|haha(da)tt|jack_rose|jack&rose|

**合法标识符:** fromNo22, my_Boolean, GUI, lnj, Mike2jack, _test, jack_rose
**非法标识符:**
- from##22 (包含特殊字符##)
- my-Boolean (包含特殊字符-)
- 2ndObj (以数字开头)
- 江哥 (包含中文字符，虽然部分现代编译器可能支持，但标准C不允许)
- test!32 (包含特殊字符!)
- haha(da)tt (包含特殊字符())
- jack&rose (包含特殊字符&)

---

# **第二部分：数据与运算**

#### 6. 数据与数据类型
#### 6.1. 什么是数据？
- 生活中无时无刻都在跟数据打交道
    
    - 例如:人的体重、身高、收入、性别等数据等
- 在我们使用计算机的过程中，也会接触到各种各样的数据
    
    - 例如: 文档数据、图片数据、视频数据等

---

#### 6.2. 数据分类
- 静态的数据
    
    - _**静态数据是指一些永久性的数据，一般存储在硬盘中**_。硬盘的存储空间一般都比较大，现在普通计算机的硬盘都有500G左右，因此硬盘中可以存放一些比较大的文件
    - 存储的时长：_**计算机关闭之后再开启，这些数据依旧还在，只要你不主动删掉或者硬盘没坏，这些数据永远都在**_
    - 哪些是静态数据：静态数据一般是以文件的形式存储在硬盘上，比如文档、照片、视频等。
- 动态的数据
    
    - _**动态数据指在程序运行过程中，动态产生的临时数据，一般存储在内存中**_。内存的存储空间一般都比较小，现在普通计算机的内存只有8G左右，因此要谨慎使用内存，不要占用太多的内存空间
    - 存储的时长：_**计算机关闭之后，这些临时数据就会被清除**_
    - 哪些是动态数据：当运行某个程序（软件）时，整个程序就会被加载到内存中，在程序运行过程中，会产生各种各样的临时数据，这些临时数据都是存储在内存中的。当程序停止运行或者计算机被强制关闭时，这个程序产生的所有临时数据都会被清除。
- 既然硬盘的存储空间这么大，为何不把所有的应用程序加载到硬盘中去执行呢？
    
    - 主要***原因就是内存的访问速度比硬盘快N倍***

---

- 静态数据和动态数据的相互转换
    - 也就是从磁盘加载到内存  
        ![](https://i-blog.csdnimg.cn/blog_migrate/ba8f926eab116a6069370cc3fc68564c.png)
- 动态数据和静态数据的相互转换
    - 也就是从内存保存到磁盘  
        ![](https://i-blog.csdnimg.cn/blog_migrate/77417f90f40344b1ac105c8da501bb33.png)
- 数据的计量单位
    - 不管是静态还是动态数据，都是0和1组成的
    - 数据越大，包含的0和1就越多

```
1 B(Byte字节) = 8 bit(位)
// 00000000 就是一个字节
// 111111111 也是一个字节
// 10101010 也是一个字节
// 任意8个0和1的组合都是一个字节
1 KB(KByte) = 1024 B
1 MB = 1024 KB
1 GB = 1024 MB
1 TB = 1024 GB
```

---

#### 6.3. C语言数据类型
- _**作为程序员, 我们最关心的是内存中的动态数据**_,因为我们写的程序就是在内存中运行的
- 程序在运行过程中会产生各种各样的临时数据,_**为了方便数据的运算和操作, C语言对这些数据进行了分类**_, 提供了丰富的数据类型
- C语言中有4大类数据类型:_**基本类型、构造类型、指针类型、空类型**_

![](https://i-blog.csdnimg.cn/blog_migrate/1092a1fdaaa8b342b861a8bf73aec32a.png)

---

#### 6.4. 类型说明符
- 类型说明符基本概念
    - C语言提供了**说明长度**和**说明符号位**的两种类型说明符, 这两种类型说明符一共有4个：
        - short 短整型 (说明长度)
        - long 长整型 (说明长度)
        - signed 有符号型 (说明符号位)
        - unsigned 无符号型 (说明符号位)
- 这些说明符一般都是用来修饰int类型的，所以在使用时可以省略int
- 这些说明符都属于C语言关键字

---

#### 6.5. `short` 和 `long`
- short和long可以提供不同长度的整型数，也就是可以改变整型数的取值范围。
    - 在64bit编译器环境下，int占用4个字节（32bit），取值范围是-2^31 ~ 2^31-1；
    - short占用2个字节（16bit），取值范围是-2^15 ~ 2^15-1；
    - long占用8个字节（64bit），取值范围是-2^63 ~ 2^63-1
- 总结一下：在64位编译器环境下:
    - short占2个字节(16位)
    - int占4个字节(32位)
    - long占8个字节(64位)。
    - 因此，如果使用的整数不是很大的话，可以使用short代替int，这样的话，更节省内存开销。
- 世界上的编译器林林总总，不同编译器环境下，int、short、long的取值范围和占用的长度又是不一样的。比如在16bit编译器环境下，long只占用4个字节。不过幸运的是，ANSI \ ISO制定了以下规则：
    - short跟int至少为16位(2字节)
    - long至少为32位(4字节)
    - **short的长度不能大于int，int的长度不能大于long**
    - **char一定为为8位(1字节)，毕竟char是我们编程能用的最小数据类型**
- 可以连续使用2个long，也就是long long。一般来说，long long的范围是不小于long的，比如在32bit编译器环境下，long long占用8个字节，long占用4个字节。不过在64bit编译器环境下，long long跟long是一样的，都占用8个字节。

```c
##include <stdio.h>

int main()
{
    // char占1个字节, char的取值范围 -2^7~2^7-1 (typically, or 0~2^8-1 if unsigned by default on some systems)
    char num = 129; // Overflow will occur if char is signed and 8-bit.
    printf("size = %zu\n", sizeof(num)); // %zu is for sizeof
    printf("num = %d\n", num); // Behavior of 129 in char depends on signedness

    // short int 占2个字节, short int的取值范围 -2^15~2^15-1
    short int num1 = 32769; // Overflow
    printf("size = %zu\n", sizeof(num1)); 
    printf("num1 = %hd\n", num1); // %hd for short

    // int占4个字节 (typically), int的取值范围 -2^31~2^31-1
    // int num2 = 12345678901; // This value is too large for a typical 32-bit int
    long long num2_large = 12345678901LL; // Use long long for such large numbers
    int num2 = 2000000000; // A value that fits in a 32-bit int
    printf("size = %zu\n", sizeof(num2)); 
    printf("num2 = %d\n", num2);

    // long in 32-bit typically 4 bytes, in 64-bit typically 4 or 8 bytes.
    long int num3 = 12345678901L; // Suffix L for long. Still might overflow 32-bit long.
    printf("size = %zu\n", sizeof(num3)); 
    printf("num3 = %ld\n", num3); // %ld for long

    // long long is typically 8 bytes. -2^63~2^63-1
    long long int num4 = 12345678901LL; // Suffix LL for long long
    printf("size = %zu\n", sizeof(num4)); 
    printf("num4 = %lld\n", num4); // %lld for long long
    
    // 由于short/long/long long一般都是用于修饰int, 所以int可以省略
    short num5 = 123;
    printf("num5 = %hd\n", num5); // Corrected format specifier
    long num6 = 123L;
    printf("num6 = %ld\n", num6); // Corrected format specifier
    long long num7 = 123LL;
    printf("num7 = %lld\n", num7);
    return 0;
}
```

---

#### 6.6. `signed` 和 `unsigned`
- 首先要明确的：signed int等价于signed，unsigned int等价于unsigned
- signed和unsigned的区别就是它们的最高位是否要当做符号位，并不会像short和long那样改变数据的长度，即所占的字节数。
    - signed：表示有符号，也就是说最高位要当做符号位。但是int的最高位本来就是符号位，因此signed和int是一样的，signed等价于signed int，也等价于int。signed的取值范围是-2^31 ~ 2^31 - 1 (for a 32-bit int)
    - unsigned：表示无符号，也就是说最高位并不当做符号位，所以不包括负数。
    - 因此unsigned的取值范围是：0000 0000 0000 0000 0000 0000 0000 0000 ~ 1111 1111 1111 1111 1111 1111 1111 1111，也就是0 ~ 2^32 - 1 (for a 32-bit int)

```c
##include <stdio.h>

int main()
{
    // 1.默认情况下所有类型都是由符号的 (int is signed by default)
    int num1 = 9;
    int num2 = -9;
    int num3 = 0;
    printf("num1 = %d\n", num1);
    printf("num2 = %d\n", num2);
    printf("num3 = %d\n", num3);

    // 2.signed用于明确说明, 当前保存的数据可以是有符号的, 一般情况下很少使用 (as int is already signed)
    signed int num4 = 9;
    signed int num5 = -9;
    signed int num6 = 0;
    printf("num4 = %d\n", num4);
    printf("num5 = %d\n", num5);
    printf("num6 = %d\n", num6);

    // signed也可以省略数据类型, 但是不推荐这样编写 (it implies signed int)
    signed num7 = 9;
    printf("num7 = %d\n", num7);
   

    // 3.unsigned用于明确说明, 当前不能保存有符号的值, 只能保存0和正数
    // 应用场景: 保存银行存款,学生分数等不能是负数的情况
    unsigned int num8 = -9; // This will result in a large positive number due to wrap-around
    unsigned int num9 = 0;
    unsigned int num10 = 9;
    // 注意: 不看怎么存只看怎么取
    printf("num8 = %u\n", num8); // %u for unsigned
    printf("num9 = %u\n", num9);
    printf("num10 = %u\n", num10);
    return 0;
}
```

- 注意点:
    - 修饰符号的说明符可以和修饰长度的说明符混合使用
    - 相同类型的说明符不能混合使用

```c
    signed short int num1 = 666;
    // signed unsigned int num2 = 666; // 报错 (signed and unsigned are mutually exclusive)
```

---

## 7. 常量与变量
#### 7.1. 什么是常量？
- "量"表示数据。常量，则表示一些固定的数据，也就是不能改变的数据
- 就好比现实生活中生男生女一样, 生下来是男孩永远都是男孩, 生下来是女孩就永远都是女孩, 所以性别就是现实生活中常量的一种体现
    - 不要和江哥吹牛X说你是泰国来的, 如果你真的来自泰国, 我只能说你赢了

---

#### 7.2. 常量的类型
- 整型常量
    
    - 十进制整数。例如:666,-120, 0
    - 八进制整数,八进制形式的常量都以0开头。例如:0123,也就是十进制的83;-011,也就是十进 制的-9
    - 十六进制整数,十六进制的常量都是以0x开头。例如:0x123,也就是十进制的291
    - 二进制整数,逢二进一 0b开头。例如: 0b0010,也就是十进制的2 (Note: 0b prefix is a C99/C++14 feature, not in ANSI C/C89)
- 实型常量
    
    - 小数形式
        - 单精度小数:以字母f或字母F结尾。例如:0.0f、1.01f
        - 双精度小数:十进制小数形式。例如:3.14、 6.66
        - 默认就是双精度
        - 可以没有整数位只有小数位。例如: .3、 .6f
    - 指数形式
        - 以幂的形式表示, 以字母e或字母E后跟一个10为底的幂数
            - 上过初中的都应该知道科学计数法吧,指数形式的常量就是科学计数法的另一种表 示,比如123000,_**用科学计数法表示为1.23×10的5次方**_
            - _**用C语言表示就是1.23e5或1.23E5**_
            - 字母e或字母E后面的指数必须为整数
            - 字母e或字母E前后必须要有数字
            - 字母e或字母E前后不能有空格
- 字符常量
    
    - 字符型常量都是用’’(单引号)括起来的。例如:‘a’、‘b’、‘c’
    - 字符常量的单引号中只能有一个字符
    - 特殊情况: 如果是转义字符,单引号中可以有两个字符。例如:’\n’、’\t’
- 字符串常量
    
    - 字符型常量都是用""(双引号)括起来的。例如:“a”、“abc”、“lnj”
    - 系统会自动在字符串常量的末尾加一个字符’\0’作为字符串结束标志
- 自定义常量
    
    - 后期讲解内容, 此处先不用了解 (`##define` or `const`)
- 常量类型练习
    

||||||||
|---|---|---|---|---|---|---|
|123|1.1F|1.1|.3|‘a’|“a”|“李南江”|

**解答:**
- `123`: 整型常量 (十进制)
- `1.1F`: 实型常量 (单精度浮点数)
- `1.1`: 实型常量 (双精度浮点数)
- `.3`: 实型常量 (双精度浮点数, 相当于0.3)
- `‘a’`: 字符常量
- `“a”`: 字符串常量
- `“李南江”`: 字符串常量

---

#### 7.3. 什么是变量？
- "量"表示数据。变量，则表示一些不固定的数据，也就是可以改变的数据
- 就好比现实生活中人的身高、体重一样, 随着年龄的增长会不断发生改变, 所以身高、体重就是现实生活中变量的一种体现
- 就好比现实生活中超市的储物格一样, 同一个格子在不同时期不同人使用,格子中存储的物品是可以变化的。张三使用这个格子的时候里面放的可能是尿不湿, 但是李四使用这个格子的时候里面放的可能是面包

---

#### 7.4. 如何定义变量
- 格式1: 变量类型 变量名称 ;
    - 为什么要定义变量?
        - 任何变量在使用之前，必须先进行定义, 只有定义了变量才会分配存储空间, 才有空间存储数据
    - 为什么要限定类型?
        - 用来约束变量所存放数据的类型。一旦给变量指明了类型，那么这个变量就只能存储这种类型的数据
        - 内存空间极其有限,不同类型的变量占用不同大小的存储空间
    - 为什么要指定变量名称?
        - 存储数据的空间对于我们没有任何意义, 我们需要的是空间中存储的值
        - 只有有了名称, 我们才能获取到空间中的值

```c
int a;
float b;
char ch;
```

- 格式2:变量类型 变量名称,变量名称;
    - 连续定义, 多个变量之间用逗号(,)号隔开

```c
int a,b,c;
```

- 变量名的命名的规范
    - 变量名属于标识符,所以必须严格遵守标识符的命名原则

---

#### 7.5. 如何使用变量？
- 可以利用=号往变量里面存储数据
    - 在C语言中,利用=号往变量里面存储数据, 我们称之为给变量赋值

```c
int value;
value = 998; // 赋值
```

- 注意:
    - 这里的=号，并不是数学中的“相等”，而是C语言中的***赋值运算符***，作用是将右边的整型常量998赋值给左边的整型变量value
    - 赋值的时候,= 号的左侧必须是变量 (10=b,错误)
    - 为了方便阅读代码, 习惯在 = 的两侧 各加上一个 空格

---

#### 7.6. 变量的初始化
- C语言中, 变量的第一次赋值，我们称为“初始化”
- 初始化的两种形式
    - 先定义,后初始化
    - `int value; value = 998; // 初始化`
    - 定义时同时初始化
    - `int a = 10; int b = 4, c = 2;`
    - 其它表现形式(不推荐)

```c
int a, b = 10; //部分初始化
int c, d, e;
c = d = e =0;
```

- 不初始化里面存储什么?
    - 随机数
    - 上次程序分配的存储空间,存数一些 内容,“垃圾”
    - 系统正在用的一些数据

---

#### 7.7. 如何修改变量值？
- 多次赋值即可
    - 每次赋值都会覆盖原来的值

```c
int i = 10;
i = 20; // 修改变量的值
```

---

#### 7.8. 变量之间的值传递
- 可以将一个变量存储的值赋值给另一个变量

```c
 int a = 10;
 int b = a; // 相当于把a中存储的10拷贝了一份给b
```

---

#### 7.9. 如何查看变量的值？
- 使用printf输出一个或多个变量的值

```c
int a = 10, c = 11;
printf("a=%d, c=%d", a, c);
```

- 输出其它类型变量的值

```c
double height = 1.75;
char blood = 'A';
printf("height=%.2f, 血型是%c", height,  blood);
```

---

## 8. 运算符与表达式
#### 8.1. 基本概念
- 和数学中的运算符一样, C语言中的运算符是告诉程序执行特定算术或逻辑操作的符号
    
    - 例如告诉程序, 某两个数相加, 相减,相乘等  
        ![](https://i-blog.csdnimg.cn/blog_migrate/deae60860c5225a617aed04f38216440.png)
- 什么是表达式
    
    - 表达式就是利用运算符链接在一起的有意义,有结果的语句;
    - 例如: a + b; 就是一个算数表达式, 它的意义是将两个数相加, 两个数相加的结果就是表达式的结果
    - 注意: 表达式一定要有结果

---

#### 8.2. 运算符分类
- 按照功能划分:
    - 算术运算符
    - 赋值运算符
    - 关系运算符
    - 逻辑运算符
    - 位运算符
- 按照参与运算的操作数个数划分:
    - 单目运算
        - 只有一个操作数 如 : i++;
    - 双目运算
        - 有两个操作数 如 : a + b;
    - 三目运算
        - C语言中唯一的一个,也称为问号表达式 如: a>b ? 1 : 0;

---

#### 8.3. 算数运算符
|优先级|名称|符号|说明|
|---|---|---|---|
|3|乘法运算符|*|双目运算符,具有左结合性|
|3|除法运算符|/|双目运算符,具有左结合性|
|3|求余运算符 (模运算符)|%|双目运算符,具有左结合性|
|4|加法运算符|+|双目运算符,具有左结合性|
|4|减法运算符|-|双目运算符,具有左结合性|

- 注意事项
    - 如果参与运算的两个操作数皆为整数, 那么结果也为整数
    - 如果参与运算的两个操作数其中一个是浮点数, 那么结果一定是浮点数
    - 求余运算符, 本质上就是数学的商和余"中的余数
    - 求余运算符, 参与运算的两个操作数必须都是整数, 不能包含浮点数
    - 求余运算符, 被除数小于除数, 那么结果就是被除数
    - 求余运算符, 运算结果的正负性取决于被除数,跟除数无关, 被除数是正数结果就是正数,被除数是负数结果就是负数
    - 求余运算符, 被除数为0, 结果为0
    - 求余运算符, 除数为0, 没有意义(不要这样写)

```c
##include <stdio.h>
int main(){
    int a = 10;
    int b = 5;
    // 加法
    int result = a + b;
    printf("%d\n", result); // 15
    // 减法
    result = a - b;
    printf("%d\n", result); // 5
    // 乘法
    result = a * b;
    printf("%d\n", result); // 50
    // 除法
    result = a / b;
    printf("%d\n", result); // 2
    
    // 算术运算符的结合性和优先级
    // 结合性: 左结合性, 从左至右
    int c = 50;
    result = a + b + c; // 15 + c;  65;
    printf("%d\n", result);
    
    // 优先级: * / % 大于 + -
    result = a + b * c; // a + 250; 260;
    printf("%d\n", result);
    return 0; // Added return
}
```

```c
##include <stdio.h>
int main(){
    // 整数除以整数, 结果还是整数
    printf("%d\n", 10 / 3); // 3

    // 参与运算的任何一个数是小数, 结果就是小数
    printf("%f\n", 10 / 3.0); // 3.333333
    return 0; // Added return
}
```

```c
##include <stdio.h>
int main(){
    // 10 / 3 商等于3, 余1
    int result = 10 % 3;
    printf("%d\n", result); // 1

    // 左边小于右边, 那么结果就是左边
    result = 2 % 10;
    printf("%d\n", result); // 2

    // 被除数是正数结果就是正数,被除数是负数结果就是负数
    result = 10 % 3;
    printf("%d\n", result); // 1
    result = -10 % 3;
    printf("%d\n", result); // -1
    result = 10 % -3;
    printf("%d\n", result); // 1
    return 0; // Added return
}
```

---

#### 8.4. 赋值运算符
|优先级|名称|符号|说明|
|---|---|---|---|
|14|赋值运算符|=|双目运算符,具有右结合性|
|14|除后赋值运算符|/=|双目运算符,具有右结合性|
|14|乘后赋值运算符 (模运算符)|*=|双目运算符,具有右结合性|
|14|取模后赋值运算符|%=|双目运算符,具有右结合性|
|14|加后赋值运算符|+=|双目运算符,具有右结合性|
|14|减后赋值运算符|-=|双目运算符,具有右结合性|

- 简单赋值运算符

```c
##include <stdio.h>
int main(){
    // 简单的赋值运算符 =
    // 会将=右边的值赋值给左边
    int a = 10;
    printf("a = %d\n", a); // 10
    return 0; // Added return
}
```

- 复合赋值运算符

```c
##include <stdio.h>
int main(){
     // 复合赋值运算符 += -= *= /= %=
     // 将变量中的值取出之后进行对应的操作, 操作完毕之后再重新赋值给变量
     int num1 = 10;
     // num1 = num1 + 1; num1 = 10 + 1; num1 = 11;
     num1 += 1;
     printf("num1 = %d\n", num1); // 11
     int num2 = 10;
     // num2 = num2 - 1; num2 = 10 - 1; num2 = 9;
     num2 -= 1;
     printf("num2 = %d\n", num2); // 9
     int num3 = 10;
     // num3 = num3 * 2; num3 = 10 * 2; num3 = 20;
     num3 *= 2;
     printf("num3 = %d\n", num3); // 20
     int num4 = 10;
     // num4 = num4 / 2; num4 = 10 / 2; num4 = 5;
     num4 /= 2;
     printf("num4 = %d\n", num4); // 5
     int num5 = 10;
     // num5 = num5 % 3; num5 = 10 % 3; num5 = 1;
     num5 %= 3;
     printf("num5 = %d\n", num5); // 1
     return 0; // Added return
}
```

- 结合性和优先级

```c
##include <stdio.h>
int main(){
    int number = 10;
    // 赋值运算符优先级是14, 普通运算符优先级是3和4, 所以先计算普通运算符
    // 普通运算符中乘法优先级是3, 加法是4, 所以先计算乘法
    // number += 1 + 25; number += 26; number = number + 26; number = 36;
    number += 1 + 5 * 5;
    printf("number = %d\n", number); // 36
    return 0; // Added return
}
```

---

#### 8.5. 自增自减运算符
- 在程序设计中,经常遇到“i=i+1”和“i=i-1”这两种极为常用的操作。
- C语言为这种操作提供了两个更为简洁的运算符,即++和–

|优先级|名称|符号|说明|
|---|---|---|---|
|2|自增运算符(在后)|i++|单目运算符,具有左结合性|
|2|自增运算符(在前)|++i|单目运算符,具有右结合性|
|2|自减运算符(在后)|i–|单目运算符,具有左结合性|
|2|自减运算符(在前)|–i|单目运算符,具有右结合性|

---

- 自增
    - 如果只有***单个***变量, 无论++写在前面还是后面都会对变量做+1操作

```c
##include <stdio.h>
int main(){
    int number = 10;
    number++;
    printf("number = %d\n", number); // 11
    ++number;
    printf("number = %d\n", number); // 12
    return 0; // Added return
}
```

- 如果出现在一个表达式中, 那么++写在前面和后面就会有所区别
    - 前缀表达式:++x, --x;其中x表示变量名,先完成变量的自增自减1运算,再用x的值作为表达式的值;即“先变后用”,也就是变量的值先变,再用变量的值参与运算
    - 后缀表达式:x++, x–;先用x的当前值作为表达式的值,再进行自增自减1运算。即“先用后变”,也就是先用变量的值参与运算,变量的值再进行自增自减变化

```c
##include <stdio.h>
int main(){
    int number = 10;
    // ++在后, 先参与表达式运算, 再自增
    // 表达式运算时为: 3 + 10;
    int result = 3 + number++;
    printf("result = %d\n", result); // 13
    printf("number = %d\n", number); // 11
    return 0; // Added return
}
```

```c
##include <stdio.h>
int main(){
    int number = 10;
    // ++在前, 先自增, 再参与表达式运算
    // 表达式运算时为: 3 + 11;
    int result = 3 + ++number;
    printf("result = %d\n", result); // 14
    printf("number = %d\n", number); // 11
    return 0; // Added return
}
```

- 自减

```c
##include <stdio.h>
int main(){
    int number = 10;
    // --在后, 先参与表达式运算, 再自减
    // 表达式运算时为: 10 + 3;
    int result = number-- + 3;
    printf("result = %d\n", result); // 13
    printf("number = %d\n", number); // 9
    return 0; // Added return
}
```

```c
##include <stdio.h>
int main(){
    int number = 10;
    // --在前, 先自减, 再参与表达式运算
    // 表达式运算时为: 9 + 3;
    int result = --number + 3;
    printf("result = %d\n", result); // 12
    printf("number = %d\n", number); // 9
    return 0; // Added return
}
```

- 注意点:
    - 自增、自减运算只能用于单个变量,只要是标准类型的变量,不管是整型、实型,还是字符型变量等,但不能用于表达式或常量
        - 错误用法: `++(a+b); 5++;`
    - 企业开发中尽量让++ – 单独出现, 尽量不要和其它运算符混合在一起

```c
int i = 10;
int b = i++; // 不推荐
// 或者
// int b = ++i; // 不推荐
// 或者
// int a = 10;
// int b = ++a + a++;  // 不推荐
```

- 请用如下代码替代

```c
int i = 10;
int b = i; // 推荐
i++;
// 或者;
// i++;
// int b = i; // 推荐
// 或者
// int a = 10;
// ++a;
// int b = a + a; // 推荐
// a++;
```

- C语言标准没有明确的规定，`同一个表达式中同一个变量自增或自减后如何运算`, 不同编译器得到结果也不同, 在企业开发中千万不要这样写

```c
    ##include <stdio.h> // Added for printf
    int main() { // Added main wrapper
        int a = 1;
        // 下列代码利用Qt运行时6, 利用Xcode运行是5
        // 但是无论如何, 最终a的值都是3
       //  在C语言中这种代码没有意义, 不用深究也不要这样写
       // 特点: 参与运算的是同一个变量, 参与运算时都做了自增自减操作, 并且在同一个表达式中
        int b = ++a + ++a; // Behavior is undefined
        printf("b = %d\n", b); 
        printf("a = %d\n", a); // To see final value of a
        return 0; // Added return
    }
```

---

#### 8.6. `sizeof` 运算符
- sizeof可以用来计算一个变量或常量、数据类型所占的内存字节数
    
    - 标准格式: sizeof(常量 or 变量);
- sizeof的几种形式
    
    - sizeof( 变量\常量 );
        - `sizeof(10);`
        - `char c = 'a'; sizeof(c);`
    - sizeof 变量\常量;
        - `sizeof 10;`
        - `char c = 'a'; sizeof c;`
    - sizeof( 数据类型);
        - `sizeof(float);`
        - `如果是数据类型不能省略括号`
- sizeof面试题:
    
    - sizeof()和+=、*=一样是一个复合运算符, 由sizeof和()两个部分组成, 但是代表的是一个整体
    - 所以sizeof不是一个函数, 是一个运算符, 该运算符的优先级是2

```c
##include <stdio.h>
int main(){
    int a = 10;
    double b = 3.14;
    // 由于sizeof的优先级比+号高, 所以会先计算sizeof(a);
    // a是int类型, 所以占4个字节得到结果4
    // 然后再利用计算结果和b相加, 4 + 3.14 = 7.14
    double res = sizeof a + b; // Equivalent to (sizeof a) + b
    printf("res = %lf\n", res); // 7.14
    return 0; // Added return
}
```

---

#### 8.7. 逗号运算符
- 在C语言中逗号“,”也是一种运算符,称为逗号运算符。 其功能是把多个表达式连接起来组成一个表达式,称为逗号表达式
- 逗号运算符会从左至右依次取出每个表达式的值, 最后整个逗号表达式的值等于最后一个表达式的值
- 格式: `表达式1，表达式2，… …，表达式n;`
    - 例如: `int result = (a+1,b=3*4);` // result will be assigned the value of (b=3*4), which is 12.

```c
##include <stdio.h>
int main(){
    int a = 10, b = 20, c;
    // ()优先级高于逗号运算符和赋值运算符, 所以先计算()中的内容
    // c = (11, 21);
    // ()中是一个逗号表达式, 结果是最后一个表达式的值, 所以计算结果为21
    // 将逗号表达式的结果赋值给c, 所以c的结果是21
    c = (a + 1, b + 1);
    printf("c = %d\n", c); // 21
    return 0; // Added return
}
```

---

#### 8.8. 关系运算符
- 为什么要学习关系运算符
    - 默认情况下，我们在程序中写的每一句正确代码都会被执行。但很多时候，我们想在某个条件成立的情况下才执行某一段代码
    - 这种情况的话可以使用条件语句来完成，但是学习条件语句之前，我们先来看一些更基础的知识：如何判断一个条件是否成立

---

- C语言中的真假性
    - 在C语言中，条件成立称为“真”，条件不成立称为“假”，因此，判断条件是否成立，就是判断条件的“真假”
    - 怎么判断真假呢？C语言规定，任何数值都有真假性，任何非0值都为“真”，只有0才为“假”。也就是说，108、-18、4.5、-10.5等都是“真”，0则是“假”  
        ![](https://i-blog.csdnimg.cn/blog_migrate/ae31aa763d97aee833ef5cc1c34d97d1.png)

---

- 关系运算符的运算结果只有2种：如果条件成立，结果就为1，也就是“真”；如果条件不成立，结果就为0，也就是“假”

|优先级|名称|符号|说明|
|---|---|---|---|
|6|大于运算符|>|双目运算符,具有左结合性|
|6|小于运算符|<|双目运算符,具有左结合性|
|6|大于等于运算符|>=|双目运算符,具有左结合性|
|6|小于等于运算符|<=|双目运算符,具有左结合性|
|7|等于运算符|==|双目运算符,具有左结合性|
|7|不等于运算符|!=|双目运算符,具有左结合性|

```c
##include <stdio.h>
int main(){
    int result = 10 > 5;
    printf("result = %d\n", result); // 1
    result = 5 < 10;
    printf("result = %d\n", result); // 1
    result = 5 > 10;
    printf("result = %d\n", result); // 0
    result = 10 >= 10;
    printf("result = %d\n", result); // 1
    result = 10 <= 10;
    printf("result = %d\n", result); // 1
    result = 10 == 10;
    printf("result = %d\d\n", result); // 1
    result = 10 != 9;
    printf("result = %d\n", result); // 1
    return 0; // Added return
}
```

- 优先级和结合性

```c
##include <stdio.h>
int main(){
    // == 优先级 小于 >, 所以先计算>
    // result = 10 == 1; result = 0;
    int result = 10 == (5 > 3); // Use parentheses for clarity
    printf("result = %d\n", result); // 0
    return 0; // Added return
}
```

```c
##include <stdio.h>
int main(){
    // == 和 != 优先级一样, 所以按照结合性
    // 关系运算符是左结合性, 所以从左至右计算
    // result = (10 == 5) != 3; result = 0 != 3; result = 1;
    int result = (10 == 5) != 3; // Use parentheses for clarity
    printf("result = %d\n", result); // 1
    return 0; // Added return
}
```

- 练习: 计算result的结果

```c
// int result1 = 3 > 4 + 7;
// int result2 = (3>4) + 7;
// int result3 = 5 != 4 + 2 * 7 > 3 == 10;
```

**解答:**
- `result1 = 3 > 4 + 7`
  - `4 + 7` is `11`
  - `3 > 11` is `0`
  - `result1` is `0`
- `result2 = (3>4) + 7`
  - `(3>4)` is `0`
  - `0 + 7` is `7`
  - `result2` is `7`
- `result3 = 5 != 4 + 2 * 7 > 3 == 10` (This is complex and relies heavily on precedence and associativity, best to use parentheses)
  - `2 * 7` is `14`
  - `4 + 14` is `18`
  - Expression becomes: `5 != 18 > 3 == 10`
  - `18 > 3` is `1` (true)
  - Expression becomes: `5 != 1 == 10`
  - `5 != 1` is `1` (true) (assuming left-to-right for `!=` and `==` which have same precedence after `>`)
  - Expression becomes: `1 == 10`
  - `1 == 10` is `0` (false)
  - `result3` is `0`
  
  To be safe and clear: `result3 = (5 != (4 + (2 * 7))) > (3 == 10)` - this interpretation might differ.
  Let's re-evaluate strictly by C precedence:
  `*` (higher) -> `+` -> `>` -> `!=` and `==` (left to right)
  `5 != 4 + (2 * 7) > 3 == 10`
  `5 != 4 + 14 > 3 == 10`
  `5 != 18 > 3 == 10`
  `18 > 3` is `1`
  `5 != 1 == 10`
  `5 != 1` is `1` (leftmost of `!=` and `==`)
  `1 == 10` is `0`
  So, `result3` is `0`.

- 注意点:
    - 无论是float还是double都有精度问题, 所以一定要避免利用==判断浮点数是否相等

```c
##include <stdio.h>
##include <math.h> // For fabs for float comparison

int main(){
    float a = 0.1f * 10.0f; // a should be 1.0
    float b = 1.0f;
    // int result = a == b; // This can be unreliable
    // Better way to compare floats:
    int result = (fabs(a - b) < 0.000001); // Check if difference is very small
    printf("a = %f, b = %f\n", a, b);
    printf("result = %d\n", result); // Should be 1 (true) with proper comparison
    return 0; // Added return
}
```

---

#### 8.9. 逻辑运算符
|优先级|名称|符号|说明|
|---|---|---|---|
|2|逻辑非运算符|!|单目运算符,具有右结合性|
|11|逻辑与运算符|&&|双目运算符,具有左结合性|
|12|逻辑或运算符|`||`|双目运算符,具有左结合性| <!-- Corrected the or symbol -->

- 逻辑非
    - 格式: `! 条件A;`
    - 运算结果: 真变假,假变真
    - 运算过程:
        - 先判断条件A是否成立，如果添加A成立, 那么结果就为0，即“假”；
        - 如果条件A不成立，结果就为1，即“真”
    - 使用注意:
        - 可以多次连续使用逻辑非运算符
        - !!!0;相当于(!(!(!0)));最终结果为1

```c
##include <stdio.h>
int main(){
    // ()优先级高, 先计算()里面的内容
    // 10==10为真, 所以result = !(1);
    // !代表真变假, 假变真,所以结果是假0
    int result = !(10 == 10);
    printf("result = %d\n", result); // 0
    return 0; // Added return
}
```

---

- 逻辑与
    - 格式: `条件A && 条件B;`
    - 运算结果:一假则假
    - 运算过程:
        - 总是先判断"条件A"是否成立
        - 如果"条件A"成立，接着再判断"条件B"是否成立, 如果"条件B"也成立，结果就为1，即“真”
        - 如果"条件A"成立，"条件B"不成立，结果就为0，即“假”
        - 如果"条件A"不成立，不会再去判断"条件B"是否成立, 因为逻辑与只要一个不为真结果都不为真 (short-circuit evaluation)
    - 使用注意:
        - "条件A"为假, "条件B"不会被执行

```c
##include <stdio.h>
int main(){
    int result;
    //               真     &&    真
    result = (10 == 10) && (5 != 1);
    printf("result = %d\n", result); // 1
    //          假     &&    真
    result = (10 == 9) && (5 != 1);
    printf("result = %d\n", result); // 0
    //          真     &&    假
    result = (10 == 10) && (5 != 5);
    printf("result = %d\n", result); // 0
    //          假     &&    假
    result = (10 == 9) && (5 != 5);
    printf("result = %d\n", result); // 0
    return 0; // Added return
}
```

```c
##include <stdio.h>
int main(){
    int a = 10;
    int b = 20;
    // 逻辑与, 前面为假, 不会继续执行后面
    int result = (a == 9) && (++b); // ++b will not be evaluated
    printf("result = %d\n", result); // 0
    printf("b = %d\n", b); // 20
    return 0; // Added return
}
```

---

- 逻辑或
    - 格式: `条件A || 条件B;`
    - 运算结果:一真则真
    - 运算过程:
        - 总是先判断"条件A"是否成立
        - 如果"条件A"不成立，接着再判断"条件B"是否成立, 如果"条件B"成立，结果就为1，即“真”
        - 如果"条件A"不成立，"条件B"也不成立成立, 结果就为0，即“假”
        - 如果"条件A"成立, 不会再去判断"条件B"是否成立, 因为逻辑或只要一个为真结果都为真 (short-circuit evaluation)
    - 使用注意:
        - "条件A"为真, "条件B"不会被执行

```c
##include <stdio.h>
int main(){
    int result;
    //               真     ||    真
    result = (10 == 10) || (5 != 1);
    printf("result = %d\n", result); // 1
    //          假     ||    真
    result = (10 == 9) || (5 != 1);
    printf("result = %d\n", result); // 1
    //          真     ||    假
    result = (10 == 10) || (5 != 5);
    printf("result = %d\n", result); // 1
    //          假     ||    假
    result = (10 == 9) || (5 != 5);
    printf("result = %d\n", result); // 0
    return 0; // Added return
}
```

```c
##include <stdio.h>
int main(){
    int a = 10;
    int b = 20;
    // 逻辑或, 前面为真, 不会继续执行后面
    int result = (a == 10) || (++b); // ++b will not be evaluated
    printf("result = %d\n", result); // 1
    printf("b = %d\n", b); // 20
    return 0; // Added return
}
```

- 练习: 计算result的结果

```c
// int result = 3>5 || 2<4 && 6<1;
```
**解答:**
`&&` has higher precedence than `||`.
1. `3 > 5` is `0` (false)
2. `2 < 4` is `1` (true)
3. `6 < 1` is `0` (false)
4. Expression becomes: `0 || 1 && 0`
5. `1 && 0` is `0` (false)
6. Expression becomes: `0 || 0`
7. `0 || 0` is `0` (false)
So, `result` is `0`.

---

#### 8.10. 三目运算符
- 三目运算符，它需要3个数据或表达式构成条件表达式
    
- 格式: `表达式1？表达式2(结果A)：表达式3(结果B)`
    
    - 示例: `考试及格 ? 及格 : 不及格;`  
        ![](https://i-blog.csdnimg.cn/blog_migrate/14b0d1f2b7c2bd9ef735ef315ca89a1e.png)
- 求值规则:
    
    - 如果"表达式1"为真，三目运算符的运算结果为"表达式2"的值(结果A)，否则为"表达式3"的值(结果B)

```c
// 示例:
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int a = 10;
    int b = 20;
    int max = (a > b) ? a : b;
    printf("max = %d", max);
    // 输出结果: 20
    return 0; // Added return
}
/*
等价于:
    int a = 10;
    int b = 20;
    int max = 0;
    if(a>b){
      max=a;
    }else {
       max=b;
    }
    printf("max = %d", max);
*/
```

- 注意点
    - 条件运算符的运算优先级低于关系运算符和算术运算符,但高于赋值符
    - 条件运算符?和:是一个整体,不能分开使用

```c
##include <stdio.h>
int main(){
    int a = 10;
    int b = 5;
    // 先计算 a > b
    // 然后再根据计算结果判定返回a还是b
    // 相当于int max= (a>b) ? a : b;
    int max= a>b ? a : b;
    printf("max = %d\n", max); // 10
    return 0; // Added return
}
```

```c
##include <stdio.h>
int main(){
    int a = 10;
    int b = 5;
    int c = 20;
    int d = 10;
    // 结合性是从右至左, 所以会先计算:后面的内容
    // int res = a > b ? a : (c > d ? c : d); // Parentheses for clarity
    // int res = a > b ? a : (20 > 10 ? 20 : 10);
    // int res = a > b ? a : (20);
    // 然后再计算最终的结果
    // int res = 10 > 5 ? 10 : (20);
    // int res = 10;
    int res = a > b ? a : c > d ? c : d;
    printf("res = %d\n", res); // 10
    return 0; // Added return
}
```

---

#### 8.11. 运算符的优先级和结合性
- 早在小学的数学课本中,我们就学习过"从左往右,先乘除后加减,有括号的先算括号里面的", 这句话就蕴含了优先级和结合性的问题
- C语言中,运算符的运算优先级共分为15 级。1 级最高,15 级最低
    - 在C语言表达式中,不同优先级的运算符, 运算次序按照由高到低执行
    - 在C语言表达式中,相同优先级的运算符, 运算次序按照结合性规定的方向执行  
        ![](https://i-blog.csdnimg.cn/blog_migrate/7df63b9c2ce20a4059094653ed17b634.png)![](https://i-blog.csdnimg.cn/blog_migrate/777a6b87cde2f2200e0b7afefaa90b60.png)

---

#### 8.12. 类型转换
|强制类型转换(显示转换)|自动类型转换(隐式转换)|
|---|---|
|(需要转换的类型)(表达式)|1.算数转换 2.赋值转换|

- 强制类型转换(显示转换)

```c
// 将double转换为int
int a = (int)10.5; // a will be 10
```

- 算数转换 (Implicit type promotion)
    - 系统会自动对占用内存较少的类型做一个“自动类型提升”的操作, 先将其转换为当前算数表达式中占用内存高的类型, 然后再参与运算

```c
// 当前表达式用1.0占用8个字节 (double), 2占用4个字节 (int)
// 所以会先将整数类型2转换为double类型之后再计算
double b = 1.0 / 2; // 2 is promoted to 2.0, result is 0.5
```

- 赋值转换 (Implicit type conversion on assignment)

```c
// 赋值时左边是什么类型,就会自动将右边转换为什么类型再保存
int a = 10.6; // 10.6 is truncated to 10 and stored in a
```

- 注意点:
    - 参与计算的是什么类型, 结果就是什么类型 (This is not entirely accurate, promotion rules apply)

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    // 结果为0, 因为参与运算的都是整型 (integer division)
    double a = (double)(1 / 2); // 1/2 is 0, then (double)0 is 0.0
    printf("a = %lf\n", a); // 0.000000

    // 结果为0.5, 因为1被强制转换为了double类型, 2也会被自动提升为double类型
    double b = (double)1 / 2; // (double)1 is 1.0, 1.0 / 2 promotes 2 to 2.0, result is 0.5
    printf("b = %lf\n", b); // 0.500000
    return 0; // Added return
}
```

- 类型转换并不会影响到原有变量的值

```c
##include <stdio.h>
int main(){
    double d = 3.14;
    int num = (int)d;
    printf("num = %d\n", num); // 3
    printf("d = %lf\n", d); // 3.140000
    return 0; // Added return
}
```

---

#### 8.13. 阶段练习
- 从键盘输入一个整数, 判断这个数是否是100到200之间的数
- 表达式 `6 == 6 == 6` 的值是多少？
- 用户从键盘上输入三个整数,找出最大值,然后输入最大值
- 用两种方式交换两个变量的保存的值

```c
// 交换前
// int a = 10; int b = 20;
// 交换后
// int a = 20; int b = 10;
```
**解答:**
1.  **判断100到200之间:**
    ```c
    ##include <stdio.h>
    int main() {
        int num;
        printf("请输入一个整数: ");
        scanf("%d", &num);
        if (num >= 100 && num <= 200) {
            printf("%d 在100到200之间。\n", num);
        } else {
            printf("%d 不在100到200之间。\n", num);
        }
        return 0;
    }
    ```
2.  **表达式 `6 == 6 == 6` 的值:**
    - `6 == 6` is `1` (true)
    - Expression becomes `1 == 6`
    - `1 == 6` is `0` (false)
    - 所以表达式的值是 `0`.
3.  **三个整数找最大值:**
    ```c
    ##include <stdio.h>
    int main() {
        int n1, n2, n3, max;
        printf("请输入三个整数 (用空格分隔): ");
        scanf("%d %d %d", &n1, &n2, &n3);
        max = n1;
        if (n2 > max) {
            max = n2;
        }
        if (n3 > max) {
            max = n3;
        }
        printf("最大值是: %d\n", max);
        return 0;
    }
    ```
4.  **交换两个变量的值:**
    *   **方式一：使用临时变量**
        ```c
        ##include <stdio.h>
        int main() {
            int a = 10;
            int b = 20;
            printf("交换前: a = %d, b = %d\n", a, b);
            int temp = a;
            a = b;
            b = temp;
            printf("交换后: a = %d, b = %d\n", a, b);
            return 0;
        }
        ```
    *   **方式二：不使用临时变量 (算术运算)**
        ```c
        ##include <stdio.h>
        int main() {
            int a = 10;
            int b = 20;
            printf("交换前: a = %d, b = %d\n", a, b);
            a = a + b; // a = 30
            b = a - b; // b = 30 - 20 = 10
            a = a - b; // a = 30 - 10 = 20
            printf("交换后: a = %d, b = %d\n", a, b);
            return 0;
        }
        ```
    *   **方式三：不使用临时变量 (位运算 - 仅限整数)**
        ```c
        ##include <stdio.h>
        int main() {
            int a = 10; // 1010
            int b = 20; // 10100
            printf("交换前: a = %d, b = %d\n", a, b);
            a = a ^ b;
            b = a ^ b; 
            a = a ^ b;
            printf("交换后: a = %d, b = %d\n", a, b);
            return 0;
        }
        ```

---

## 9. 输入输出 (I/O)
#### 9.1. `printf` 函数
![](https://i-blog.csdnimg.cn/blog_migrate/a228100a4abf0b300fd95fe9734f1a53.png)

- printf函数称之为格式输出函数,方法名称的最后一个字母f表示format。其功能是按照用户指定的格式,把指定的数据输出到屏幕上
- printf函数的调用格式为:
    - `printf("格式控制字符串",输出项列表 );`
    - 例如:`printf("a = %d, b = %d",a, b);`  
        ![](https://i-blog.csdnimg.cn/blog_migrate/5f8d0ebed3085f67624df9aa047f8ee0.png)
    - 非格式字符串原样输出, 格式控制字符串会被输出项列表中的数据替换
    - 注意: 格式控制字符串和输出项在数量和类型上***必须一一对应***

---

- 格式控制字符串
    - 形式: `%[标志][输出宽度][.精度][长度]类型`

---

- 类型
    - 格式: `printf("a = %类型", a);`
    - 类型字符串用以表示输出数据的类型, 其格式符和意义如下所示

|类型|含义|
|---|---|
|d|有符号10进制整型|
|i|有符号10进制整型|
|u|无符号10进制整型|
|o|无符号8进制整型|
|x|无符号16进制整型 (小写字母 a-f)|
|X|无符号16进制整型 (大写字母 A-F)|
|f|单、双精度浮点数(默认保留6位小数)|
|e / E|以指数形式输出单、双精度浮点数|
|g / G|以最短输出宽度,输出单、双精度浮点数 (根据数值大小自动选择 %f 或 %e/%E)|
|c|字符|
|s|字符串|
|p|地址 (指针的值)|

```c
##include <stdio.h>
int main(){
    int a = 10;
    int b = -10;
    float c_float = 6.6f; // Renamed to avoid conflict with char f
    double d_double = 3.1415926; // Renamed
    double e_double = 10.10; // Renamed
    char f_char = 'a'; // Renamed

    // 有符号整数(可以输出负数)
    printf("a = %d\n", a); // 10
    printf("a = %i\n", a); // 10

    // 无符号整数(不可以输出负数 - if b is printed with %u, it will be a large positive number)
    printf("a = %u\n", a); // 10
    printf("b = %u\n", b); // 4294967286 (on a 32-bit system, due to 2's complement representation)

    // 无符号八进制整数(不可以输出负数)
    printf("a = %o\n", a); // 12
    printf("b = %o\n", b); // 37777777766 (on a 32-bit system)

    // 无符号十六进制整数(不可以输出负数)
    printf("a = %x\n", a); // a
    printf("b = %x\n", b); // fffffff6 (on a 32-bit system)

    // 无符号十六进制整数(大写)
    printf("a = %X\n", a); // A
    printf("b = %X\n", b); // FFFFFFF6 (on a 32-bit system)

    // 单、双精度浮点数(默认保留6位小数)
    printf("c_float = %f\n", c_float); // 6.600000
    printf("d_double = %f\n", d_double); // 3.141593 (Note: printf promotes float to double, so %f works for both)
                                       // For explicit double, %lf can be used with scanf, but with printf %f is fine.

    // 以指数形式输出单、双精度浮点数
    printf("e_double = %e\n", e_double); // 1.010000e+01
    printf("e_double = %E\n", e_double); // 1.010000E+01
    
    // 以最短输出宽度,输出单、双精度浮点数
    printf("e_double = %g\n", e_double); // 10.1
    printf("e_double = %G\n", e_double); // 10.1
    
    // 输出字符
    printf("f_char = %c\n", f_char); // a
    return 0; // Added return
}
```

---

- 宽度
    - 格式: `printf("a = %[宽度]类型", a);`
    - 用十进制整数来指定输出的宽度, 如果实际位数多于指定宽度,则按照实际位数输出, 如果实际位数少于指定宽度则以空格补位 (默认右对齐)

```c
##include <stdio.h>
int main(){
    // 实际位数小于指定宽度
    int a = 1;
    printf("a =|%d|\n", a); // |1|
    printf("a =|%5d|\n", a); // |    1| (padded with spaces on the left)
    // 实际位数大于指定宽度
    int b = 1234567;
    printf("b =|%d|\n", b); // |1234567|
    printf("b =|%5d|\n", b); // |1234567| (width is ignored as it's smaller)
    return 0; // Added return
}
```

---

- 标志
    - 格式: `printf("a = %[标志][宽度]类型", a);`

|标志|含义|
|---|---|
|-|左对齐, 默认右对齐|
|+|当输出值为正数时,在输出值前面加上一个+号, 默认不显示|
|0|右对齐时, 用0填充宽度.(默认用空格填充). 如果有'-'标志，'0'标志被忽略。对于整数类型，如果有精度，'0'标志被忽略。|
|空格|输出值为正数时,在输出值前面加上空格, 为负数时加上负号. 如果有'+'标志，空格标志被忽略。|
|##|对c、s、d、u类型无影响|
|##|对o类型, 在输出时加前缀0 (注意是零，不是字母o)|
|##|对x或X类型,在输出时加前缀0x或0X|
|##|对e, E, f, F, g, G类型，结果总包含小数点，即使后面没有数字。对于g和G，尾随的零不被移除。|


```c
##include <stdio.h>
int main(){
    int a = 1;
    int b = -1;
    // -号标志
    printf("a =|%d|\n", a); // |1|
    printf("a =|%5d|\n", a); // |    1|
    printf("a =|%-5d|\n", a);// |1    |
    // +号标志
    printf("a =|%d|\n", a); // |1|
    printf("a =|%+d|\n", a);// |+1|
    printf("b =|%d|\n", b); // |-1|
    printf("b =|%+d|\n", b);// |-1|
    // 0标志
    printf("a =|%5d|\n", a); // |    1|
    printf("a =|%05d|\n", a); // |00001|
    // 空格标志
    printf("a =|% d|\n", a); // | 1| (space before 1)
    printf("b =|% d|\n", b); // |-1| (no space as it's negative)
    // ##号
    int c = 10;
    printf("c = %o\n", c); // 12
    printf("c = %##o\n", c); // 012
    printf("c = %x\n", c); // a
    printf("c = %##x\n", c); // 0xa
    return 0; // Added return
}
```

---

- 精度
    - 格式: `printf("a = %.[精度]类型", a);`
    - 精度格式符以"."开头, 后面跟上十进制整数.
        - 对于d, i, o, u, x, X类型：指定最小输出数字位数。如果写入值的位数小于此值，则结果在左侧用零填充。如果写入值的位数大于此值，则不截断该值。精度为0表示不输出任何字符。
        - 对于a, A, e, E, f, F类型：指定小数点后要输出的数字位数。默认值为6。如果精度为0，则不输出小数点。
        - 对于g, G类型：指定要输出的最大有效数字位数。
        - 对于s类型：指定要输出的最大字节数。如果指定此项，则字符串将写入到达到最大字节数或遇到空字符为止。

```c
##include <stdio.h>
int main(){
    double a = 3.1415926;
    printf("a = %.2f\n", a); // 3.14 (rounds if necessary)

    int val = 123;
    printf("val = %.5d\n", val); // 00123

    char str[] = "hello world";
    printf("str = %.5s\n", str); // hello
    return 0; // Added return
}
```

- 动态指定保留小数位数 (or width, or precision for strings)
    - 格式: `printf("a = %.*f", precision, a);` or `printf("s = %.*s", max_len, s);` or `printf("d = %*d", width, d);`

```c
##include <stdio.h>
int main(){
    double a = 3.1415926;
    printf("a = %.*f\n", 2, a); // 3.14 (precision is 2)

    int num = 123;
    printf("num = %*d\n", 5, num); // |  123| (width is 5)

    char s[] = "example";
    printf("s = %.*s\n", 3, s); // exa (max 3 chars from string)
    return 0; // Added return
}
```

- 实型(浮点类型)有效位数问题
    - 对于单精度数(float),使用%f格式符输出时,仅前6~7位是有效数字 (decimal digits of precision).
    - 对于双精度数(double),使用%lf (or %f in printf)格式符输出时,前15~16位是有效数字 (decimal digits of precision).
    - 有效位数和精度(保留多少位)不同, 有效位数是指从第一个非零数字开始,误差不超过本数位半个单位的、精确可信的数位.
    - 有效位数包含小数点前的非零数位.

```c
##include <stdio.h>
int main(){
    //        1234.567871093750000 (approximate value for float)
    float a = 1234.567890123456789f; // Suffix f is important
    //         1234.567890123456900 (approximate value for double)
    double b = 1234.567890123456789;
    printf("a = %.15f\n", a); // Output will show float precision limits
    printf("b = %.15f\n", b); // Output will show double precision limits
    return 0; // Added return
}
```

---

- 长度
    - 格式: `printf("a = %[长度]类型", a);`

|长度|修饰类型|含义|
|---|---|---|
|hh|d、i、o、u、x, X|输出signed char / unsigned char|
|h|d、i、o、u、x, X|输出 short int / unsigned short int|
|l|d、i、o、u、x, X|输出 long int / unsigned long int|
|l|c|输出 wint_t (wide character)|
|l|s|输出 wchar_t* (wide character string)|
|l|f, e, E, g, G, a, A|输出 double (though %f itself expects double due to default argument promotion, so 'l' is often optional or ignored for float types in printf)|
|ll|d、i、o、u、x, X|输出 long long int / unsigned long long int|
|L|f, e, E, g, G, a, A|输出 long double|
|j|d、i、o、u、x, X|输出 intmax_t / uintmax_t|
|z|d、i、o、u、x, X|输出 size_t / ssize_t|
|t|d、i、o、u、x, X|输出 ptrdiff_t|


```c
##include <stdio.h>
int main(){
    char a_char = 'a'; // ASCII for 'a' is 97
    short int b_short = 123;
    int  c_int = 123;
    long int d_long = 123L;
    long long int e_llong = 123LL;

    printf("a_char as hhd = %hhd\n", a_char); // 97
    printf("b_short as hd = %hd\n", b_short); // 123
    printf("c_int as d = %d\n", c_int); // 123
    printf("d_long as ld = %ld\n", d_long); // 123
    printf("e_llong as lld = %lld\n", e_llong); // 123
    return 0; // Added return
}
```

- 转义字符
    - 格式: `printf("Rate: %.2f%%\n", 3.1415);` // Note the double % for literal %
    - %号在格式控制字符串中有特殊含义, 所以想输出%必须添加一个转移字符 (%%)

```c
##include <stdio.h>
int main(){
    printf("Percentage: %.2f%%\n", 3.1415 * 100); // 输出结果 Percentage: 314.15%
    return 0; // Added return
}
```

---

#### 9.2. `scanf` 函数
- scanf函数用于接收键盘输入的内容, 是一个阻塞式函数,程序会停在scanf函数出现的地方, 直到接收到数据才会执行后面的代码
- scanf函数的调用格式为:
    - `scanf("格式控制字符串", 地址列表);`
    - 例如: `scanf("%d", &num);`  
        ![](https://i-blog.csdnimg.cn/blog_migrate/27856ec2130e7b89f0f7fcd74e55b382.png)

---

- 基本用法
    - 地址列表项中只能传入变量地址, 变量地址可以通过&符号+变量名称的形式获取

```c
##include <stdio.h>
int main(){
    int number;
    printf("请输入一个整数: "); // Prompt user
    scanf("%d", &number); // 接收一个整数
    printf("number = %d\n", number); 
    return 0; // Added return
}
```

- 接收非字符和字符串类型时, 空格、Tab和回车会被忽略 (whitespace is generally skipped before reading numbers or strings with %s)

```c
##include <stdio.h>
int main(){
    float num;
    printf("请输入一个浮点数: "); // Prompt user
    // 例如:输入 Tab 空格 回车 回车 Tab 空格 3.14 , 得到的结果还是3.14
    scanf("%f", &num);
    printf("num = %f\n", num);
    return 0; // Added return
}
```

- 非格式字符串原样输入, 格式控制字符串会赋值给地址项列表项中的变量
    - 不推荐这种写法 (It means if you have `scanf("number = %d", &var);` the user MUST type "number = " before the number)

```c
##include <stdio.h>
int main(){
    int number;
    printf("请输入 'number = <一个整数>': "); // Prompt user
    // 用户必须输入number = 数字  , 否则会得到一个意外的值 (or scanf will fail)
    scanf("number = %d", &number);
    printf("number = %d\n", number);
    return 0; // Added return
}
```

- 接收多条数据
    - 格式控制字符串和地址列表项在数量和类型上必须一一对应
    - 非字符和字符串情况下如果没有指定多条数据的分隔符, 可以使用空格或者回车作为分隔符(不推荐这种写法, as it's less clear)
    - 非字符和字符串情况下建议明确指定多条数据之间分隔符 (if a specific separator is desired)

```c
##include <stdio.h>
int main(){
    int number;
    printf("请输入第一个整数: ");
    scanf("%d", &number);
    printf("number = %d\n", number);
    int value;
    printf("请输入第二个整数: ");
    scanf("%d", &value);
    printf("value = %d\n", value);
    return 0; // Added return
}
```

```c
##include <stdio.h>
int main(){
    int number;
    int value;
    printf("请输入两个整数 (用空格或回车分隔): ");
    // 可以输入 数字 空格 数字, 或者 数字 回车 数字
    scanf("%d%d", &number, &value);
    printf("number = %d\n", number);
    printf("value = %d\n", value);
    return 0; // Added return
}
```

```c
##include <stdio.h>
int main(){
    int number;
    int value;
    printf("请输入两个整数 (用逗号分隔, 例如: 10,20): ");
    // 输入 数字,数字 即可
    scanf("%d,%d", &number, &value);
    printf("number = %d\n", number);
    printf("value = %d\n", value);
    return 0; // Added return
}
```

- \n是scanf函数的结束符号 (This is incorrect. `\n` in `scanf` format string means "match and discard any number of whitespace characters". It doesn't end `scanf` itself. Pressing Enter provides the newline to satisfy this, but `scanf` waits for non-whitespace for the next conversion or end of input.)
- 所以格式化字符串中不能出现\n (It can appear, but its behavior is often misunderstood. It's generally avoided unless specific whitespace handling is needed.)

```c
##include <stdio.h>
int main(){
    int number;
    printf("请输入一个整数，然后按回车，然后再输入一些非空白字符再按回车: ");
    // 输入完毕之后按下回车无法结束输入 (This is because the \n tells scanf to consume whitespace.
    // It will wait for a non-whitespace character after the first Enter before proceeding or finishing.)
    scanf("%d\n", &number); 
    printf("number = %d\n", number);
    return 0; // Added return
}
```

#### 9.3. `scanf` 运行原理
- 系统会将用户输入的内容先放入输入缓冲区
- scanf方式会从输入缓冲区中逐个取出内容赋值给变量
- 如果输入缓冲区的内容不为空,scanf会一直从缓冲区中获取,而不要求再次输入

```c
##include <stdio.h>
int main(){
    int num1;
    int num2;
    char ch1;
    printf("请输入格式如 '整数c整数' (例如 12c34): ");
    scanf("%d%c%d", &num1, &ch1, &num2); // e.g., user types "12c34\n"
                                        // num1 gets 12, ch1 gets 'c', num2 gets 34
                                        // '\n' remains in buffer
    printf("num1 = %d, ch1 = %c, num2 = %d\n", num1, ch1, num2);
    
    char ch2;
    int num3;
    printf("请输入格式如 'c整数' (例如 d56): ");
    // The leftover '\n' from previous input might be read by %c if not handled.
    // To skip whitespace before %c: scanf(" %c%d", &ch2, &num3); (space before %c)
    scanf("%c%d",&ch2, &num3); // If '\n' is in buffer, ch2 might get '\n'
    printf("ch2 = %c, num3 = %d\n", ch2, num3);
    return 0; // Added return
}
```

![](https://i-blog.csdnimg.cn/blog_migrate/9300ef08c74620d3720ff237c8e248a0.png)

- 利用fflush方法清空缓冲区(不是所有平台都能使用)
    - 格式: `fflush(stdin);`
    - C和C++的标准里从来没有定义过 fflush(stdin)
    - MSDN 文档里清除的描述着"fflush on input stream is an extension to the C standard" （fflush 是在标准上扩充的函数, 不是标准函数, 所以不是所有平台都支持）
- 利用setbuf方法清空缓冲区(所有平台有效) (This is incorrect. `setbuf(stdin, NULL)` makes `stdin` unbuffered, it doesn't clear it. A common way to clear the buffer is to read and discard characters until a newline.)

```c
##include <stdio.h>
// ##include <stdlib.h> // For fflush on some systems, or setbuf

void clear_input_buffer() { // A more portable way to clear buffer
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

int main(){
    int num1;
    int num2;
    char ch1;
    printf("请输入格式如 '整数c整数' (例如 12c34): ");
    scanf("%d%c%d", &num1, &ch1, &num2);
    printf("num1 = %d, ch1 = %c, num2 = %d\n", num1, ch1, num2);
    
    clear_input_buffer(); // Clear the buffer
    // fflush(stdin); // Non-standard, might work on Windows
    // setbuf(stdin, NULL); // Makes stdin unbuffered, doesn't clear existing content

    char ch2;
    int num3;
    printf("请输入格式如 'c整数' (例如 d56): ");
    scanf(" %c%d",&ch2, &num3); // Note the space before %c to skip leading whitespace
    printf("ch2 = %c, num3 = %d\n", ch2, num3);
    return 0; // Added return
}
```

---

#### 9.4. `putchar` 和 `getchar`
- putchar: 向屏幕输出一个字符

```c
##include <stdio.h>
int main(){
    char ch = 'a';
    putchar(ch); // 输出a
    putchar('\n'); // To make output cleaner
    return 0; // Added return
}
```

- getchar: 从键盘获得一个字符

```c
##include <stdio.h>
int main(){
    char ch;
    printf("请输入一个字符: ");
    ch = getchar();// 获取一个字符
    printf("ch = %c\n", ch);
    return 0; // Added return
}
```

---

## 10. 内存初步了解
#### 10.1. 变量内存分析（简单版）
- 字节和地址
    - 为了更好地理解变量在内存中的存储细节，先来认识一下内存中的“字节”和“地址”
    - _**每一个小格子代表一个字节**_
    - _**每个字节都有自己的内存地址**_
    - _**内存地址是连续的**_

![](https://i-blog.csdnimg.cn/blog_migrate/5d25d1e1b0e268e047093c2f0118bb83.png)

- 变量存储占用的空间
    - 一个变量所占用的存储空间，和***定义变量时声明的类型***以及***当前编译环境***有关

|类型|16位编译器|32位编译器|64位编译器|
|---|---|---|---|
|char|1|1|1|
|int|2|4|4 (or 8, but commonly 4)|
|float|4|4|4|
|double|8|8|8|
|short|2|2|2|
|long|4|4|8 (or 4, commonly 8 on 64-bit Linux/macOS, 4 on 64-bit Windows)|
|long long|8|8|8|
|void* (pointer)|2|4|8|

- 变量存储的过程
    
    - 根据定义变量时声明的类型和当前编译环境确定需要开辟多大存储空间
    - 在内存中开辟一块存储空间，开辟时从内存地址大的开始开辟（内存寻址从大到小 - This refers to how the stack typically grows downwards on many architectures. Heap allocation is different.)
    - 将数据保存到已经开辟好的对应内存空间中
    
    ```c
    // int main(){ // Original code snippet was missing main
    //   int number;
    //   int value;
    //   number = 22;
    //   value = 666;
    // }
    ```
    
    ```c
    ##include <stdio.h>
    int main(){
        int number;
        int value;
        number = 22;
        value = 666;
        printf("&number = %p\n", (void*)&number); // %p expects void*
        printf("&value = %p\n", (void*)&value);   
        // Example output (stack grows down):
        // &number = 0x7ffee1c4d838 
        // &value = 0x7ffee1c4d834 
        return 0; // Added return
    }
    ```
    

![](https://i-blog.csdnimg.cn/blog_migrate/5a1c006eb07f56e65dbfd6922a015d4c.png)

> 先不要着急, 刚开始接触C语言, 我先了解这么多就够了. 后面会再次更深入的讲解存储的各种细节。

#### 10.2. `char` 类型内存存储细节
- char类型基本概念
    - char是C语言中比较灵活的一种数据类型，称为“字符型”
    - char类型变量占1个字节存储空间，共8位
    - 除单个字符以外, C语言的的转义字符也可以利用char类型存储 (A char stores the *value* of the character, including escape sequences which represent single characters)

|字符|意义|ASCII (Dec)|
|---|---|---|
|\b|退格(BS)当前位置向后回退一个字符|8|
|\r|回车(CR),将当前位置移至本行开头|13|
|\n|换行(LF),将当前位置移至下一行开头|10|
|\t|水平制表(HT),跳到下一个 TAB 位置|9|
|\0|用于表示字符串的结束标记 (空字符 NUL)|0|
|`\\`|代表一个反斜线字符 \| |92|
|\"|代表一个双引号字符"|34|
|\’|代表一个单引号字符’|39|

- char型数据存储原理
    - 计算机只能识别0和1, 所以char类型存储数据并不是存储一个字符, 而是将字符转换为0和1之后再存储 (More accurately, it stores the character's numerical representation, typically ASCII or UTF-8 value, as a binary number).
    - 正是因为存储字符类型时需要将字符转换为0和1, 所以为了统一, 老美就定义了一个叫做ASCII表的东东
    - ASCII表中定义了每一个字符对应的整数  
        ![](https://i-blog.csdnimg.cn/blog_migrate/1df91a9ee6676e90d6bbe0964de82335.png)

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    char ch1 = 'a'; 
    printf("%d\n", ch1); // 97 (ASCII value of 'a')

    char ch2 = 97;
    printf("%c\n", ch2); // a (character corresponding to ASCII 97)
    return 0; // Added return
}
```

- char类型注意点
    
    - char类型占一个字节, 一个中文字符占3字节(unicode表 - specifically UTF-8 encoding for many Chinese characters),所有char不可以存储中文 (directly as a single char variable)
    
    ```c
    // char c = '我'; // 错误写法 (for a single char variable to hold a multi-byte character)
    // You would use a char array (string) for Chinese characters: char s[] = "我";
    ```
    
    - 除转义字符以外, 不支持多个字符 (in a single char variable)
    
    ```c
    // char ch = 'ab'; // 错误写法 (multi-character constant, implementation-defined, usually bad)
    ```
    
    - char类型存储字符时会先查找对应的ASCII码值, 存储的是ASCII值, 所以字符'6'和数字6存储的内容不同
    
    ```c
    ##include <stdio.h> // Added for printf
    int main() { // Added main wrapper
        char ch1 = '6'; // 存储的是ASCII码 54 (for character '6')
        char ch2 = 6; //  存储的是数字 6 (which corresponds to ACK control character in ASCII)
        printf("ch1 as char: %c, as int: %d\n", ch1, ch1);
        printf("ch2 as char: %c, as int: %d\n", ch2, ch2); // Will print ACK or non-printable
        return 0; // Added return
    }
    ```
    
- 练习
    - 定义一个函数, 实现输入一个小写字母,要求转换成大写输出
```c

##include <stdio.h> // Added for printf
##include <ctype.h> // Added for toupper

char toUpper(char lower) {
    if (lower >= 'a' && lower <= 'z') {
        return lower - ('a' - 'A'); // or use toupper(lower) from ctype.h
    }
    return lower; // Return as is if not a lowercase letter
}

int main() {
    char inputChar, upperChar;
    printf("请输入一个小写字母: ");
    scanf(" %c", &inputChar); // Space before %c to consume any leading whitespace

    upperChar = toUpper(inputChar);
    printf("转换后的大写字母是: %c\n", upperChar);

    return 0;
}
    ```

---

## **第三部分：流程控制**

## 11. 流程控制基本概念
- 默认情况下程序运行后，系统会按书写顺序从上至下依次执行程序中的每一行代码。但是这并不能满足我们所有的开发需求, 为了方便我们控制程序的运行流程，C语言提供3种流程控制结构，不同的流程控制结构可以实现不同的运行流程。
    
- 这3种流程结构分别是顺序结构、选择结构、循环结构
    
- 顺序结构:
    
    - 按书写顺序从上至下依次执行  
        ![](https://i-blog.csdnimg.cn/blog_migrate/0a015b3a151164c8c7447301bcc10d42.png)
- 选择结构
    
    - 对给定的条件进行判断，再根据判断结果来决定执行代码  
        ![](https://i-blog.csdnimg.cn/blog_migrate/1c019301e8c2e91aed6353b567686680.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/4cb9ed3cffca484e9f586d857b1938e9.png)
- 循环结构
    
    - 在给定条件成立的情况下，反复执行某一段代码  
        ![](https://i-blog.csdnimg.cn/blog_migrate/d2c187cea8d49b6462cedbc90a00e07f.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/8ba26ca5375ac484559951b2bcf817c9.png)

---

## 12. 选择结构
- C语言中提供了两大选择结构, 分别是if和switch  
#### 12.1. `if` 语句
- if第一种形式
    - 表示如果表达式为真,执行语句块1,否则不执行

```c
if(表达式) {
  语句块1;
}
后续语句;
```

```c
// Example
int age = 20; // Added variable declaration
if(age >= 18) {
  printf("开网卡\n");
}
printf("买烟\n");
```

- if第二种形式
    - 如果表达式为真,则执行语句块1,否则执行语句块2
    - else不能脱离if单独使用

```c
if(表达式){
  语句块1;
}else{
  语句块2;
}
后续语句;
```

```c
// Example
int age = 16; // Added variable declaration
if(age > 18){
  printf("开网卡\n");
}else{
  printf("喊家长来开\n");
}
printf("买烟\n");
```

- if第三种形式 (else if)
    - 如果"表达式1"为真,则执行"语句块1",否则判断"表达式2",如果为真执行"语句块2",否则再判断"表达式3",如果真执行"语句块3", 当表达式1、2、3都不满足,会执行最后一个else语句
    - 众多大括号中,只有一个大括号中的内容会被执行
    - 只有前面所有添加都不满足, 才会执行else大括号中的内容

```c
if(表达式1) {
  语句块1;
}else if(表达式2){
  语句块2;
}else if(表达式3){
  语句块3;
}else{
  语句块4;
}
后续语句;
```

```c
// Example
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int age = 20; // Added variable declaration
    if(age>40){
      printf("给房卡");
    }else if(age>25){
      printf("给名片");
    }else if(age>18){
       printf("给网卡");
    }else{
      printf("给好人卡");
    }
    printf("\n买烟\n"); // Added newline for clarity
    return 0; // Added return
}
```

- if嵌套
    - if中可以继续嵌套if, else中也可以继续嵌套if

```c
if(表达式1){
    // 语句块1; // Original comment was here, can be actual code
   if(表达式2){
      // 语句块2;
  }
}else{
   if(表达式3){
      // 语句块3;
  }else{
      // 语句块4;
  }
}
```

---

- _**if注意点**_
    - 任何数值都有真假性

```c
##include <stdio.h>
int main(){
    if(0){ // 0 is false
        printf("执行了if");
    }else{
        printf("执行了else"); // 被执行
    }
    printf("\n"); // Added for clarity
    return 0; // Added return
}
```

- 当if else后面只有一条语句时, if else后面的大括号可以省略 (but it's generally bad practice as it can lead to errors)

```c
    // 极其不推荐写法
    ##include <stdio.h> // Added for printf
    int main() { // Added main wrapper
        int age = 17;
        if (age >= 18)
            printf("开网卡\n");
        else
            printf("喊家长来开\n");
        return 0; // Added return
    }
```

- 当if else后面的大括号被省略时, else会自动和距离最近的一个未匹配的if匹配 (dangling else problem)

```c
##include <stdio.h>
int main(){
    if(0) // This if is false
        if(1) // This if is not evaluated
            printf("A\n");
    else // This else matches the inner if(1), but since if(0) was false, this block is skipped.
            printf("B\n"); 
    // The following is a separate if-else structure
    if (0) // This if is false
        printf("X\n"); // Not printed
    else // This else matches the if(0) above it
        if (1) // This if is true
            printf("C\n"); // 输出C
    else // This else matches the if(1)
            printf("D\n");
    printf("\n"); // Added for clarity
    return 0; // Added return
}
/* Original interpretation was:
    if(0)
        if(1)
            printf("A\n");
        else //和if(1)匹配
            printf("B\n");
    else //和if(0)匹配, 因为if(1)已经被匹配过了
        if (1)
            printf("C\n"); // 输出C
        else //和if(1)匹配
            printf("D\n");
This structure implies the second 'else' belongs to the first 'if(0)'.
The output would be C.
*/
```

- 如果if else省略了大括号, 那么后面不能定义变量 (This is because a declaration is not an expression statement. You'd need a block `{}`.)

```c
##include <stdio.h>
int main(){
    if(1) { // Added braces to make it valid
        int number = 10; 
        printf("number = %d\n", number);
    }
    // else // If there was an else, it would also need braces or a single statement
    //    int value = 20; // 系统会报错 without braces
    return 0; // Added return
}
```

```c
##include <stdio.h>
int main(){
    if(0){
        int number = 10; 
    }else { // Added braces
        int value = 20; 
        printf("value = %d\n", value); // Moved printf inside to use value
    }
    return 0; // Added return
}
```

- C语言中分号(;)也是一条语句, 称之为空语句

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    // 因为if(10 > 2)后面有一个分号, 所以系统会认为if省略了大括号
    // if省略大括号时只能管控紧随其后的那条语句, 所以只能管控分号 (the empty statement)
    if(10 > 2); // The if statement controls only this semicolon.
    { // This is a separate block, not controlled by the if.
        printf("10 > 2\n"); // This will always print.
    }
    // 输出结果: 10 > 2
    return 0; // Added return
}
```

- 但凡遇到比较一个变量等于或者不等于某一个常量的时候，把常量写在前面 (Yoda conditions - helps prevent accidental assignment)

```c
##include <stdio.h>
int main(){
    int a = 8;
//    if(a = 10){ // 错误写法 (assignment, not comparison), 但不会报错 (it's valid C, but logically wrong)
    if (10 == a){ // Good practice
      printf("a的值是10\n");
    }else{
     printf("a的值不是10\n");
    }
    return 0; // Added return
}
```

---

- if练习
    
    - 从键盘输入一个整数，判断其是否是偶数，如果是偶数就输出YES，否则输出NO；
    - 接收用户输入的1～7的整数，根据用户输入的整数，输出对应的星期几
    - 接收用户输入的一个整数month代表月份，根据月份输出对应的季节
    - 接收用户输入的两个整数，判断大小后输出较大的那个数
    - 接收用户输入的三个整数，判断大小后输出较大的那个数
    - 接收用户输入的三个整数，排序后输出
- 实现石头剪刀布
    

```
剪刀石头布游戏:
1)定义游戏规则
  剪刀 干掉 布
  石头 干掉 剪刀
  布 干掉石头
2)显示玩家开始猜拳
3)接收玩家输入的内容
4)让电脑随机产生一种拳
5)判断比较
(1)玩家赢的情况(显示玩家赢了)
(2)电脑赢的情况(显示电脑赢了)
(3)平局(显示平局)
```

![](https://i-blog.csdnimg.cn/blog_migrate/6397663a2671ba2ab48e8793d7967f13.png)  
![](https://i-blog.csdnimg.cn/blog_migrate/22b98baf5825a6293f3d3d19a9c6db82.png)  
![](https://i-blog.csdnimg.cn/blog_migrate/895d2deaf8718f37418cf369b59cec0a.png)

---

#### 12.2. 选择结构 `switch`
- 由于 if else if 还是不够简洁，所以switch 就应运而生了，他跟 if else if 互为补充关系。switch 提供了点的多路选择
- 格式:

```c
switch(表达式){ // Expression must evaluate to an integer type (char, short, int, long, enum)
    case 常量表达式1: // Constant expression must be an integer constant
        语句1;
        break; // Optional, but usually needed to prevent fall-through
    case 常量表达式2:
        语句2; 
        break;
    // ...
    case 常量表达式n:
        语句n;
        break;
    default: // Optional
        语句n+1;
        break; // Optional for default if it's the last case
}
```

- 语义:
    - 计算"表达式"的值, 逐个与其后的"常量表达式"值相比较,当"表达式"的值与某个"常量表达式"的值相等时, 即执行其后的语句, 然后跳出switch语句 (if `break` is present)
    - 如果"表达式"的值与所有case后的"常量表达式"均不相同时,则执行default后的语句 (if `default` is present)
- 示例:

```c
##include <stdio.h>

int main() {
    int num = 3;
    switch(num){
    case 1:
        printf("星期一\n");
        break;
    case 2:
        printf("星期二\n");
        break;
    case 3:
        printf("星期三\n");
        break;
    case 4:
        printf("星期四\n");
        break;
    case 5:
        printf("星期五\n");
        break;
    case 6:
        printf("星期六\n");
        break;
    case 7:
        printf("星期日\n");
        break;
    default:
        printf("回火星去\n");
        break;
    }
    return 0; // Added return
}
```

---

- switch注意点
    - switch条件表达式的类型必须是整型, 或者可以被提升为整型的值(char、short)

```c
##include <stdio.h>

int main() {
    // switch(1.1){ // 报错: switch quantity not an integer
    // case 1:
    //     printf("星期一\n");
    //     break;
    // case 2:
    //     printf("星期二\n");
    //     break;
    // default:
    //     printf("回火星去\n");
    //     break;
    // }
    printf("Switch with float will cause a compile error.\n");
    return 0; // Added return
}
```

- case的值只能是常量, 并且还必须是整型, 或者可以被提升为整型的值(char、short)

```c
##include <stdio.h>

int main() {
    int num_var = 3; // Renamed from num to avoid conflict
    switch(1){ 
    case 1:
        printf("星期一\n");
        break;
    case 'a': // 'a' is an integer constant (its ASCII value)
        printf("星期二 (case 'a')\n");
        break;
    // case num_var: // 报错: case label does not reduce to an integer constant
    //     printf("星期三\n");
    //     break;
    // case 4.0: // 报错: case label does not reduce to an integer constant
    //     printf("星期四\n");
    //     break;
    default:
        printf("回火星去\n");
        break;
    }
    printf("Variable in case or float in case will cause compile error.\n");
    return 0; // Added return
}
```

- case后面常量表达式的值不能相同

```c
##include <stdio.h>

int main() {
    switch(1){ 
    case 1: 
        printf("星期一 (first case 1)\n");
        break;
    // case 1: // 报错: duplicate case value
    //     printf("星期一 (second case 1)\n");
    //     break;
    default:
        printf("回火星去\n");
        break;
    }
    printf("Duplicate case will cause compile error.\n");
    return 0; // Added return
}
```

- case后面要想定义变量,必须给case加上大括号 (to create a new scope)

```c
##include <stdio.h>

int main() {
    switch(1){
    case 1:{ // Braces create a block scope
        int num_case = 10; // Renamed from num
        printf("num_case = %d\n", num_case);
        printf("星期一\n");
        break;
        }
    case 2:
        printf("星期二\n"); // Corrected from "星期一"
        break;
    default:
        printf("回火星去\n");
        break;
    }
    return 0; // Added return
}
```

- switch中只要任意一个case匹配, 其它所有的case和default都会失效 (This is incorrect. If a case matches and there's no `break`, execution "falls through" to the next case's statements, regardless of whether that next case label matches. `default` is only jumped to if no case matches initially.)
- 所以如果case和default后面没有break就会出现穿透问题 (Fall-through is the correct term)

```c
##include <stdio.h>

int main() {
    int num = 2;
    switch(num){
    case 1:
        printf("星期一\n");
        break;
    case 2:
        printf("星期二\n"); // 被输出
        // No break, fall-through occurs
    case 3:
        printf("星期三\n"); // 被输出 due to fall-through
        // No break, fall-through occurs
    default: // Also executed due to fall-through
        printf("回火星去\n"); // 被输出
        break; // This break stops further fall-through if default wasn't last
    }
    return 0; // Added return
}
```

- switch中default可以省略

```c
##include <stdio.h>

int main() {
    switch(1){
    case 1:
        printf("星期一\n");
        break;
    case 2:
        printf("星期二\n"); // Corrected
        break;
    // No default case
    }
    return 0; // Added return
}
```

- switch中default的位置不一定要写到最后, 无论放到哪都会等到所有case都不匹配才会执行(穿透问题除外) (Correct, but if it's not last and has code, it needs a `break` to prevent falling into subsequent cases if it's matched.)

```c
##include <stdio.h>

int main() {
    switch(3){ // This will match default
    case 1:
        printf("星期一\n");
        break;
    default:
        printf("Other,,,\n");
        break; // Important if default is not the last case with code
    case 2:
        printf("星期二\n"); // Corrected
        break;
    }
    return 0; // Added return
}
```

---

- _**if和Switch转换**_
- 看上去if和switch都可以实现同样的功能, 那么在企业开发中我们什么时候使用if, 什么时候使用switch呢?
    - if else if 针对于范围的多路选择 (and complex conditions)
    - switch 是针对点的多路选择 (equality with integer constants)
- 判断用户输入的数据是否大于100

```c
##include <stdio.h>

int main() {
    int a = -1;
    printf("请输入一个整数: "); // Prompt
    scanf("%d", &a);
    if(a > 100){
        printf("用户输入的数据大于100\n");
    }else{
        printf("用户输入的数据不大于100\n");
    }
    return 0; // Added return
}
```

```c
##include <stdio.h>

int main() {
    int a = -1;
    printf("请输入一个整数: "); // Prompt
    scanf("%d", &a);
    // 挺(T)萌(M)的(D)搞不定啊 (This comment implies switch is not suitable here, which is true for ranges)
    // Switch is not good for range checks like > 100.
    // The example below is impractical for this problem.
    switch (a) { // This would require listing all numbers > 100
        // case 101:
        // case 102:
        // ... and so on, which is not feasible.
        // A common trick for simple ranges if applicable:
        // switch (a > 100) { // a > 100 evaluates to 0 or 1
        //    case 1: printf("大于100\n"); break;
        //    case 0: printf("不大于100\n"); break;
        // }
        // However, the original example was trying to match specific values.
        default: // This default would catch everything not explicitly cased.
            if (a > 100) { // Need an if inside for the actual logic
                 printf("大于100\n");
            } else {
                 printf("不大于100\n");
            }
            break;
    }
    return 0; // Added return
}
```

---

- 练习
    - 实现分数等级判定

```
要求用户输入一个分数，根据输入的分数输出对应的等级
A 90～100  
B 80～89
C 70～79
D 60～69
E 0～59
```
**Using if-else if (more suitable):**
```c
##include <stdio.h>
int main() {
    int score;
    printf("请输入分数 (0-100): ");
    scanf("%d", &score);
    if (score >= 90 && score <= 100) {
        printf("等级: A\n");
    } else if (score >= 80 && score <= 89) {
        printf("等级: B\n");
    } else if (score >= 70 && score <= 79) {
        printf("等级: C\n");
    } else if (score >= 60 && score <= 69) {
        printf("等级: D\n");
    } else if (score >= 0 && score <= 59) {
        printf("等级: E\n");
    } else {
        printf("无效的分数\n");
    }
    return 0;
}
```
**Using switch (less direct, often involves integer division trick):**
```c
##include <stdio.h>
int main() {
    int score;
    printf("请输入分数 (0-100): ");
    scanf("%d", &score);
    if (score < 0 || score > 100) {
        printf("无效的分数\n");
        return 1;
    }
    switch (score / 10) { // Integer division
        case 10: // For score 100
        case 9:  // For scores 90-99
            printf("等级: A\n");
            break;
        case 8:  // For scores 80-89
            printf("等级: B\n");
            break;
        case 7:  // For scores 70-79
            printf("等级: C\n");
            break;
        case 6:  // For scores 60-69
            printf("等级: D\n");
            break;
        default: // For scores 0-59
            printf("等级: E\n");
            break;
    }
    return 0;
}
```

- 实现+ - * / 简单计算器
```c
##include <stdio.h>
int main() {
    double num1, num2, result;
    char operator;
    printf("请输入表达式 (例如: 10 + 20): ");
    scanf("%lf %c %lf", &num1, &operator, &num2);

    switch (operator) {
        case '+':
            result = num1 + num2;
            printf("%.2lf + %.2lf = %.2lf\n", num1, num2, result);
            break;
        case '-':
            result = num1 - num2;
            printf("%.2lf - %.2lf = %.2lf\n", num1, num2, result);
            break;
        case '*':
            result = num1 * num2;
            printf("%.2lf * %.2lf = %.2lf\n", num1, num2, result);
            break;
        case '/':
            if (num2 != 0) {
                result = num1 / num2;
                printf("%.2lf / %.2lf = %.2lf\n", num1, num2, result);
            } else {
                printf("错误：除数不能为零！\n");
            }
            break;
        default:
            printf("错误：无效的运算符！\n");
            break;
    }
    return 0;
}
```


---

# **第三部分：流程控制**

## 11. 流程模式

按照代码的执行顺序，或者执行流程，我们可以将C语言程序分成三种基本结构，分别是顺序结构、选择结构和循环结构：

- 顺序结构就是按照从头到尾的顺序依次执行每一条C语言代码，不重复执行任何代码，也不跳过任何代码。
- 选择结构也称分支结构，就是程序出现了“岔路口”，会有选择性的执行部分代码，而忽略其它代码；换句话说，程序可以跳过没用的代码，只执行有用的代码。
- 循环结构就是让程序“杀个回马枪”，不断地重复执行同一段代码。

除了这三种基本结构，C语言其实还有第四种结构，就是跳转结构（通过 [goto](https://c.biancheng.net/view/ol0crux.html) 语句实现），它允许程序跳转到任意一条代码，然后从此处开始执行。不过，频繁使用跳转结构会使得程序的逻辑变得复杂难懂，调试费劲，所以现在已经不推荐使用跳转结构了。  
  
在大学教材，或者考试题目中，通常只会提到“三种基本结构”，很少涉及第四种结构。

- 默认情况下程序运行后，系统会按书写顺序从上至下依次执行程序中的每一行代码。但是这并不能满足我们所有的开发需求, 为了方便我们控制程序的运行流程，C语言提供3种流程控制结构，不同的流程控制结构可以实现不同的运行流程。
    
- 这3种流程结构分别是顺序结构、选择结构、循环结构
    
- 顺序结构:
    
    - 按书写顺序从上至下依次执行  
        ![](https://i-blog.csdnimg.cn/blog_migrate/0a015b3a151164c8c7447301bcc10d42.png)
- 选择结构
    
    - 对给定的条件进行判断，再根据判断结果来决定执行代码  
        ![](https://i-blog.csdnimg.cn/blog_migrate/1c019301e8c2e91aed6353b567686680.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/4cb9ed3cffca484e9f586d857b1938e9.png)
- 循环结构
    
    - 在给定条件成立的情况下，反复执行某一段代码  
        ![](https://i-blog.csdnimg.cn/blog_migrate/d2c187cea8d49b6462cedbc90a00e07f.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/8ba26ca5375ac484559951b2bcf817c9.png)


  

### 11.1.1 顺序结构

顺序结构是最简单的程序结构，也是代码默认的执行顺序。在程序结构中，程序会按照代码的书写顺序从上到下、从左到右依次执行每一条语句。顺序结构的代码就是傻瓜式执行，没有任何拐弯抹角。  
  
本教程前面的代码都是顺序结构，这是初学者最先接触的程序结构。  
  
下面是一个顺序结构的示例，展示了如何计算长方形的面积：

```c
1. #include <stdio.h>

2. int main() {
3.     float length, width, area;

4.     length = 5.0;
5.     width = 3.0;
6.     area = length * width;

7.     printf("长方形的面积是：%.2f\n", area);

8.     return 0;
9. }
```
输出结果：

长方形的面积是：15.00

在这个例子中，程序按照顺序执行以下步骤：声明变量、赋值、计算面积、打印结果。每一步都依次执行，不忽略任何代码，也不重复任何代码。

### 11.1.2 分支结构

在C语言中，我们可以设置一个条件，让程序根据不同的条件执行不同的代码块，这就是分支结构。分支结构就像岔路口，你可以往左走，也可以往右走；具体要怎么走，得根据给出的条件来判断。  
  
C语言有三种方式来实现分支结构，分别是 [if else](https://c.biancheng.net/view/40tjdob.html) 语句、[switch case](https://c.biancheng.net/view/1808.html) 语句、[三目运算符](https://c.biancheng.net/view/296.html)`? :`。  
  
下面的例子使用了 if else 分支结构，用来判断一个数是否是偶数：

```c
1. #include <stdio.h>

2. int main() {
3.     int number;

4.     printf("请输入一个整数：");
5.     scanf("%d", &number);

6.     if (number % 2 == 0) {
7.         //这是第一个代码块
8.         printf("%d 是偶数。\n", number);
9.     } else {
10.         //这是第二个代码块
11.         printf("%d 是奇数。\n", number);
12.     }

13.     return 0;
14. }
```
输出结果（假设输入为 7）：
```bash
请输入一个整数：7↙
7 是奇数。
```

在这个例子中，程序根据「输入的数字是否能被 2 整除」来决定执行哪个代码块，也即`{ }`中的代码。if 语句检查条件`number % 2 == 0`，如果它的结果为真，则执行第一个代码块，否则执行 else 后的代码块。

### 11.1.3 循环结构

C语言循环结构允许程序重复地执行某个代码块，直到满足特定的条件才会终止。循环结构非常适合处理需要重复执行的任务，比如遍历数组、计算累加的和、分析每一条日志等。  
  
C语言提供了三种主要的循环结构，分别是 [for](https://c.biancheng.net/view/1811.html) 循环、[while](https://c.biancheng.net/view/4t0wijh.html) 循环和 do while 循环。  
  
下面的例子使用 for 循环来计算从 1 加到 100 的和：

```c
1. #include <stdio.h>

2. int main() {
3.     int sum = 0;

4.     for (int i = 1; i <= 100; i++) {
5.         //这是重复执行的代码块
6.         sum += i;
7.     }

8.     printf("1 到 100 的和是：%d\n", sum);

9.     return 0;
10. }
```

输出结果：
```bash
1 到 100 的和是：5050
```

在这个例子中，for 循环初始化变量 i 为 1，每次循环 i 增加 1，直到 i 大于 100 时停止。循环体内将每次的 i 值加到 sum 中，最终得到 1 到 100 的和。

### 11.1.4 跳转结构

跳转结构通过 goto 语句实现，它允许程序无条件地跳转到代码中的任意位置，然后从此处开始执行。虽然 goto 语句用起来非常灵活，但是它往往使得程序的逻辑变得混乱难懂，所以现在已经不推荐使用了。  
  
下面的例子中，我们使用 goto 语句跳出嵌套循环：

```c
1. #include <stdio.h>

2. int main() {
3.     int i, j;

4.     for (i = 1; i < 5; i++) {
5.         for (j = 1; j < 5; j++) {
6.             if (i == 2 && j == 2) {
7.                 goto end_loop;
8.             }
9.             printf("i = %d, j = %d\n", i, j);
10.         }
11.     }

12. end_loop:
13.     printf("跳出循环\n");

14.     return 0;
15. }
```

输出结果：

```bash
i = 1, j = 1
i = 1, j = 2
i = 1, j = 3
i = 1, j = 4
i = 2, j = 1
跳出循环
```

在这个例子中，当 i 和 j 都等于 2 时，会执行 goto 语句，直接跳到 end_loop 标签处，然后执行它后面的代码。这意味着，整个循环被跳过了，不再执行了。

```ad-note
title:总结
本文介绍了C语言程序的三种基本结构（顺序结构、选择结构和循环结构），以及一种不常用、不推荐的结构（跳转结构）；对于每种结构，笔者还提供了示例，让大家有一个更加直观的认识。  
  
对于初学者来说，本文中的示例大概率看不懂，不过别着急，接下来的章节我会详细介绍它们的用法，let's go。

```


---

## 12. 选择结构
- C语言中提供了两大选择结构, 分别是if和switch  
#### 12.1. `if` 语句
- if第一种形式
    - 表示如果表达式为真,执行语句块1,否则不执行

```c
if(表达式) {
  语句块1;
}
后续语句;
```

```c
// Example
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int age = 20; 
    if(age >= 18) {
      printf("开网卡\n");
    }
    printf("买烟\n");
    return 0; // Added return
}
```

- if第二种形式
    - 如果表达式为真,则执行语句块1,否则执行语句块2
    - else不能脱离if单独使用

```c
if(表达式){
  语句块1;
}else{
  语句块2;
}
后续语句;
```

```c
// Example
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int age = 16; 
    if(age > 18){
      printf("开网卡\n");
    }else{
      printf("喊家长来开\n");
    }
    printf("买烟\n");
    return 0; // Added return
}
```

- if第三种形式 (else if)
    - 如果"表达式1"为真,则执行"语句块1",否则判断"表达式2",如果为真执行"语句块2",否则再判断"表达式3",如果真执行"语句块3", 当表达式1、2、3都不满足,会执行最后一个else语句
    - 众多大括号中,只有一个大括号中的内容会被执行
    - 只有前面所有添加都不满足, 才会执行else大括号中的内容

```c
if(表达式1) {
  语句块1;
}else if(表达式2){
  语句块2;
}else if(表达式3){
  语句块3;
}else{
  语句块4;
}
后续语句;
```

```c
// Example
##include <stdio.h> 
int main() { 
    int age = 20; 
    if(age>40){
      printf("给房卡");
    }else if(age>25){
      printf("给名片");
    }else if(age>18){
       printf("给网卡");
    }else{
      printf("给好人卡");
    }
    printf("\n买烟\n"); 
    return 0; 
}
```

- if嵌套
    - if中可以继续嵌套if, else中也可以继续嵌套if

```c
if(表达式1){
    // 语句块1; 
   if(表达式2){
      // 语句块2;
  }
}else{
   if(表达式3){
      // 语句块3;
  }else{
      // 语句块4;
  }
}
```

---

- _**if注意点**_
    - 任何数值都有真假性

```c
##include <stdio.h>
int main(){
    if(0){ 
        printf("执行了if");
    }else{
        printf("执行了else"); 
    }
    printf("\n"); 
    return 0; 
}
```

- 当if else后面只有一条语句时, if else后面的大括号可以省略 (but it's generally bad practice as it can lead to errors)

```c
    // 极其不推荐写法
    ##include <stdio.h> 
    int main() { 
        int age = 17;
        if (age >= 18)
            printf("开网卡\n");
        else
            printf("喊家长来开\n");
        return 0; 
    }
```

- 当if else后面的大括号被省略时, else会自动和距离最近的一个未匹配的if匹配 (dangling else problem)

```c
##include <stdio.h>
int main(){
    if(0) 
        if(1) 
            printf("A\n");
    else 
            printf("B\n"); 
    
    if (0) 
        printf("X\n"); 
    else 
        if (1) 
            printf("C\n"); 
    else 
            printf("D\n");
    printf("\n"); 
    return 0; 
}
```

- 如果if else省略了大括号, 那么后面不能定义变量 (This is because a declaration is not an expression statement. You'd need a block `{}`.)

```c
##include <stdio.h>
int main(){
    if(1) { 
        int number = 10; 
        printf("number = %d\n", number);
    }
    return 0; 
}
```

```c
##include <stdio.h>
int main(){
    if(0){
        int number = 10; 
    }else { 
        int value = 20; 
        printf("value = %d\n", value); 
    }
    return 0; 
}
```

- C语言中分号(;)也是一条语句, 称之为空语句

```c
##include <stdio.h> 
int main() { 
    if(10 > 2); 
    { 
        printf("10 > 2\n"); 
    }
    return 0; 
}
```

- 但凡遇到比较一个变量等于或者不等于某一个常量的时候，把常量写在前面 (Yoda conditions - helps prevent accidental assignment)

```c
##include <stdio.h>
int main(){
    int a = 8;
    if (10 == a){ 
      printf("a的值是10\n");
    }else{
     printf("a的值不是10\n");
    }
    return 0; 
}
```

---

- if练习
    
    - 从键盘输入一个整数，判断其是否是偶数，如果是偶数就输出YES，否则输出NO；
    - 接收用户输入的1～7的整数，根据用户输入的整数，输出对应的星期几
    - 接收用户输入的一个整数month代表月份，根据月份输出对应的季节
    - 接收用户输入的两个整数，判断大小后输出较大的那个数
    - 接收用户输入的三个整数，判断大小后输出较大的那个数
    - 接收用户输入的三个整数，排序后输出
- 实现石头剪刀布
    

```
剪刀石头布游戏:
1)定义游戏规则
  剪刀 干掉 布
  石头 干掉 剪刀
  布 干掉石头
2)显示玩家开始猜拳
3)接收玩家输入的内容
4)让电脑随机产生一种拳
5)判断比较
(1)玩家赢的情况(显示玩家赢了)
(2)电脑赢的情况(显示电脑赢了)
(3)平局(显示平局)
```

![](https://i-blog.csdnimg.cn/blog_migrate/6397663a2671ba2ab48e8793d7967f13.png)  
![](https://i-blog.csdnimg.cn/blog_migrate/22b98baf5825a6293f3d3d19a9c6db82.png)  
![](https://i-blog.csdnimg.cn/blog_migrate/895d2deaf8718f37418cf369b59cec0a.png)

---

#### 12.2. 选择结构 `switch`
- 由于 if else if 还是不够简洁，所以switch 就应运而生了，他跟 if else if 互为补充关系。switch 提供了点的多路选择
- 格式:

```c
switch(表达式){ 
    case 常量表达式1: 
        语句1;
        break; 
    case 常量表达式2:
        语句2; 
        break;
    // ...
    case 常量表达式n:
        语句n;
        break;
    default: 
        语句n+1;
        break; 
}
```

- 语义:
    - 计算"表达式"的值, 逐个与其后的"常量表达式"值相比较,当"表达式"的值与某个"常量表达式"的值相等时, 即执行其后的语句, 然后跳出switch语句 (if `break` is present)
    - 如果"表达式"的值与所有case后的"常量表达式"均不相同时,则执行default后的语句 (if `default` is present)
- 示例:

```c
##include <stdio.h>

int main() {
    int num = 3;
    switch(num){
    case 1:
        printf("星期一\n");
        break;
    case 2:
        printf("星期二\n");
        break;
    case 3:
        printf("星期三\n");
        break;
    case 4:
        printf("星期四\n");
        break;
    case 5:
        printf("星期五\n");
        break;
    case 6:
        printf("星期六\n");
        break;
    case 7:
        printf("星期日\n");
        break;
    default:
        printf("回火星去\n");
        break;
    }
    return 0; 
}
```

---

- switch注意点
    - switch条件表达式的类型必须是整型, 或者可以被提升为整型的值(char、short)

```c
##include <stdio.h>

int main() {
    printf("Switch with float will cause a compile error.\n");
    return 0; 
}
```

- case的值只能是常量, 并且还必须是整型, 或者可以被提升为整型的值(char、short)

```c
##include <stdio.h>

int main() {
    int num_var = 3; 
    switch(1){ 
    case 1:
        printf("星期一\n");
        break;
    case 'a': 
        printf("星期二 (case 'a')\n");
        break;
    default:
        printf("回火星去\n");
        break;
    }
    printf("Variable in case or float in case will cause compile error.\n");
    return 0; 
}
```

- case后面常量表达式的值不能相同

```c
##include <stdio.h>

int main() {
    switch(1){ 
    case 1: 
        printf("星期一 (first case 1)\n");
        break;
    default:
        printf("回火星去\n");
        break;
    }
    printf("Duplicate case will cause compile error.\n");
    return 0; 
}
```

- case后面要想定义变量,必须给case加上大括号 (to create a new scope)

```c
##include <stdio.h>

int main() {
    switch(1){
    case 1:{ 
        int num_case = 10; 
        printf("num_case = %d\n", num_case);
        printf("星期一\n");
        break;
        }
    case 2:
        printf("星期二\n"); 
        break;
    default:
        printf("回火星去\n");
        break;
    }
    return 0; 
}
```

- switch中只要任意一个case匹配, 其它所有的case和default都会失效 (This is incorrect. If a case matches and there's no `break`, execution "falls through" to the next case's statements, regardless of whether that next case label matches. `default` is only jumped to if no case matches initially.)
- 所以如果case和default后面没有break就会出现穿透问题 (Fall-through is the correct term)

```c
##include <stdio.h>

int main() {
    int num = 2;
    switch(num){
    case 1:
        printf("星期一\n");
        break;
    case 2:
        printf("星期二\n"); 
    case 3:
        printf("星期三\n"); 
    default: 
        printf("回火星去\n"); 
        break; 
    }
    return 0; 
}
```

- switch中default可以省略

```c
##include <stdio.h>

int main() {
    switch(1){
    case 1:
        printf("星期一\n");
        break;
    case 2:
        printf("星期二\n"); 
        break;
    }
    return 0; 
}
```

- switch中default的位置不一定要写到最后, 无论放到哪都会等到所有case都不匹配才会执行(穿透问题除外) (Correct, but if it's not last and has code, it needs a `break` to prevent falling into subsequent cases if it's matched.)

```c
##include <stdio.h>

int main() {
    switch(3){ 
    case 1:
        printf("星期一\n");
        break;
    default:
        printf("Other,,,\n");
        break; 
    case 2:
        printf("星期二\n"); 
        break;
    }
    return 0; 
}
```

---

- _**if和Switch转换**_
- 看上去if和switch都可以实现同样的功能, 那么在企业开发中我们什么时候使用if, 什么时候使用switch呢?
    - if else if 针对于范围的多路选择 (and complex conditions)
    - switch 是针对点的多路选择 (equality with integer constants)
- 判断用户输入的数据是否大于100

```c
##include <stdio.h>

int main() {
    int a = -1;
    printf("请输入一个整数: "); 
    scanf("%d", &a);
    if(a > 100){
        printf("用户输入的数据大于100\n");
    }else{
        printf("用户输入的数据不大于100\n");
    }
    return 0; 
}
```

```c
##include <stdio.h>

int main() {
    int a = -1;
    printf("请输入一个整数: "); 
    scanf("%d", &a);
    switch (a > 100) { 
       case 1: printf("大于100\n"); break;
       case 0: printf("不大于100\n"); break;
    }
    return 0; 
}
```

---

- 练习
    - 实现分数等级判定

```
要求用户输入一个分数，根据输入的分数输出对应的等级
A 90～100  
B 80～89
C 70～79
D 60～69
E 0～59
```
**Using if-else if (more suitable):**
```c
##include <stdio.h>
int main() {
    int score;
    printf("请输入分数 (0-100): ");
    scanf("%d", &score);
    if (score >= 90 && score <= 100) {
        printf("等级: A\n");
    } else if (score >= 80 && score <= 89) {
        printf("等级: B\n");
    } else if (score >= 70 && score <= 79) {
        printf("等级: C\n");
    } else if (score >= 60 && score <= 69) {
        printf("等级: D\n");
    } else if (score >= 0 && score <= 59) {
        printf("等级: E\n");
    } else {
        printf("无效的分数\n");
    }
    return 0;
}
```
**Using switch (less direct, often involves integer division trick):**
```c
##include <stdio.h>
int main() {
    int score;
    printf("请输入分数 (0-100): ");
    scanf("%d", &score);
    if (score < 0 || score > 100) {
        printf("无效的分数\n");
        return 1;
    }
    switch (score / 10) { 
        case 10: 
        case 9:  
            printf("等级: A\n");
            break;
        case 8:  
            printf("等级: B\n");
            break;
        case 7:  
            printf("等级: C\n");
            break;
        case 6:  
            printf("等级: D\n");
            break;
        default: 
            printf("等级: E\n");
            break;
    }
    return 0;
}
```

- 实现+ - * / 简单计算器
```c
##include <stdio.h>
int main() {
    double num1, num2, result;
    char operator_char; // Renamed from operator
    printf("请输入表达式 (例如: 10 + 20): ");
    scanf("%lf %c %lf", &num1, &operator_char, &num2);

    switch (operator_char) {
        case '+':
            result = num1 + num2;
            printf("%.2lf + %.2lf = %.2lf\n", num1, num2, result);
            break;
        case '-':
            result = num1 - num2;
            printf("%.2lf - %.2lf = %.2lf\n", num1, num2, result);
            break;
        case '*':
            result = num1 * num2;
            printf("%.2lf * %.2lf = %.2lf\n", num1, num2, result);
            break;
        case '/':
            if (num2 != 0) {
                result = num1 / num2;
                printf("%.2lf / %.2lf = %.2lf\n", num1, num2, result);
            } else {
                printf("错误：除数不能为零！\n");
            }
            break;
        default:
            printf("错误：无效的运算符！\n");
            break;
    }
    return 0;
}
```

---

## 13. 循环结构
- C语言中提供了三大循环结构, 分别是while、dowhile和for
- 循环结构是程序中一种很重要的结构。
    - 其特点是,在给定条件成立时,反复执行某程序段, 直到条件不成立为止。
    - 给定的条件称为"循环条件",反复执行的程序段称为"循环体"  
        ![](https://i-blog.csdnimg.cn/blog_migrate/d8791353c99e0a3582f054f821628e6f.png)

#### 13.1. 循环结构 `while`
- 格式:

```c
while (  循环控制条件 ) {
    循环体中的语句;
    能够让循环结束的语句; 
    // ....
}
```

- 构成循环结构的几个条件
    
    - 循环控制条件
        - 循环退出的主要依据,来控制循环到底什么时候退出
    - 循环体
        - 循环的过程中重复执行的代码段
    - 能够让循环结束的语句(递增、递减、真、假等)
        - 能够让循环条件为假的依据,否则退出循环 
- 示例:
    

```c
##include <stdio.h> 
int main() { 
    int count = 0;
    while (count < 3) { 
        printf("发射子弹~哔哔哔哔\n"); 
        count++; 
    }
    return 0; 
}
```

- while循环执行流程
    - 首先会判定"循环控制条件"是否为真, 如果为假直接跳到循环语句后面
    - 如果"循环控制条件"为真, 执行一次循环体, 然后再次判断"循环控制条件"是否为真, 为真继续执行循环体,为假跳出循环
    - 重复以上操作, 直到"循环控制条件"为假为止

```c
##include <stdio.h>
int main(){
    int count = 4;
    while (count < 3) { 
        printf("发射子弹~哔哔哔哔\n"); 
        count++; 
    }
    printf("循环执行完毕\n");
    return 0; 
}
```

```c
##include <stdio.h>
int main(){
    int count = 0;
    while (count < 3) { 
        printf("发射子弹~哔哔哔哔\n"); 
        count++; 
    }
    printf("循环执行完毕\n");
    return 0; 
}
```

---

- _**while循环注意点**_
    - 任何数值都有真假性

```c
##include <stdio.h>
int main(){
    while (1) { 
         printf("发射子弹~哔哔哔哔\n");
         // This is an infinite loop, you might need a break condition or to stop it manually.
         // For example, add: if (some_condition) break;
    }
    return 0; // This line will not be reached in an infinite loop
}
```

- 当while后面只有一条语句时,while后面的大括号可以省略

```c
##include <stdio.h>
int main(){
    int count = 0; // Example to make it not an infinite loop for demonstration
    while (count < 3)  // 
         printf("发射子弹~哔哔哔哔\n");
         // count++; // This would be outside the loop if braces are omitted, leading to infinite loop
    // To make it work as intended with omitted braces (not recommended):
    // while (count < 3) printf("发射子弹~哔哔哔哔 %d\n", count++);
    // Or better:
    // while (count < 3) {
    //      printf("发射子弹~哔哔哔哔\n");
    //      count++;
    // }
    return 0; // Added return
}
```

- 如果while省略了大括号, 那么后面不能定义变量

```c
##include <stdio.h>
int main(){
    int i = 0; // Example
    while (i < 1) { // Added braces to make it valid
         int num = 10; 
         printf("num = %d\n", num); // Added printf to use num
         i++; // To exit loop
    }
    return 0; // Added return
}
```

- C语言中分号(;)也是一条语句, 称之为空语句

```c
##include <stdio.h>
int main(){
    int count = 0;
    while (count < 3);{ // The semicolon after while makes an empty loop body. The block below is separate.
                       // This will be an infinite loop if count is not changed elsewhere or condition isn't met.
                       // If count was 3 or more initially, it would skip the empty loop.
       printf("发射子弹~哔哔哔哔\n"); // This will print if the block is reached.
       count++; 
    }
    return 0; // Added return
}
```

- 最简单的死循环

```c
// 死循环一般在操作系统级别的应用程序会比较多, 日常开发中很少用
// while (1); // This is a valid infinite loop with an empty body.
```

---

- while练习
    - 计算1 + 2 + 3 + …n的和
    - 获取1～100之间 7的倍数的个数

**解答:**
1.  **计算1 + 2 + 3 + …n的和:**
    ```c
    ##include <stdio.h>
    int main() {
        int n, i = 1, sum = 0;
        printf("请输入n的值: ");
        scanf("%d", &n);
        while (i <= n) {
            sum += i;
            i++;
        }
        printf("1到%d的和是: %d\n", n, sum);
        return 0;
    }
    ```
2.  **获取1～100之间 7的倍数的个数:**
    ```c
    ##include <stdio.h>
    int main() {
        int i = 1, count = 0;
        while (i <= 100) {
            if (i % 7 == 0) {
                count++;
            }
            i++;
        }
        printf("1到100之间7的倍数的个数是: %d\n", count);
        return 0;
    }
    ```

---

#### 13.2. 循环结构 `do while`
- 格式:

```c
do {
    循环体中的语句;
    能够让循环结束的语句;
    // ....
} while (循环控制条件 ); // Semicolon is important here
```

- 示例

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int count = 0;
    do {
       printf("发射子弹~哔哔哔哔\n");
       count++;
    }while(count < 10);
    return 0; // Added return
}
```

- do-while循环执行流程
    
    - 首先不管while中的条件是否成立, 都会执行一次"循环体"
    - 执行完一次循环体,接着再次判断while中的条件是否为真, 为真继续执行循环体,为假跳出循环
    - 重复以上操作, 直到"循环控制条件"为假为止
- 应用场景
    
    - 口令校验

```c
##include<stdio.h>
int main()
{
    int num = -1; // Or some value that is not 123456
    do{
        printf("请输入密码,验证您的身份\n");
        scanf("%d", &num);
    }while(123456 != num);
    printf("主人,您终于回来了\n");
    return 0; // Added return
}
```

- while和dowhile应用场景
    - 绝大多数情况下while和dowhile可以互换, 所以能用while就用while (This is a general preference, not a strict rule. `do-while` is better if the loop body *must* execute at least once.)
    - 无论如何都需要先执行一次循环体的情况, 才使用dowhile
    - do while 曾一度提议废除，但是他在输入性检查方面还是有点用的

---

#### 13.3. 循环结构 `for`
- 格式:

```c
for(初始化表达式；循环条件表达式；循环后的操作表达式) {
    循环体中的语句;
}
```

- 示例

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    for(int i = 0; i < 10; i++){
        printf("发射子弹~哔哔哔哔\n");
    }
    return 0; // Added return
}
```

- for循环执行流程
    
    - 首先执行"初始化表达式"，而且在整个循环过程中,***只会执行一次***初始化表达式
    - 接着判断"循环条件表达式"是否为真，为真执行循环体中的语句
    - 循环体执行完毕后，接下来会执行"循环后的操作表达式"，然后再次判断条件是否为真,为真继续执行循环体,为假跳出循环
    - 重复上述过程，直到条件不成立就结束for循环
- for循环注意点:
    
    - 和while一模一样 (Regarding scope of variables declared in initialization if C99+, and general loop control logic)
    - 最简单的死循环`for(;;);`
- for和while应用场景
    
    - while能做的for都能做, 所以企业开发中能用for就用for, 因为for更为灵活 (Often preferred when the number of iterations is known or easily calculable beforehand, or when an iterator is naturally involved.)
    - 而且对比while来说for更节约内存空间 (This is not generally true. Both compile to similar machine code. Variable scope can differ if variables are declared inside the `for` loop's initialization part (C99+), which can be a slight advantage in terms of limiting scope, but not necessarily a significant memory saving in terms of the loop mechanism itself.)

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int count = 0; // 初始化表达式
    while (count < 10) { // 条件表达式
          printf("发射子弹~哔哔哔哔 %d\n", count); // Corrected printf
          count++; // 循环后增量表达式
    }
    // 如果初始化表达式的值, 需要在循环之后使用, 那么就用while
    printf("count = %d\n", count);
    return 0; // Added return
}
```

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    // 注意: 在for循环初始化表达式中定义的变量, 只能在for循环后面的{}中访问 (if declared in C99+ style: for(int count=0;...))
    // 所以: 如果初始化表达式的值, 不需要在循环之后使用, 那么就用for
    // 因为如果初始化表达式的值, 在循环之后就不需要使用了 , 那么用while会导致性能问题 (The performance difference is usually negligible. The main benefit is scope.)
    for (int count = 0; count < 10; count++) {
         printf("发射子弹~哔哔哔哔 %d\n", count); // Corrected printf
    }
    // printf("count = %d\n", count); // Error: count is not defined in this scope
    return 0; // Added return
}
```

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    // 如果需要使用初始化表达式的值, 也可以将初始化表达式写到外面
    int count = 0;
    for (; count < 10; count++) {
         printf("发射子弹~哔哔哔哔 %d\n", count); // Corrected printf
    }
    printf("count = %d\n", count); // count will be 10 here
    return 0; // Added return
}
```

---

#### 13.4. 四大跳转
- C语言中提供了四大跳转语句, 分别是return、break、continue、goto
    
- break:
    
    - 立即跳出switch语句或循环 (the innermost loop or switch)
- 应用场景:
    
    - switch
    - 循环结构  
        ![](https://i-blog.csdnimg.cn/blog_migrate/eaa1f4c18d906d3a28d8728e1452dde9.png)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/f5911e64d3054a78e3175f8ae1b4d349.png)
- break注意点:
    
    - break离开应用范围，存在是没有意义的 (It must be within a loop or switch statement)

```c
// if(1) {
//   break; // 会报错: break statement not within loop or switch
// }
```

- 在多层循环中,一个break语句只向外跳一层

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    while(1) {
      printf("Outer loop start\n"); // Added to show outer loop execution
      while(1) { // Changed from while(2) to while(1) for typical infinite loop
        printf("  Inner loop start\n");
        break;// 只对while(1) (inner)有效, 不会影响while(1) (outer)
        printf("  Inner loop end (not reached)\n"); // Not reached
      }
      printf("Outer loop after inner break\n"); // This will be printed
      // To break the outer loop as well, you'd need another break or a flag.
      break; // Example to break outer loop after one iteration
    }
    printf("Program end\n");
    return 0; // Added return
}
```

- break下面不可以有语句，因为执行不到 (Unreachable code if break is unconditional)

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    while(1){ // Changed from while(2)
      break;
      printf("打我啊!");// 执行不到 (Unreachable code warning)
    }
    return 0; // Added return
}
```

---

- continue
    - 结束***本轮***循环，进入***下一轮***循环 (skips the rest of the current iteration and proceeds to the next iteration's condition check/increment)
- 应用场景:
    - 循环结构  
        ![](https://i-blog.csdnimg.cn/blog_migrate/512ce3ca58549a696adcbf1c805386f8.png)
- continue注意点:
    - continue离开应用范围，存在是没有意义的 (It must be within a loop statement)

```c
// if(1) {
//   continue; // 会报错: continue statement not within a loop
// }
```

---

- goto
    - 这是一个不太值得探讨的话题，goto 会破坏结构化程序设计流程，它将使程序层次不清，且不易读，所以慎用
    - goto 语句，仅能在本函数内实现跳转，不能实现跨函数跳转(短跳转)。但是他在跳出多重循环的时候效率还是蛮高的  
        ![](https://i-blog.csdnimg.cn/blog_migrate/cccc69e4237546db32a364581a5ab520.png)

```c
##include <stdio.h>
int main(){
    int num = 0;
// loop:是定义的标记
loop: // Label definition
    if(num < 10){
        printf("num = %d\n", num);
        num++;
        // goto loop代表跳转到标记的位置
        goto loop;
    }
    return 0; // Added return
}
```

```c
##include <stdio.h>
int main(){
    while (1) {
        while(1){ // Changed from while(2)
            goto lnj; // Jump to label lnj
        }
        // This part of the outer loop will be skipped
    }
lnj: // Label definition
    printf("跳过了所有循环\n"); // Corrected printf
    return 0; // Added return
}
```

---

- return
    - 结束当前函数，将结果返回给调用者
    - 不着急, 放一放,学到函数我们再回头来看它

---

## 14. 循环的应用
#### 14.1. 循环的嵌套
- 循环结构的循环体中存在其他的循环结构，我们称之为循环嵌套
    - 注意: 一般循环嵌套不超过三层 (This is a guideline for readability, not a strict C rule)
    - 外循环执行的次数 * 内循环执行的次数就是内循环总共执行的次数 (If the inner loop runs a fixed number of times per outer loop iteration)
- 格式:

```c
while(条件表达式) {
    // while循环结构 or dowhile循环结构 or for循环结构
}
```

```c
for(初始化表达式；循环条件表达式；循环后的操作表达式) {
    // while循环结构 or dowhile循环结构 or for循环结构
}
```

```c
do {
     // while循环结构 or dowhile循环结构 or for循环结构
} while (循环控制条件 );
```

- 循环优化
    - 在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少 CPU 跨切循环层的次数 (This advice is generally about cache performance and data locality, not just "CPU cross-cutting". If the inner loop accesses data that's contiguous, it can be more cache-friendly. The "longest loop" advice depends on the specific access patterns.)

```c
// Assume a is a 2D array a[100][5]
// int sum = 0; // Initialize sum
// int a[100][5]; // Declaration
// // ... initialize array a ...

// for (int row=0; row<100; row++) { // Outer loop iterates 100 times
//   // 低效率：长循环在最外层 (This statement is context-dependent. If memory is row-major, this is often more efficient.)
//   for (int col=0; col<5; col++ ) { // Inner loop iterates 5 times
//     sum = sum + a[row][col];
//   }
// }
```

```c
// Assume a is a 2D array a[100][5]
// int sum = 0; // Initialize sum
// int a[100][5]; // Declaration
// // ... initialize array a ...

// for (int col=0; col<5; col++ ) { // Outer loop iterates 5 times
//   // 高效率：长循环在最内层 (This can be less efficient if memory is row-major due to cache misses)
//   for (int row=0; row<100; row++) { // Inner loop iterates 100 times
//     sum = sum + a[row][col]; // Accessing a[row][col] in this order might jump around in memory
//   }
// }
```
**Note on loop optimization:** For typical C row-major array storage, iterating through rows in the outer loop and columns in the inner loop (`a[row][col]`) is generally more cache-friendly because it accesses memory sequentially. The provided "optimization" advice might be misleading without more context on the specific hardware or access pattern intended.

- 练习
    - 打印好友列表

```
好友列表1
    好友1
    好友2
好友列表2
    好友1
    好友2
好友列表3
    好友1
    好友2
```

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    for (int i = 0; i < 3; i++) { // Changed to 3 to match output example
        printf("好友列表%d\n", i+1);
        for (int j = 0; j < 2; j++) { // Changed to 2 to match output example
            printf("    好友%d\n", j + 1); // Changed "角色" to "好友" and j to j+1
        }
    }
    return 0; // Added return
}
```

---

#### 14.2. 图形打印
- 一重循环解决线性的问题，而二重循环和三重循环就可以解决平面和立体的问题了
- 打印矩形

```
****
****
****
```

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
// 3行4列
//  外循环控制行数
    for (int i = 0; i < 3; i++) {
    //        内循环控制列数
        for (int j = 0; j < 4; j++) {
            printf("*");
        }
        printf("\n");
    }
    return 0; // Added return
}
```

- 打印三角形
    - 尖尖朝上，改变内循环的条件表达式，让内循环的条件表达式随着外循环的i值变化
    - 尖尖朝下，改变内循环的初始化表达式，让内循环的初始化表达式随着外循环的i值变化 (Or change the condition to decrease with `i`)

```
*
**
***
****
*****
```

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
/*
最多打印5行
最多打印5列
每一行和每一列关系是什么? 列数<=行数
*/
    for(int i = 0; i< 5; i++) { // i goes from 0 to 4 (5 rows)
        for(int j = 0; j <= i; j++) { // j goes from 0 to i (number of stars in current row)
            printf("*");
        }
        printf("\n");
    }
    return 0; // Added return
}
```

```
*****
****
***
**
*
```

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    for(int i = 0; i< 5; i++) { // i goes from 0 to 4 (5 rows)
        for(int j = i; j < 5; j++) { // Prints 5-i stars
            printf("*");
        }
        printf("\n");
    }
    // Alternative for downward triangle:
    // for(int i = 5; i > 0; i--) { // i goes from 5 down to 1
    //     for(int j = 0; j < i; j++) {
    //         printf("*");
    //     }
    //     printf("\n");
    // }
    return 0; // Added return
}
```

- 练习
    - 打印特殊三角形

```
1
12
123
```

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    for (int i = 0; i < 3; i++) { // For 3 rows
        for (int j = 0; j <= i; j++) {
            printf("%d", j+1);
        }
        printf("\n");
    }
    return 0; // Added return
}
```

- 打印特殊三角形

```
1
22
333
```

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    for (int i = 1; i <= 3; i++) { // i represents the number to be printed
        for (int j = 1; j <= i; j++) { // j controls how many times i is printed
            printf("%d", i);
        }
        printf("\n");
    }
    return 0; // Added return
}
```

- 打印特殊三角形 (Isosceles triangle with spaces)

```
--*   (Assuming 5 rows total, this is row 0 with 2 spaces, 1 star)
-***  (Row 1 with 1 space, 3 stars)
***** (Row 2 with 0 spaces, 5 stars)
// The example seems to imply a 3-row triangle based on the pattern.
// Let's assume total rows N = 3.
// Row i (0-indexed): (N-1-i) spaces, (2*i+1) stars.
```

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int N = 3; // Number of rows for the triangle
    for (int i = 0; i < N; i++) { // Iterate through rows (0 to N-1)
        // Print spaces
        for (int j = 0; j < N - 1 - i; j++) {
            printf("-"); // Using '-' for space as in example
        }
        // Print stars
        for (int m = 0; m < 2 * i + 1; m++) {
            printf("*");
        }
        printf("\n");
    }
    return 0; // Added return
}
```

- 打印99乘法表

```
1 * 1 = 1
1 * 2 = 2     2 * 2 = 4
1 * 3 = 3     2 * 3 = 6     3 * 3 = 9
...
```

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    for (int i = 1; i <= 9; i++) { // Outer loop for the second number in multiplication (rows)
        for (int j = 1; j <= i; j++) { // Inner loop for the first number (columns, up to i)
            printf("%d * %d = %-2d \t", j, i, (j * i)); // %-2d for left-aligned 2-digit width
        }
        printf("\n");
    }
    return 0; // Added return
}
```

#### 14.3. C语言程序练习
(This section implies general practice problems combining selection and loops. Specific problems would go here if provided in the original content for this exact spot.)

---

# **第四部分：函数**

## 15. 函数基本概念
- C源程序是由函数组成的
    - 例如: 我们前面学习的课程当中,通过main函数+scanf函数+printf函数+逻辑代码就可以组成一个C语言程序
- C语言不仅提供了极为丰富的库函数, 还允许用户建立自己定义的函数。用户可把自己的算法编写成一个个相对独立的函数，然后再需要的时候调用它
    - 例如:你用C语言编写了一个MP3播放器程序，那么它的程序结构如下图所示
    - ![](https://i-blog.csdnimg.cn/blog_migrate/3096670a2c3c5df37b0349d163d180a4.png)
- 可以说C程序的全部工作都是由各式各样的函数完成的,所以也把C语言称为函数式语言

---

#### 15.1. 什么是函数？
(模块化) - 函数允许我们将一个大的任务分解成若干个小的、可管理的部分（模块）。每个函数执行一个特定的子任务。

#### 15.2. 函数的分类
- 在C语言中可从不同的角度对函数分类
- 从函数定义的角度看,函数可分为库函数和用户定义函数两种
    - _**库函数:**_ 由C语言系统提供,用户无须定义,也不必在程序中作类型说明,只需在程序前包含有该函数原型的头文件即可在程序中直接调用。在前面各章的例题中反复用到printf、scanf、getchar、putchar等函数均属此类
    - ***用户定义函数:*** 由用户按需编写的函数。对于用户自定义函数,不仅要在程序中定义函数本身,而且在主调函数模块中还必须对该被调函数进行类型说明,然后才能使用
- 从函数执行结果的角度来看, 函数可分为有返回值函数和无返回值函数两种
    - _**有返回值函数:**_ 此类函数被调用执行完后将向调用者返回一个执行结果,称为函数返回值。(必须指定返回值类型和使用return关键字返回对应数据)
    - _**无返回值函数:**_ 此类函数用于完成某项特定的处理任务,执行完成后不向调用者返回函数值。(返回值类型为void, 不用使用return关键字返回对应数据)
- 从主调函数和被调函数之间数据传送的角度看,又可分为无参函数和有参函数两种
    - _**无参函数:**_ 在函数定义及函数说明及函数调用中均不带参数。主调函数和被调函数之间不进行参数传送。
    - _**有参函数:**_ 在函数定义及函数说明时都有参数,称为形式参数(简称为形参)。在函数调用时也必须给出参数,称为实际参数(简称为实参)

---

#### 15.3. 函数的定义
- 定义函数的目的
    
    - 将一个常用的功能封装起来，方便以后调用
- 自定义函数的书写格式
    

```c
返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数2，…) {
    函数体;
    返回值; // 如果返回值类型不是void，则需要return语句
}
```

- 示例

```c
int main(){ // main也是一个函数
    printf("hello world\n");
    return 0; // main函数通常返回int
}
```

- 定义函数的步骤
    - 函数名：函数叫什么名字
    - 函数体：函数是干啥的，里面包含了什么代码
    - 返回值类型: 函数执行完毕返回什么和调用者 (如果函数不返回任何值，则为 `void`)
    - 参数列表: 函数需要哪些输入数据 (形式参数)

---

- 无参无返回值函数定义
    
    - 没有返回值时return可以省略 (或者写 `return;`)
    - 格式:
    
    ```c
    void 函数名() { // 参数列表为空
        函数体;
    }
    ```
    
    - 示例:
    
    ```c
    ##include <stdio.h> // Added for printf
    // 1.没有返回值/没有形参
    // 如果一个函数不需要返回任何数据给调用者, 那么返回值类型就是void
    void printRose() {
        printf(" {@}\n");
        printf("  |\n");
        printf(" \\|/\n"); // 注意: \是一个特殊的符号(转义字符), 想输出\必须写两个斜线 (\\)
        printf("  |\n");
      // 如果函数不需要返回数据给调用者, 那么函数中的return可以不写
    }

    int main() { // Added main to call printRose
        printRose();
        return 0;
    }
    ```
    

---

- 无参有返回值函数定义
    
    - 格式:
    
    ```c
    返回值类型 函数名() { // 参数列表为空
        函数体;
        return 值; // 值必须与返回值类型兼容
    }
    ```
    
    - 示例:
    
    ```c
    ##include <stdio.h> // Added for printf, scanf

    int getMax() {
        printf("请输入两个整数, 以逗号隔开, 以回车结束\n");
        int number1, number2;
        scanf("%d,%d", &number1, &number2); // Corrected format specifier to %d
        int max = number1 > number2 ? number1 : number2;
        return max;
    }

    int main() { // Added main to call getMax
        int result = getMax();
        printf("最大值是: %d\n", result);
        return 0;
    }
    ```
    

---

- 有参无返回值函数定义
    
    - 形式参数表列表的格式: `类型 变量名,类型 变量2,......`
    - 格式:
    
    ```c
    void 函数名(参数类型 形式参数1，参数类型 形式参数2，…) {
        函数体;
    }
    ```
    
    - 示例:
    
    ```c
    ##include <stdio.h> // Added for printf

    void printMax(int value1, int value2) {
        int max = value1 > value2 ? value1 : value2;
        printf("max = %d\n", max); // Corrected format specifier to %d
    }

    int main() { // Added main to call printMax
        printMax(10, 20);
        printMax(30, 15);
        return 0;
    }
    ```
    

---

- 有参有返回值函数定义
    
    - 格式:
    
    ```c
    返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数2，…) {
        函数体;
        return 值; // 值必须与返回值类型兼容
    }
    ```
    
    - 示例:
    
    ```c
    ##include <stdio.h> // Added for printf

     int calculateMax(int value1, int value2) { // Renamed to avoid conflict
        int max = value1 > value2 ? value1 : value2;
        return max;
    }

    int main() { // Added main to call calculateMax
        int result = calculateMax(50, 25);
        printf("计算出的最大值是: %d\n", result);
        return 0;
    }
    ```
    

---

- 函数定义注意
- - 函数名称不能相同 (在同一作用域内，具有相同参数列表的函数不能重名。C语言不支持函数重载。)
    
    ```c
    // void test() {
    // }
    // void test() { // 报错: redefinition of 'test'
    // }
    ```
    

---

#### 15.4. 函数的参数和返回值
- 形式参数
    - 在***定义函数***时，函数名后面小括号()中定义的变量称为形式参数，简称形参
    - 形参变量只有在被调用时才分配内存单元,在调用结束时,即刻释放所分配的内存单元。
    - 因此,形参只有在函数内部有效,函数调用结束返回主调函数后则不能再使用该形参变量

```c
int max(int number1, int number2) //  number1 和 number2 是形式参数
{
    return number1 > number2 ? number1 : number2;
}
```

---

- 实际参数
    - 在***调用函数***时, 传入的值称为实际参数，简称实参
    - 实参可以是常量、变量、表达式、函数等,无论实参是何种类型的量,在进行函数调用时,它们都必须具有确定的值,以便把这些值传送给形参
    - 因此应预先用赋值,输入等办法使实参获得确定值

```c
##include <stdio.h> // For max function if defined elsewhere or as example

// Assuming max is defined as:
int max_func(int n1, int n2, int n3) { // Renamed to avoid conflict with previous max
    int temp_max = n1;
    if (n2 > temp_max) temp_max = n2;
    if (n3 > temp_max) temp_max = n3;
    return temp_max;
}

int main() {
    int num = 99;
    // 88, num, 22+44均能得到一个确定的值, 所以都可以作为实参
    // max(88, num, 22+44); // 实际参数 (Assuming a 3-parameter max function)
    int result = max_func(88, num, 22+44); // Calling the example function
    printf("Max result: %d\n", result);
    return 0;
}
```

---

- 形参、实参注意点
    
    - 调用函数时传递的实参个数必须和函数的形参个数必须保持一致
    
    ```c
    // int max(int number1, int number2) { 
    //     return number1 > number2 ? number1 : number2;
    // }
    // int main() {
    //     // 函数需要2个形参, 但是我们只传递了一个实参, 所以报错
    //     max(88); 
    //     return 0;
    // }
    ```
    
- 形参实参类型不一致, 会自动转换为形参类型 (如果可以安全转换，否则可能警告或错误)

```c
##include <stdio.h> // Added for printf

void change(double number1, double number2) {
   // 输出结果: 10.000000, 20.000000
   // 自动将实参(int)转换为double类型后保存
   printf("number1 = %f, number2 = %f\n", number1, number2);
}
int main() {
    change(10, 20); // 10 and 20 (int) are promoted to double
    return 0;
}
```

- 当使用基本数据类型（char、int、float等）作为实参时，实参和形参之间只是值传递，修改形参的值并不影响到实参
    
    ```c
    ##include <stdio.h> // Added for printf

    void change_val(int number1, int number2) { // Renamed to avoid conflict
        number1 = 250; // 修改的是形参的副本，不影响实参
        number2 = 222;
        printf("Inside change_val: number1 = %d, number2 = %d\n", number1, number2);
    }
    int main() {
        int a = 88;
        int b = 99;
        printf("Before change_val: a = %d, b = %d\n", a, b);
        change_val(a, b);
        printf("After change_val: a  = %d, b = %d\n", a, b); // 输出结果: 88, 99
        return 0;
    }
    ```
    

---

- 返回值类型注意点
    
    - 如果没有写返回值类型，默认是int (This was true in older C standards (K&R C, C89 implicitly). C99 and later require an explicit return type. Compilers might warn or error if omitted.)
    
    ```c
    // max(int number1, int number2) { // Implicit int return type (old style)
    //     return number1 > number2 ? number1 : number2;
    // }
    ```
    
- 函数返回值的类型和return实际返回的值类型应保持一致。如果两者不一致,则以返回值类型为准,自动进行类型转换 (if a conversion is possible)

```c
##include <stdio.h> // Added for printf

int height() { // Function declared to return int
    return 3.14; // 3.14 (double) will be truncated to 3 (int)
}
int main() {
  // double temp = height(); // temp will get 3.0
  int temp = height(); // temp will get 3
  printf("temp = %d\n", temp); // 输出结果: 3
  return 0;
}
```

- 一个函数内部可以多次使用return语句，但是return语句后面的代码就不再被执行
    
    ```c
    // int max(int number1, int number2) {
    //     if (number1 > number2) {
    //         return number1;
    //         printf("执行不到1\n"); // 执行不到
    //     } else {
    //         return number2;
    //         printf("执行不到2\n"); // 执行不到
    //     }
    //     // return number1 > number2 ? number1 : number2; // Original logic
    //     printf("执行不到3\n"); // 执行不到
    //     // return 250; // 执行不到 if previous returns are met
    // }
    ```
    

---

#### 15.5. 函数的声明
- 在C语言中，函数的定义顺序是有讲究的：
    - 默认情况下，只有后面定义的函数才可以调用前面定义过的函数 (More accurately, a function must be declared or defined before it is called.)
- 如果想把函数的定义写在main函数后面，而且main函数能正常调用这些函数，那就必须在main函数的前面进行函数的声明, 否则
    - 系统搞不清楚有没有这个函数
    - 系统搞不清楚这个函数接收几个参数
    - 系统搞不清楚这个函数的返回值类型是什么
- 所以函数声明,就是在函数调用之前告诉系统, 该函数叫什么名称, 该函数接收几个参数, 该函数的返回值类型是什么
- 函数的声明格式：
    - 将自定义函数时{}之前的内容拷贝到调用之间即可 (The function signature)
    - 例如: `int max( int a, int b );` (Parameter names are optional in declarations)
    - 或者: `int max( int, int );`

```c
##include <stdio.h> // Added for printf

// 函数声明
void getMax(int v1, int v2); // Or void getMax(int, int);

int main(int argc, const char * argv[]) {
    getMax(10, 20); // 调用函数
    return 0;
}

// 函数实现 (定义)
void getMax(int v1, int v2) {
    int max_val = v1 > v2 ? v1 : v2; // Renamed max to avoid conflict
    printf("max_val = %d\n", max_val); // Corrected format specifier
}
```

- 函数的声明与实现的关系
    - 声明仅仅代表着告诉系统一定有这个函数, 和这个函数的参数、返回值是什么
    - 实现代表着告诉系统, 这个函数具体的业务逻辑是怎么运作的
- 函数声明注意点:
    
    - 函数的实现不能重复, 而函数的声明可以重复 (Though redundant declarations are usually avoided for clarity)
    
    ```c
    ##include <stdio.h> // Added for printf
    // 函数声明
    void getMax_decl(int v1, int v2); // Renamed to avoid conflict
    void getMax_decl(int v1, int v2);
    void getMax_decl(int v1, int v2); // 不会报错
    
    int main(int argc, const char * argv[]) {
        getMax_decl(10, 20); // 调用函数
        return 0;
    }
    // 函数实现
    void getMax_decl(int v1, int v2) {
        int max_val = v1 > v2 ? v1 : v2;
        printf("max_val = %d\n", max_val);
    }
    ```
    
- 函数声明可以写在函数外面,也可以写在函数里面, 只要在调用之前被声明即可 (Declaring inside a function limits its scope to that function, which is less common for general utility functions.)
    
    ```c
    ##include <stdio.h> // Added for printf

    // Forward declaration (prototype)
    void getMax_local_decl(int v1, int v2); 

    int main(int argc, const char * argv[]) {
        // void getMax_local_decl(int v1, int v2); // 函数声明也可以在这里, 但通常在文件顶部或头文件中
        getMax_local_decl(10, 20); // 调用函数
        return 0;
    }
    // 函数实现
    void getMax_local_decl(int v1, int v2) {
        int max_val = v1 > v2 ? v1 : v2;
        printf("max_val = %d\n", max_val);
    }
    ```
    
- 当被调函数的函数定义出现在主调函数之前时,在主调函数中也可以不对被调函数再作声明 (The definition itself serves as a declaration for subsequent calls in the same file.)

```c
##include <stdio.h> // Added for printf

// 函数实现 (定义)
void getMax_defined_first(int v1, int v2) { // Renamed
    int max_val = v1 > v2 ? v1 : v2;
    printf("max_val = %d\n", max_val);
}

int main(int argc, const char * argv[]) {
    getMax_defined_first(10, 20); // 调用函数 (declaration is implicit from definition above)
    return 0;
}
```

- 如果被调函数的返回值是整型时,可以不对被调函数作说明,而直接调用 (This was a feature of older C standards (implicit int). Modern C (C99 and later) requires functions to be declared before use, regardless of return type. Compilers will usually warn or error if a function is called without a prior declaration.)
    
    ```c
    ##include <stdio.h> // Added for printf

    // It's best practice to declare getMin before main or define it before main.
    // int getMin(int num1, int num2); // Proper declaration

    int main(int argc, const char * argv[]) {
        // int res = getMin(5, 3); // Calling without declaration might work with warnings on older compilers
                               // or error on modern compilers.
        // printf("result = %d\n", res );
        printf("Calling getMin without declaration is not recommended.\n");
        return 0;
    }
    // int getMin(int num1, int num2) { // 返回int, 不用声明 (This comment is misleading for modern C)
    //     return num1 < num2 ? num1 : num2;
    // }
    ```
    

---

#### 15.6. `main` 函数分析
- main的含义:
    - main是函数的名称, 和我们自定义的函数名称一样, 也是一个标识符
    - 只不过main这个名称比较特殊, 程序已启动就会自动调用它
- return 0;的含义:
    - 告诉系统main函数是否正确的被执行了
    - 如果main函数的执行正常, 那么就返回0 (by convention, indicates success)
    - 如果main函数执行不正常, 那么就返回一个非0的数 (by convention, indicates an error)
- 返回值类型:
    - 一个函数return后面写的是什么类型, 函数的返回值类型就必须是什么类型, 所以写int (The standard signature for `main` is `int main(void)` or `int main(int argc, char *argv[])`. Returning `int` is standard.)
- 形参列表的含义
    - `int argc` : (argument count)
        - 系统在启动程序时调用main函数时传递给argv的值的个数 (More accurately, it's the number of command-line arguments passed to the program, including the program name itself.)
    - `const char * argv[]` : (argument vector)
        - 系统在启动程序时传入的的值, 默认情况下系统只会传入一个值, 这个值就是main函数执行文件的路径 (It's an array of strings. `argv[0]` is typically the program name, `argv[1]` is the first argument, and so on. `argv[argc]` is guaranteed to be a null pointer.)
        - 也可以通过命令行或项目设置传入其它参数  
            ![](https://i-blog.csdnimg.cn/blog_migrate/27f9c561f87a4d0147cf777dc1021874.png)  
            ![](https://i-blog.csdnimg.cn/blog_migrate/7f07c3b3f4c3869cc4db2204fae6ab05.png)

---

- 函数练习
    - 写一个函数从键盘输入三个整型数字,找出其最大值
    - 写一个函数求三个数的平均值

**解答:**
1.  **找出三个整数的最大值:**
    ```c
    ##include <stdio.h>

    int findMaxOfThree() {
        int n1, n2, n3, max_val;
        printf("请输入三个整数 (用空格分隔): ");
        scanf("%d %d %d", &n1, &n2, &n3);
        max_val = n1;
        if (n2 > max_val) {
            max_val = n2;
        }
        if (n3 > max_val) {
            max_val = n3;
        }
        return max_val;
    }

    int main() {
        int maxResult = findMaxOfThree();
        printf("三个数中的最大值是: %d\n", maxResult);
        return 0;
    }
    ```
2.  **求三个数的平均值:**
    ```c
    ##include <stdio.h>

    double averageOfThree() {
        int n1, n2, n3;
        printf("请输入三个整数 (用空格分隔): ");
        scanf("%d %d %d", &n1, &n2, &n3);
        return (double)(n1 + n2 + n3) / 3.0; // Cast to double for floating point division
    }

    int main() {
        double avgResult = averageOfThree();
        printf("三个数的平均值是: %.2f\n", avgResult);
        return 0;
    }
    ```

---

#### 15.7. 递归函数
- 什么是递归函数?
    
    - 一个函数在它的函数体内调用它自身称为递归调用
    
    ```c
    // void function(int x){
    //     function(x); // This would be infinite recursion without a base case
    // }
    ```
    
- 递归函数构成条件
    - 自己搞自己 (A function calls itself)
    - 存在一个条件能够让递归结束 (Base case)
    - 问题的规模能够缩小 (Recursive step moves towards the base case)
- 示例:
    - 获取用户输入的数字, 直到用户输入一个正数为止

**使用循环 (非递归):**
```c
##include <stdio.h> // Added for printf, scanf

void getNumber(){
    int number = -1;
    while (number < 0) {
        printf("请输入一个正数\n");
        scanf("%d", &number);
    }
    printf("number = %d\n", number);
}

// int main() { // Example usage
//     getNumber();
//     return 0;
// }
```

**使用递归:**
```c
##include <stdio.h> // Added for printf, scanf

void getNumber2(){
    int number = -1; // This variable is local to each call, which is not ideal for this problem
                    // A better recursive approach might pass the number or use a static/global.
                    // The original example's logic is a bit flawed for simple input validation via recursion.
    printf("请输入一个正数 (递归版本)\n");
    scanf("%d", &number);
    if (number < 0) {
        // 负数
        getNumber2(); // Recursive call
    }else{
        // 正数
       printf("number = %d\n", number);
    }
}

// int main() { // Example usage
//     getNumber2();
//     return 0;
// }
```
**Note on recursive `getNumber2`:** The `number` variable is local to each call. If the user enters a negative number, `getNumber2` calls itself, and that new call gets a new `number`. When the base case (positive number) is finally met in a deeper recursive call, only that call prints. The previous calls don't "see" the final positive number. For this specific problem, a loop is more straightforward. A recursive solution would typically involve returning the valid number or passing a pointer.

- 递归和循环区别
    
    - 能用循环实现的功能,用递归都可以实现 (Theoretically, yes, but sometimes one is much more natural or efficient.)
    - 递归常用于"回溯", “树的遍历”,"图的搜索"等问题 (And problems that have a naturally recursive structure, like factorial, Fibonacci sequence)
    - 但代码理解难度大 (can be, for complex recursion), 内存消耗大(易导致栈溢出 - due to function call overhead and stack frames), 所以考虑到代码理解难度和内存消耗问题, 在企业开发中一般能用循环都不会使用递归 (This is a common guideline, especially for performance-critical or deep recursion scenarios.)
- 递归练习
    
    - 有5个人坐在一起,问第5个人多少岁?他说比第4个人大两岁。问 第4个人岁数,他说比第3个人大两岁。问第3个人,又说比第2个 人大两岁。问第2个人,说比第1个人大两岁。最后问第1个人, 他说是10岁。请问第5个人多大?
    - 用递归法求N的阶乘
    - 设计一个函数用来计算B的n次方

**解答:**
1.  **5个人年龄问题:**
    ```c
    ##include <stdio.h>
    int getAge(int personNumber) {
        if (personNumber == 1) {
            return 10; // Base case: 1st person is 10 years old
        } else {
            return getAge(personNumber - 1) + 2; // Recursive step
        }
    }
    int main() {
        printf("第5个人的年龄是: %d岁\n", getAge(5));
        return 0;
    }
    ```
2.  **N的阶乘:**
    ```c
    ##include <stdio.h>
    long long factorial(int n) { // Use long long for larger results
        if (n < 0) {
            printf("阶乘未定义负数。\n");
            return -1; // Indicate error
        }
        if (n == 0 || n == 1) {
            return 1; // Base case: 0! = 1, 1! = 1
        } else {
            return (long long)n * factorial(n - 1); // Recursive step
        }
    }
    int main() {
        int num = 5;
        printf("%d的阶乘是: %lld\n", num, factorial(num));
        num = 0;
        printf("%d的阶乘是: %lld\n", num, factorial(num));
        num = 10;
        printf("%d的阶乘是: %lld\n", num, factorial(num));
        return 0;
    }
    ```
3.  **B的n次方:**
    ```c
    ##include <stdio.h>
    double power(double base, int exp) {
        if (exp == 0) {
            return 1.0; // Base case: b^0 = 1
        } else if (exp > 0) {
            return base * power(base, exp - 1); // Recursive step for positive exponent
        } else { // Negative exponent
            return 1.0 / power(base, -exp); // b^-n = 1 / b^n
        }
    }
    int main() {
        printf("2的3次方是: %.2f\n", power(2.0, 3));
        printf("5的0次方是: %.2f\n", power(5.0, 0));
        printf("2的-2次方是: %.2f\n", power(2.0, -2));
        return 0;
    }
    ```

---

## 16. 作用域与存储类别
#### 16.1. 全局变量和局部变量
- 变量作用域基本概念
    - 变量作用域：变量的可用范围
    - 按照作用域的不同，变量可以分为：局部变量和全局变量
- 局部变量
    - 定义在函数内部的变量以及函数的形参, 我们称为局部变量
    - 作用域：从定义的那一行开始, 直到遇到}结束或者遇到return为止
    - 生命周期: 从程序运行到定义哪一行开始分配存储空间到程序离开该变量所在的作用域 (More precisely, when the block/function they are defined in is entered, and destroyed when exited.)
    - 存储位置: 局部变量会存储在内存的栈区中 (Typically, for `auto` variables)
    - 特点：
        - 相同作用域内不可以定义同名变量
        - 不同作用范围可以定义同名变量，内部作用域的变量会覆盖外部作用域的变量 (Shadowing)
- 全局变量
    - 定义在函数外面的变量称为全局变量
    - 作用域范围：从定义哪行开始直到文件结尾 (And can be accessed by other files if declared with `extern`)
    - 生命周期:程序一启动就会分配存储空间,直到程序结束 (Static storage duration)
    - 存储位置：静态存储区 (Data segment or BSS segment)
    - 特点: 多个同名的全局变量指向同一块存储空间 (This is true if they are defined in different files and not declared `static`. If defined in the same file, it's a redefinition error. If `static`, each file has its own copy.)

---

#### 16.2. 变量的作用域
- 块作用域 (Block Scope):
    - 在 `{}` 内声明的变量，其作用域从声明点到块的末尾 `}`。
    - 函数参数也具有块作用域，其作用域是整个函数体。
- 函数作用域 (Function Scope):
    - 仅适用于标签 (labels for `goto` statements)。标签在整个函数内都是可见的，无论其声明在何处。
- 文件作用域 (File Scope):
    - 在所有函数之外声明的标识符（变量或函数）具有文件作用域。
    - 它们从声明点到文件末尾都是可见的。
    - 全局变量和 `static` 全局变量具有文件作用域。

#### 16.3. `auto` 和 `register` 关键字
- auto关键字(忘记)
    - 只能修饰局部变量, 局部变量如果没有其它修饰符, 默认就是auto的
    - 特点: 随用随开, 用完即销 (Automatic storage duration: created when block is entered, destroyed when exited)

```c
auto int num; // 等价于 int num; (within a function)
```

- register关键字(忘记)
    - 只能修饰局部变量, 原则上将内存中变量提升到CPU寄存器中存储, 这样访问速度会更快
    - 但是由于CPU寄存器数量相当有限, 通常不同平台和编译器在优化阶段会自动转换为auto (The `register` keyword is a hint to the compiler; the compiler is free to ignore it. Modern compilers are often better at register allocation than manual hints.)
    - 不能对 `register` 变量取地址 (`&`).

```c
register int num; 
```

#### 16.4. `static` 关键字
- **对局部变量的作用**
    - 延长局部变量的生命周期,从程序启动到程序退出 (Static storage duration),但是它并没有改变变量的作用域 (Still block scope)
    - 定义变量的代码在整个程序运行期间仅仅会执行一次 (Initialization is done once, before program execution or when the function is first called, depending on the compiler and context. The variable retains its value between function calls.)

```c
##include <stdio.h>
void test_static_local(); // Declaration
int main()
{
    test_static_local();
    test_static_local();
    test_static_local();

    return 0;
}
void test_static_local(){ // Renamed to avoid conflict
    static int num = 0; // 局部变量, 但具有静态存储期
    num++; 
    // 如果不加static输出 1 1 1
    // 如果添加static输出 1 2 3
    printf("num = %d\n", num); 
}
```

- **对全局变量的作用**
- 全局变量分类：

- 内部变量 (Internal Linkage):只能在本文件中访问的变量. 使用 `static` 修饰的全局变量。
- 外部变量 (External Linkage):可以在其他文件中访问的变量,默认所有全局变量都是外部变量 (if not declared `static`).

- 默认情况下多个同名的全局变量共享一块空间 (This is problematic and leads to linker errors if multiple definitions exist. One definition rule applies.), 这样会导致全局变量污染问题
- 如果想让某个全局变量只在某个文件中使用, 并且不和其他文件中同名全局变量共享同一块存储空间 (or rather, to prevent name clashes and limit visibility), 那么就可以使用static

**文件 A (a.c):**
```c
// A文件中的代码
// int num; // 和B文件中的num共享 (If B also defines num, it's a linker error)
// To share, B should use 'extern int num;' and A defines it.

// Example for static global:
static int num_a_static = 100; // Only visible in a.c

void test_a(){
    // printf("ds.c中的 num = %d\n", num); // Assuming num is defined elsewhere and externed
    printf("a.c: num_a_static = %d\n", num_a_static);
}
```

**文件 B (b.c):**
```c
// B文件中的代码
##include <stdio.h>
// ##include "ds.h" // Assuming ds.h declares test() from A

// extern int num; // To use num defined in A (if it's not static)
// int num; // This would be a separate global variable in B if A's num is static,
           // or a redefinition error if A's num is also global and not static.

// Example for static global in B:
static int num_b_static = 200;

// extern void test_a(); // If test_a is defined in a.c and not static

int main()
{
    // num = 666; // Modifies the shared num if properly set up
    // test(); // Calls test from A
    
    // test_a(); // Call function from a.c
    printf("b.c: num_b_static = %d\n", num_b_static);
    // printf("a.c's num_a_static is not accessible here directly.\n");
    return 0;
}
```
**Corrected Example for `static` global variable:**

**File `file1.c`:**
```c
##include <stdio.h>
static int file_local_var = 10; // Visible only within file1.c

void print_file1_var() {
    printf("From file1.c: file_local_var = %d\n", file_local_var);
    file_local_var++;
}
```

**File `file2.c`:**
```c
##include <stdio.h>
static int file_local_var = 20; // Different variable, visible only within file2.c
// extern void print_file1_var(); // Declaration if print_file1_var is not static

void print_file2_var() {
    printf("From file2.c: file_local_var = %d\n", file_local_var);
    file_local_var++;
}

// Example main in file2.c
// int main() {
//     print_file1_var(); // Call function from file1
//     print_file1_var();
//     print_file2_var();
//     print_file2_var();
//     return 0;
// }
```
If `main` is in a separate file, it would need declarations for `print_file1_var` and `print_file2_var` (if they are not `static`).

---

#### 16.5. `extern` 关键字
- 对局部变量的作用
    - extern不能用于局部变量 (in the sense of defining or accessing a local variable from another scope using `extern`. `extern` is about linkage.)
    - extern代表声明一个变量, 而不是定义一个变量, 变量只有定义才会开辟存储空间
    - 所以如果是局部变量, 虽然提前声明有某个局部变量, 但是局部变量只有执行到才会分配存储空间 (This is confusing. `extern` with local variables is not standard usage for defining or accessing them. Local variables are `auto` by default.)

```c
##include <stdio.h>

// extern int num; // This would declare a global variable num expected to be defined elsewhere.

int main()
{
    // extern int num; // This declares that num is defined globally or in another file.
                      // It does not make a local variable.
    // num = 998; // This would refer to the global num.
    
    int num_local; // This is a local variable, distinct from any global 'num'.
    // num_local = 998;
    // printf("num_local = %d\n", num_local); // Using uninitialized local variable is risky.
    return 0;
}
// int num; // If this global definition exists, the extern declaration in main would refer to it.
```
The original example for `extern` with local variables is misleading. `extern` is used to declare a variable that is defined elsewhere (typically globally in another file or later in the same file).

- 对全局变量的作用
    - 声明一个全局变量, 代表告诉编译器我在其它地方定义了这个变量, 你可以放心使用 (Correct. It provides a declaration for a variable with external linkage.)

**File `def.c`:**
```c
int global_num = 55; // Definition
```
**File `use.c`:**
```c
##include <stdio.h>
extern int global_num; // Declaration: global_num is defined elsewhere

int main() {
    printf("global_num = %d\n", global_num); // Accesses global_num from def.c
    global_num = 998; 
    printf("global_num is now = %d\n", global_num);
    return 0;
}
```

---

#### 16.6. `static` 与 `extern` 对函数的作用
- 内部函数 (Internal Linkage):只能在本文件中访问的函数. Achieved by declaring/defining the function with `static`.
    
- 外部函数 (External Linkage):可以在本文件中以及其他的文件中访问的函数. This is the default for functions.
    
- 默认情况下所有的函数都是外部函数
    
- **static 作用**
    
    - 声明一个内部函数 (Makes the function's name local to the current translation unit/file)

```c
static int sum_internal(int num1,int num2); // Declaration of an internal function
```

- 定义一个内部函数

```c
static int sum_internal(int num1,int num2) // Definition of an internal function
{
  return num1 + num2;
}
```

- **extern作用**
    - 声明一个外部函数 (This is often redundant as functions are `extern` by default, but can be used for explicitness or to forward-declare a function defined later in the same file or in another file.)

```c
extern int sum_external(int num1,int num2); // Declaration of an external function
```

- - 定义一个外部函数 (The `extern` keyword is optional in a function definition as functions have external linkage by default unless `static` is used.)

```c
// extern int sum_external(int num1,int num2) // 'extern' is redundant here
int sum_external(int num1,int num2) // Default is external linkage
{
  return num1 + num2;
}
```

> - 注意点:
> - 由于默认情况下所有的函数都是外部函数, 所以extern一般会省略 (in definitions and often in declarations unless it's a forward declaration within the same file for a function defined later, or for clarity when linking across files).
> - 如果只有函数声明添加了static与extern, 而定义中没有添加static与extern, 那么无效 (The linkage is determined by the definition. If a function is defined as `static`, it has internal linkage, even if an `extern` declaration for it exists elsewhere (which would be a contradiction). If defined without `static`, it has external linkage. The first declaration (or definition) sets the linkage.)

---

# **第五部分：数组与字符串**

## 17. 数组
#### 17.1. 数组的基本概念
- 数组，从字面上看，就是一组数据的意思，没错，数组就是用来存储一组数据的
    
    - 在C语言中,数组属于**构造数据类型**
- 数组的几个名词
    
    - 数组:一组`相同数据类型`数据的`有序`的集合
    - 数组元素: 构成数组的每一个数据。
    - 数组的下标: 数组元素位置的索引(从0开始)
- 数组的应用场景
    
    - 一个int类型的变量能保存一个人的年龄，如果想保存整个班的年龄呢？
        - 第一种方法是定义很多个int类型的变量来存储
        - 第二种方法是只需要定义一个int类型的数组来存储

```c
##include <stdio.h>

int main(int argc, const char * argv[]) {
    /*
    // 需求: 保存2个人的分数
    int score1 = 99;
    int score2 = 60;
    
    // 需求: 保存全班同学的分数(130人)
    int score3 = 78;
    int score4 = 68;
    ...
    int score130 = 88;
    */
    // 数组: 如果需要保存`一组``相同类型`的数据, 就可以定义一个数组来保存
    // 只要定义好一个数组, 数组内部会给每一块小的存储空间一个编号, 这个编号我们称之为 索引, 索引从0开始
    // 1.定义一个可以保存3个int类型的数组
    int scores[3];
    
    // 2.通过数组的下标往数组中存放数据
    scores[0] = 998;
    scores[1] = 123;
    scores[2] = 567;
   
    // 3.通过数组的下标从数组中取出存放的数据
    printf("%d\n", scores[0]); // Corrected format specifier
    printf("%d\n", scores[1]);
    printf("%d\n", scores[2]);
    return 0;
}
```

---

#### 17.2. 定义数组
- 元素类型 数组名[元素个数];

```c
// int 元素类型
// ages 数组名称
// [10] 元素个数
int ages[10];
```

---

#### 17.3. 初始化数组
- **定义的同时初始化**
- 指定元素个数,完全初始化
    - 其中在{ }中的各数据值即为各元素的初值,各值之间用逗号间隔

```c
int ages[3] = {4, 6, 9};
```

- 不指定元素个数,完全初始化
    - 根据大括号中的元素的个数来确定数组的元素个数

```c
int nums[] = {1,2,3,5,6}; // Size will be 5
```

- 指定元素个数,部分初始化
    - 没有显式初始化的元素,那么系统会自动将其初始化为0 (For static and global arrays. For local (auto) arrays, uninitialized elements contain indeterminate values unless explicitly initialized to 0, e.g., `int nums[10] = {0};` to zero all.)
    - If any element is initialized, all other elements are initialized to zero (for arrays with static storage duration or if an initializer list is provided for an automatic array).

```c
int nums[10] = {1,2}; // nums[0]=1, nums[1]=2, nums[2] through nums[9] are 0.
```

- 指定元素个数,部分初始化 (Designated initializers - C99)

```c
int nums[5] = {[4] = 3,[1] = 2}; // nums[1]=2, nums[4]=3, others are 0.
```

- 不指定元素个数,部分初始化 (Designated initializers - C99)

```c
int nums[] = {[4] = 3}; // Size will be 5 (index 4 is the highest specified). nums[4]=3, others 0.
```

- **先定义后初始化** (This means assigning values one by one, not using an initializer list after definition)

```c
int nums[3];
nums[0] = 1;
nums[1] = 2;
nums[2] = 3;
```

- **没有初始化会怎样?**
    - 如果定义数组后,没有初始化,数组中是有值的,是随机的垃圾数 (For local/automatic arrays). 全局或静态数组元素默认初始化为0.
    - 所以如果想要正确使用数组应该要进行初始化。

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int nums[5]; // Local array, elements have indeterminate values
    printf("%d\n", nums[0]);
    printf("%d\n", nums[1]);
    printf("%d\n", nums[2]);
    printf("%d\n", nums[3]);
    printf("%d\n", nums[4]);
    // 输出结果: (Indeterminate values, could be anything)
    // 0
    // 0
    // 1606416312
    // 0
    // 1606416414
    return 0; // Added return
}
```

- 注意点:

- 使用数组时不能超出数组的索引范围使用, 索引从0开始, 到元素个数-1结束
- 使用数组时不要随意使用未初始化的元素, 有可能是一个随机值 (for local arrays)
- 对于数组来说, 只能在定义的同时初始化多个值 (using an initializer list `{...}`), 不能先定义再用 initializer list 初始化多个值

```c
// int ages[3];
// ages = {4, 6, 9}; // 报错: assignment to expression with array type
```

---

#### 17.4. 数组的使用
- 通过下标（索引）访问：

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int ages[3]; // Declaration
    // 找到下标为0的元素, 赋值为10
    ages[0]=10;
    ages[2]=30; // Example assignment
    // 取出下标为2的元素保存的值
    int a = ages[2];
    printf("a = %d\n", a); // Corrected format specifier
    return 0; // Added return
}
```

---

#### 17.5. 数组的遍历
- 数组的遍历:遍历的意思就是有序地查看数组的每一个元素

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int ages[4] = {19, 22, 33, 13};
    for (int i = 0; i < 4; i++) {
        printf("ages[%d] = %d\n", i, ages[i]);
    }
    return 0; // Added return
}
```

---

#### 17.6. 数组长度计算方法
- 因为数组在内存中占用的字节数取决于其存储的数据类型和数据的个数
    - 数组所占用存储空间 = 一个元素所占用存储空间 * 元素个数(数组长度)
- 所以计算数组长度可以使用如下方法  
    数组的长度 = 数组占用的总字节数 / 数组元素占用的字节数

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int ages[4] = {19, 22, 33, 13};
    int length =  sizeof(ages)/sizeof(int); // Or sizeof(ages[0]) for more generality
    printf("length = %d\n", length);
// 输出结果: 4
    return 0; // Added return
}
```

---

#### 17.7. 练习
- 正序输出(遍历)数组

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int ages[4] = {19, 22, 33, 13};
    for (int i = 0; i < 4; i++) {
        printf("ages[%d] = %d\n", i, ages[i]);
    }
    return 0; // Added return
}
```

- 逆序输出(遍历)数组

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int ages[4] = {19, 22, 33, 13};
    for (int i = 3; i >=0; i--) {
        printf("ages[%d] = %d\n", i, ages[i]);
    }
    return 0; // Added return
}
```

- 从键盘输入数组长度,构建一个数组,然后再通过for循环从键 盘接收数字给数组初始化。并使用for循环输出查看
    (Note: Standard C does not allow variable-length arrays (VLAs) to be initialized with an initializer list directly after declaration if the size is determined at runtime. You'd typically read into them element by element.)
    ```c
    ##include <stdio.h>
    int main() {
        int length;
        printf("请输入数组长度: ");
        scanf("%d", &length);

        if (length <= 0) {
            printf("无效的数组长度。\n");
            return 1;
        }

        int arr[length]; // Variable Length Array (VLA - C99 feature)

        printf("请输入 %d 个整数:\n", length);
        for (int i = 0; i < length; i++) {
            printf("元素 %d: ", i);
            scanf("%d", &arr[i]);
        }

        printf("数组元素为: ");
        for (int i = 0; i < length; i++) {
            printf("%d ", arr[i]);
        }
        printf("\n");
        return 0;
    }
    ```

---

#### 17.8. 数组内部存储细节

- 存储方式:
    
    - 1)内存寻址从大到小, 从高地址开辟一块连续没有被使用的内存给数组 (This describes stack allocation where the stack pointer typically moves downwards. Heap allocation is different. Array elements themselves are contiguous.)
    - 2)从分配的连续存储空间中, 地址小的位置开始给每个元素分配空间 (Correct, array elements are stored contiguously, typically starting from a lower address and moving to higher addresses for subsequent elements.)
    - 3)从每个元素分配的存储空间中, 地址最大的位置开始存储数据 (This is about byte order within a multi-byte element, i.e., endianness. For a single `char`, it's just one byte. For an `int`, it depends on whether the system is big-endian or little-endian.)
    - 4)用数组名指向整个存储空间最小的地址 (Correct, the array name, when used in most expressions, decays to a pointer to its first element, which is at the lowest address of the array's contiguous block.)
- 示例
    

```c
##include <stdio.h>
int main()
{
    // int num = 9; // This variable is not directly related to the array example below it.
    char cs[] = {'l','n','j'}; // cs will have size 3, no null terminator automatically.
    printf("cs = %p\n", (void*)cs);       // Address of the first element
    printf("&cs[0] = %p\n", (void*)&cs[0]); // Address of the first element
    printf("&cs[1] = %p\n", (void*)&cs[1]); // Address of the second element
    printf("&cs[2] = %p\n", (void*)&cs[2]); // Address of the third element

    int nums[] = {2, 6};
    printf("nums = %p\n", (void*)nums);      // Address of the first element
    printf("&nums[0] = %p\n", (void*)&nums[0]);// Address of the first element
    printf("&nums[1] = %p\n", (void*)&nums[1]);// Address of the second element
    
    return 0;
}
```

![](https://i-blog.csdnimg.cn/blog_migrate/099466ea9264df83cf4fe44abd7a46c9.png)

> - 注意:字符在内存中是以对应ASCII码值的二进制形式存储的,而非上述的形式。 (The diagram shows characters, but they are stored as their ASCII/numerical values in binary.)

---

#### 17.9. 数组的越界问题
- 数组越界导致的问题
    - 约错对象 (Accessing/modifying unintended data)
    - 程序崩溃 (Segmentation fault or other runtime errors)

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    char cs1[2] = {1, 2};
    char cs2[3] = {3, 4, 5};
    // cs2[3] = 88; // 注意:这句访问到了不属于cs2的内存 (cs2 valid indices are 0, 1, 2)
                  // This is undefined behavior. It might overwrite cs1[0] or cause a crash,
                  // depending on memory layout and compiler.
    // To demonstrate the potential issue if memory is laid out sequentially (cs1 after cs2 on stack):
    // If cs2 is at a lower address than cs1, cs2[3] could be cs1[0] if char is 1 byte.
    // Let's assume cs1 is after cs2 for the example's output to make sense.
    // This is highly dependent on compiler and stack allocation order.
    
    // To illustrate the original example's point, let's assume a specific layout:
    // char dummy[1]; // to potentially separate them or influence layout
    // char cs2[3] = {3, 4, 5};
    // char cs1[2] = {1, 2}; 
    // cs2[3] = 88; // If cs2[3] happens to be the memory location of cs1[0]

    // The original output implies cs2[3] overwrote cs1[0].
    // This is not guaranteed and is undefined behavior.
    // For a predictable example of overwriting:
    char buffer[5] = {'A', 'B', 'C', 'D', 'E'};
    // buffer[5] = 'X'; // Out of bounds write
    // printf("buffer[0] = %c\n", buffer[0]); // Might still be 'A' or crash

    printf("数组越界是未定义行为，结果不可预测。\n");
    // The original example's output of 88 for cs1[0] after cs2[3]=88
    // would only happen if cs2[3] coincidentally mapped to cs1[0]'s memory location.
    return 0; // Added return
}
```

> 为什么上述会输出88, 自己按照"数组内部存储细节"画图脑补 (The output of 88 is due to undefined behavior where writing past the bounds of `cs2` happened to overwrite the memory allocated for `cs1[0]`. This is not reliable and depends on the compiler's memory layout.)

---

#### 17.10. 数组注意事项
- 在定义数组的时候[]里面只能写整型常量或者是返回整型常量的表达式 (Or integer constant expressions. VLAs (Variable Length Arrays) since C99 allow non-constant integer expressions, but they have limitations.)

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    // int ages4['A'] = {19, 22, 33}; // 'A' is 65, so this is ages4[65]. Valid but large.
    // printf("ages4[0] = %d\n", ages4[0]);

    int ages5[5 + 5] = {19, 22, 33}; // ages5[10]
    printf("ages5[0] = %d\n", ages5[0]); // Will be 19, others 0.

    // int ages6['A' + 5] = {19, 22, 33}; // 'A'+5 is 70. ages6[70].
    // printf("ages6[0] = %d\n", ages6[0]);
    return 0; // Added return
}
```

- 错误写法

```c
// 没有指定元素个数，错误 (Unless initialized, e.g., int a[] = {1,2,3};)
// int a[]; 

// []中不能放变量 (This is a VLA, allowed in C99+ but not C89. Some compilers might support as extension.)
// int number = 10;
// int ages[number]; 
// printf("%d\n", ages[4]); // Using uninitialized VLA element

// int number = 10;
// int ages2[number] = {19, 22, 33}; // Initialization of VLAs is not allowed. Direct error.

// 只能在定义数组的时候进行一次性（全部赋值）的初始化 (using initializer list)
// int ages3[5];
// ages3 = {19, 22, 33}; // Error: array type is not assignable

// 一个长度为n的数组,最大下标为n-1, 下标范围:0~n-1
// int ages4[4] = {19, 22, 33}; // ages4 has elements ages4[0] to ages4[3]
// ages4[8]; // 数组角标越界 (Accessing ages4[8] is out of bounds)
```

- 练习
    - 从键盘录入当天出售BTC的价格并计算出售的BTC的总价和平均价(比如说一天出售了10个比特币)
    ```c
    ##include <stdio.h>
    ##define MAX_SALES 100 // Define a maximum number of sales

    int main() {
        int num_sales;
        printf("请输入当天出售BTC的数量 (最多 %d): ", MAX_SALES);
        scanf("%d", &num_sales);

        if (num_sales <= 0 || num_sales > MAX_SALES) {
            printf("无效的出售数量。\n");
            return 1;
        }

        double prices[MAX_SALES];
        double total_price = 0.0;
        double average_price;

        printf("请输入 %d 个BTC的出售价格:\n", num_sales);
        for (int i = 0; i < num_sales; i++) {
            printf("第 %d 个BTC价格: ", i + 1);
            scanf("%lf", &prices[i]);
            total_price += prices[i];
        }

        average_price = total_price / num_sales;

        printf("\n--- 总结 ---\n");
        printf("总出售数量: %d\n", num_sales);
        printf("总销售额: %.2f\n", total_price);
        printf("平均售价: %.2f\n", average_price);

        return 0;
    }
    ```

---

## 18. 数组与函数
- 数组可以作为函数的参数使用,数组用作函数参数有两种形式:
    - ￼一种是把数组元素作为实参使用
    - ￼一种是把数组名作为函数的形参和实参使用

---

#### 18.1. 数组元素作为函数参数
- 数组的元素作为函数实参，与同类型的简单变量作为实参一样，如果是基本数据类型, 那么形参的改变不影响实参 (Pass-by-value)

```c
##include <stdio.h> // Added for printf

void change(int val)// int val = ages[0] (which is 1)
{
    val = 55; // Modifies the local copy 'val'
    printf("Inside change: val = %d\n", val);
}
int main(int argc, const char * argv[])
{
    int ages[3] = {1, 5, 8};
    printf("Before change: ages[0] = %d\n", ages[0]);// 1
    change(ages[0]); // Pass the value of ages[0]
    printf("After change: ages[0] = %d\n", ages[0]);// 1 (original ages[0] is unchanged)
    return 0; // Added return
}
```

> - 用数组元素作函数参数不要求形参也必须是数组元素 (Correct, the parameter is just a variable of the element's type.)

---

#### 18.2. 数组名作为函数参数
- 在C语言中,数组名除作为变量的标识符之外,数组名还代表了该数组在内存中的起始地址 (When an array name is passed to a function, it decays into a pointer to its first element),因此,当数组名作函数参数时,实参与形参之间不是"值传递",而是"地址传递" (More accurately, the address of the first element is passed by value. The function receives a copy of this address.)
- 实参数组名将该数组的起始地址传递给形参数组 (The formal parameter becomes a pointer to the first element of the actual array),两个数组共享一段内存单元 (The function uses the passed address to access the original array's memory), 系统不再为形参数组分配存储单元 (Correct, the parameter is a pointer, not a new array.)
- 既然两个数组共享一段内存单元, 所以形参数组修改时 (More accurately, modifications made *through the pointer parameter* to the array elements),实参数组也同时被修改了

```c
##include <stdio.h> // Added for printf

void change2(int array[])// int array[] is equivalent to int *array
                          // array now holds the address of ages[0]
{
    array[0] = 88; // This modifies the original ages[0]
}
int main(int argc, const char * argv[])
{
    int ages[3] = {1, 5, 8};
    printf("Before change2: ages[0] = %d\n", ages[0]);// 1
    change2(ages); // Pass the address of the first element of ages
    printf("After change2: ages[0] = %d\n", ages[0]);// 88
    return 0; // Added return
}
```

---

#### 18.3. 数组名作函数参数的注意点
- 在函数形参表中,允许不给出形参数组的长度 (Because it's treated as a pointer, the size information is lost. You usually pass the size as a separate argument.)

```c
void change(int array[]) // Size is not specified here
{
    array[0] = 88;
}
// Or equivalently:
// void change(int *array)
// {
//     array[0] = 88;
// }
```

- 形参数组和实参数组的类型必须一致,否则将引起错误。 (The element type must be compatible.)

```c
##include <stdio.h> // Added for printf

// void prtArray(double array[3]) // Error if called with int array[] due to type mismatch
void prtArray_int(int array[], int size) // Corrected to int and added size parameter
{
    for (int i = 0; i < size; i++) { // Use passed size
        printf("array[%d] = %d\n", i, array[i]); // Corrected format specifier
    }
}
int main(int argc, const char * argv[])
{
    int ages[3] = {1, 5, 8};
    // prtArray(ages); // Original call would be problematic with double array[]
    prtArray_int(ages, 3); // Call with int array and its size
    return 0; // Added return
}
```

- 当数组名作为函数参数时, 因为自动转换为了指针类型，所以在函数中无法动态计算除数组的元素个数 (using `sizeof(array)/sizeof(array[0])` directly on the pointer parameter, as `sizeof(array)` will give the size of the pointer, not the array.)

```c
##include <stdio.h> // Added for printf

void printArraySizeInfo(int array[]) // array is int* here
{
    printf("Inside printArraySizeInfo: sizeof(array) = %zu\n", sizeof(array)); // Prints size of pointer (e.g., 8 on 64-bit)
    // int length = sizeof(array)/ sizeof(int); // This would be sizeof(pointer)/sizeof(int), incorrect for array length
    // printf("Incorrect length calculation inside function = %d\n", length);
    // Correct way is to pass the size:
}

void printArrayCorrectly(int array[], int size) {
    printf("Inside printArrayCorrectly: Correct length passed = %d\n", size);
    for (int i = 0; i < size; i++) {
        printf("%d ", array[i]);
    }
    printf("\n");
}

int main() { // Added main wrapper
    int myArray[5] = {1,2,3,4,5};
    printf("In main: sizeof(myArray) = %zu\n", sizeof(myArray)); // Prints 5 * sizeof(int)
    printArraySizeInfo(myArray);
    printArrayCorrectly(myArray, 5);
    return 0; // Added return
}
```

- 练习:
    - 设计一个函数int arrayMax(int a[], int count)找出数组元素的最大值
    - 从键盘输入3个0-9的数字,然后输出0~9中哪些数字没有出现过
    - 要求从键盘输入6个0~9的数字,排序后输出

**解答:**
1.  **找出数组元素的最大值:**
    ```c
    ##include <stdio.h>
    ##include <limits.h> // For INT_MIN

    int arrayMax(int a[], int count) {
        if (count <= 0) {
            return INT_MIN; // Or handle error appropriately
        }
        int max_val = a[0];
        for (int i = 1; i < count; i++) {
            if (a[i] > max_val) {
                max_val = a[i];
            }
        }
        return max_val;
    }

    int main() {
        int arr[] = {10, 5, 25, 8, 15};
        int size = sizeof(arr) / sizeof(arr[0]);
        printf("数组中的最大值是: %d\n", arrayMax(arr, size));
        
        int empty_arr[] = {};
        printf("空数组中的最大值是 (错误处理): %d\n", arrayMax(empty_arr, 0));
        return 0;
    }
    ```
2.  **0~9中哪些数字没有出现过 (输入3个):**
    ```c
    ##include <stdio.h>
    int main() {
        int inputs[3];
        int appeared[10] = {0}; // Boolean array for 0-9, initialized to 0 (false)
        printf("请输入3个0-9的数字 (用空格分隔): ");
        scanf("%d %d %d", &inputs[0], &inputs[1], &inputs[2]);

        for (int i = 0; i < 3; i++) {
            if (inputs[i] >= 0 && inputs[i] <= 9) {
                appeared[inputs[i]] = 1; // Mark as appeared
            }
        }

        printf("没有出现过的数字: ");
        for (int i = 0; i <= 9; i++) {
            if (appeared[i] == 0) {
                printf("%d ", i);
            }
        }
        printf("\n");
        return 0;
    }
    ```
3.  **输入6个0~9的数字,排序后输出 (e.g., using bubble sort):**
    ```c
    ##include <stdio.h>

    void bubbleSortSimple(int arr[], int n) {
        int i, j, temp;
        for (i = 0; i < n - 1; i++) {
            for (j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    int main() {
        int nums[6];
        printf("请输入6个0-9的数字 (用空格分隔):\n");
        for (int i = 0; i < 6; i++) {
            scanf("%d", &nums[i]);
            if (nums[i] < 0 || nums[i] > 9) {
                printf("输入无效，请输入0-9的数字。\n");
                return 1; // Exit on invalid input
            }
        }

        bubbleSortSimple(nums, 6);

        printf("排序后的数字: ");
        for (int i = 0; i < 6; i++) {
            printf("%d ", nums[i]);
        }
        printf("\n");
        return 0;
    }
    ```

---

## 19. 二维数组
#### 19.1. 二维数组的基本概念
- 所谓二维数组就是一个一维数组的每个元素又被声明为一 维数组,从而构成二维数组. 可以说二维数组是特殊的一维数组。
- 示例:
    - int a[2][3] = { {80,75,92}, {61,65,71}};
    - 可以看作由一维数组a[0]和一维数组a[1]组成，这两个一维数组都包含了3个int类型的元素  
        ![](https://i-blog.csdnimg.cn/blog_migrate/5ef38d82dd997aba0816130f3e6804b2.png)

#### 19.2. 二维数组的定义
- 格式:
    - 数据类型 数组名[一维数组的个数][一维数组的元素个数]
    - 其中"一维数组的个数"表示当前二维数组中包含多少个一维数组 (Number of rows)
    - 其中"一维数组的元素个数"表示当前前二维数组中每个一维数组元素的个数 (Number of columns)

---

#### 19.3. 二维数组的初始化
- 二维数的初始化可分为两种:
    
    - 定义的同时初始化
    - 先定义后初始化 (Element by element, not with an initializer list)
- 定义的同时初始化
    

```c
int a[2][3]={ {80,75,92}, {61,65,71}};
```

- 先定义后初始化 (Element by element)

```c
int a[2][3];
a[0][0] = 80;
a[0][1] = 75;
a[0][2] = 92;
a[1][0] = 61;
a[1][1] = 65;
a[1][2] = 71;
```

- 按行分段赋值 (During definition with initializer list)

```c
int a[2][3]={ {80,75,92}, {61,65,71}};
```

- 按行连续赋值 (During definition with initializer list, inner braces are optional but recommended for clarity)

```c
int a[2][3]={ 80,75,92,61,65,71}; // Fills row by row
```

- 其它写法
    - 完全初始化,可以省略第一维的长度 (Number of rows can be omitted if initialized)

```c
int a[][3]={{1,2,3},{4,5,6}}; // Compiler deduces 2 rows
int a[][3]={1,2,3,4,5,6};   // Compiler deduces 2 rows
```

- 部分初始化,可以省略第一维的长度

```c
int a[][3]={{1},{4,5}}; // a[0][0]=1, a[0][1]=0, a[0][2]=0
                        // a[1][0]=4, a[1][1]=5, a[1][2]=0. Compiler deduces 2 rows.
int a[][3]={1,2,3,4};   // a[0]={1,2,3}, a[1][0]=4, a[1][1]=0, a[1][2]=0. Compiler deduces 2 rows.
```

> - 注意: 有些人可能想不明白，为什么可以省略行数，但不可以省略列数。也有人可能会问，可不可以只指定行数，但是省略列数？其实这个问题很简单，如果我们这样写：  
>     `int a[2][] = {1, 2, 3, 4, 5, 6}; // 错误写法`  
>     大家都知道，二维数组会先存放第1行的元素，由于不确定列数，也就是不确定第1行要存放多少个元素，所以这里会产生很多种情况，可能1、2是属于第1行的，也可能1、2、3、4是第一行的，甚至1、2、3、4、5、6全部都是属于第1行的 (The compiler needs the size of all dimensions except possibly the first to know how to map elements to memory and calculate offsets.)

- 指定元素的初始化 (Designated initializers - C99)

```c
int a[2][3]={[1][2]=10}; // a[1][2]=10, all others 0.
int a[2][3]={[1]={1,2,3}}; // Initializes row 1 to {1,2,3}, row 0 elements are 0.
```

---
(The original document had "二维数组的应用场景" here, but the content was images. I'll proceed to "二维数组的遍历和存储" as per the outline structure.)

#### 19.4. 二维数组的遍历和存储
###### 19.4.1. 二维数组的遍历
- 二维数组a[3][4],可分解为三个一维数组,其数组名分别为: a[0], a[1], a[2] (Note: a[0], a[1], a[2] are not array names in the same sense as `a`; they represent the first elements of each row, and when used in expressions, decay to pointers to `int`.)
    - 这三个一维数组都有4个元素,例如:一维数组a[0]的 元素为a[0][0],a[0][1],a[0][2],a[0][3]。
    - 所以遍历二维数组无非就是先取出二维数组中得一维数组, 然后再从一维数组中取出每个元素的值 (Iterate through rows, then through columns within each row.)
- 示例

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("%c\n", cs[0][0]);// 第一个[0]取出一维数组 (conceptually, the first row), 第二个[0]取出一维数组中对应的元素
    return 0; // Added return
}
```

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    for (int i = 0; i < 2; i++) { // 外循环取出一维数组 (iterates through rows)
        // i
        for (int j = 0; j < 3; j++) {// 内循环取出一维数组的每个元素 (iterates through columns in current row)
            printf("%c ", cs[i][j]); // Added space for readability
        }
        printf("\n");
    }
    return 0; // Added return
}
```

> 注意: 必须强调的是,a[0],a[1],a[2]不能当作下标变量使用,它们是数组名,不是一个单纯的下标变量 (When `a[i]` (where `a` is a 2D array) is used in an expression, it decays to a pointer to the first element of the i-th row. It's not an "array name" in the same way `a` is, but it does represent the start of that row.)

---

###### 19.4.2. 二维数组的存储
- 和一维数组一样 (Elements are stored contiguously in memory, row by row - row-major order)
    - 给数组分配存储空间从内存地址大开始分配 (This describes stack growth, not necessarily how array elements are ordered relative to each other. Array elements are contiguous from lower to higher addresses.)
    - 给数组元素分配空间, 从所占用内存地址小的开始分配 (The first element `a[0][0]` is at the lowest address of the block allocated for the array.)
    - 往每个元素中存储数据从高地址开始存储 (This refers to endianness for multi-byte elements. For `char`, it's one byte.)

```c
##include <stdio.h>
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'}, // Row 0
        {'d', 'e', 'f'}  // Row 1
    };
    // cs == &cs == &cs[0] == &cs[0][0] (These are all true in terms of the address value they yield)
    // cs (array name) decays to pointer to first row (&cs[0])
    // &cs is pointer to the whole array
    // &cs[0] is pointer to the first row
    // &cs[0][0] is pointer to the first element of the first row
    // All these pointers will hold the same base address of the array.
    printf("cs = %p\n", (void*)cs);                
    printf("&cs = %p\n", (void*)&cs);              
    printf("&cs[0] = %p\n", (void*)&cs[0]);        
    printf("&cs[0][0] = %p\n", (void*)&cs[0][0]);  

    // To show contiguity:
    printf("&cs[0][1] = %p\n", (void*)&cs[0][1]); // Address of 'b'
    printf("&cs[0][2] = %p\n", (void*)&cs[0][2]); // Address of 'c'
    printf("&cs[1][0] = %p\n", (void*)&cs[1][0]); // Address of 'd' (should be immediately after 'c')
    return 0;
}
```

![](https://i-blog.csdnimg.cn/blog_migrate/50fc4f3123efede843f47714375c019d.png)

---
#### 19.5. 二维数组与函数
- 值传递 (When passing individual elements)

```c
##include <stdio.h>

// 和一维数组一样, 只看形参是基本类型还是数组类型
// 如果是基本类型在函数中修改形参不会影响实参
void change_char_val(char ch){ // Renamed
    ch = 'n'; // Modifies local copy
    printf("Inside change_char_val: ch = %c\n", ch);
}
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("Before change_char_val: cs[0][0] = %c\n", cs[0][0]); // a
    change_char_val(cs[0][0]);
    printf("After change_char_val: cs[0][0] = %c\n", cs[0][0]); // a
    return 0;
}
```

- 地址传递 (When passing a row or the whole 2D array, it decays to a pointer)

```c
##include <stdio.h>

// 和一维数组一样, 只看形参是基本类型还是数组类型
// 如果是数组类型在函数中修改形参会影响实参
void change_row(char ch_row[]){ // ch_row is char*
    ch_row[0] = 'n'; // Modifies original array
}
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("Before change_row: cs[0][0] = %c\n", cs[0][0]); // a
    change_row(cs[0]); // Pass address of the first row (cs[0])
    printf("After change_row: cs[0][0] = %c\n", cs[0][0]); // n
    return 0;
}
```

```c
##include <stdio.h>

// 和一维数组一样, 只看形参是基本类型还是数组类型
// 如果是数组类型在函数中修改形参会影响实参
// For 2D arrays, you MUST specify the size of all dimensions except the first.
void change_2d_array(char ch_arr[][3]){ // or char (*ch_arr)[3]
    ch_arr[0][0] = 'n'; // Modifies original array
}
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("Before change_2d_array: cs[0][0] = %c\n", cs[0][0]); // a
    change_2d_array(cs); // Pass the 2D array (decays to pointer to its first row)
    printf("After change_2d_array: cs[0][0] = %c\n", cs[0][0]); // n
    return 0;
}
```

#### 19.6. 二维数组作为函数参数注意点
- 形参错误写法 (When passing a 2D array, the size of the second (and subsequent) dimensions must be specified in the function parameter.)

```c
// void test(char cs[2][]) // 错误写法: second dimension size is missing
// {
//     printf("我被执行了\n");
// }

void test_correct1(char cs[2][3]) // 正确写法 (fixed number of rows and columns)
{
    printf("我被执行了 (test_correct1)\n");
}

void test_correct2(char cs[][3]) // 正确写法 (number of rows can be variable, columns fixed)
{
    printf("我被执行了 (test_correct2)\n");
}

// Also correct and often clearer:
// void test_correct3(char (*cs_ptr_to_row)[3]) // Pointer to an array of 3 chars
// {
//     printf("我被执行了 (test_correct3)\n");
//     // Access elements like cs_ptr_to_row[row_index][col_index]
// }
```

- 二维数组作为函数参数，在被调函数中不能获得其有多少行，需要通过参数传入 (using `sizeof` on the decayed pointer parameter)

```c
##include <stdio.h> // Added for printf

void test_rows(char cs[2][3], int rows) // Pass number of rows
{
    // size_t num_rows_inside = sizeof(cs) / sizeof(cs[0]); // Incorrect: sizeof(cs) is size of pointer
    // printf("Incorrect row calculation inside: %zu\n", num_rows_inside);
    printf("Number of rows passed: %d\n", rows);
}
int main() { // Added main wrapper
    char my_cs[2][3] = {{'a'},{'b'}};
    test_rows(my_cs, 2);
    return 0; // Added return
}
```

- 二维数组作为函数参数，在被调函数中可以计算出二维数组有多少列 (This is true if the column size is part of the parameter type, e.g., `char cs[][3]`. Then `sizeof(cs[0])` gives the size of one row, which is `num_cols * sizeof(element_type)`.)

```c
##include <stdio.h> // Added for printf

void test_cols(char cs[][3]) // Column size 3 is specified
{
    size_t size_of_row = sizeof(cs[0]); // sizeof(one row) = 3 * sizeof(char) = 3
    size_t num_cols = sizeof(cs[0]) / sizeof(cs[0][0]); // 3 / 1 = 3
    printf("Size of one row (cs[0]): %zu bytes\n", size_of_row);
    printf("Number of columns calculated: %zu\n", num_cols);
}
int main() { // Added main wrapper
    char my_cs_cols[2][3] = {{'x','y','z'}, {'1','2','3'}};
    test_cols(my_cs_cols);
    return 0; // Added return
}
```

---

#### 19.7. 作业
- 玩家通过键盘录入 w,s,a,d控制小人向不同方向移动,其中w代表向上移动,s代表向 下移动,a代表向左移动,d 代表向右移动,当小人移动到出口位置,玩家胜利
    
- 思路:
    
- 1.定义二维数组存放地图
    

```
     ############
     ##O ##  E  (E for Exit, O for Player)
     ## #### ##
     ##  ## ##
     ####   ##
     ############
```

- 2.规定地图的方向  
    ![](https://i-blog.csdnimg.cn/blog_migrate/4ecf3d25d55685fb8c9458e151a307fd.png)
- 3.编写程序控制方向
    - 当输入w或者W, 小人向上移动. x-1
    - 当输入s 或者S, 小人向下. x+1
    - 当输入a或者A, 小人向左. y-1
    - 当输入d或者D, 小人向右. y+1
- 4.移动小人
    - 用变量记录小人当前的位置
        - 1)如果小人将要移动的位置是墙,则无法移动
        - 2)如果小人将要移动的位置是路,则可以移动
- 5.判断是否走出迷宫

---

## 20. 字符串
#### 20.1. 字符串的基本概念
- 字符串是位于双引号中的字符序列
    - 在内存中以“\0”结束 (null terminator),所占字节比实际多一个  
        ![](https://i-blog.csdnimg.cn/blog_migrate/65fa737274175b8f4415f7b7240da435.png)

#### 20.2. 字符串的初始化
- 在C语言中没有专门的字符串变量,通常用一个字符数组来存放一个字符串。
    - 当把一个字符串存入一个数组时,会把结束符‘\0’存入数组,并以此作为该字符串是否结束的标志。
    - 有了‘\0’标志后,就不必再用字符数组 的长度来判断字符串的长度了
- 初始化

```c
    char name[9] = "lnj"; // "lnj" is {'l','n','j','\0'}. Remaining elements of name are zero-initialized.
    char name1[9] = {'l','n','j','\0'}; // Explicit null termination.
    char name2[9] = {'l','n','j',0};    // 0 is equivalent to '\0' for char.
    // 当数组元素个数大于存储字符内容时, 未被初始化的部分默认值是0, 所以下面也可以看做是一个字符串
    char name3[9] = {'l','n','j'}; // name3[3] to name3[8] are initialized to 0 ('\0').
```

- 错误的初始化方式

```c
    //省略元素个数时, 不能省略末尾的\n (If initializing with individual chars and want it to be a C-string)
    // 不正确地写法，结尾没有\0 ，只是普通的字符数组, not a C-string
    // char name4[] = {'l','n','j'}; // This is a char array of size 3, not a string.

     //   "中间不能包含\0", 因为\0是字符串的结束标志
     //    \0的作用：字符串结束的标志
    // char name[] = "c\0ool"; // This creates a string "c". The "ool" part is after the first null terminator.
    // printf("name = %s\n",name);
// 输出结果: c
```

---

#### 20.3. 字符串输出
- 如果字符数组中存储的是一个字符串, 那么字符数组的输入输出将变得简单方便。
    - 不必使用循环语句逐个地输入输出每个字符
    - 可以使用printf函数和scanf函数一次性输出输入一个字符数组中的字符串
- 使用的格式字符串为“%s”,表示输入、输出的是一个字符串 字符串的输出

---

- **输出**
    - %s的本质就是根据传入的name的地址逐个去取数组中的元素然后输出，直到遇到\0位置

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    char chs[] = "lnj"; // Automatically null-terminated
    printf("%s\n", chs);
    return 0; // Added return
}
```

- 注意点:
    - \0引发的脏读问题 (If a char array is not properly null-terminated and used with %s)

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    char name[] = {'c', 'o', 'o', 'l' , '\0'}; // Properly null-terminated
    char name2[] = {'l', 'n', 'j'}; // NOT null-terminated. Using with %s is undefined behavior.
                                    // It might print "lnj" then garbage, or crash.
    // To fix name2 for %s: char name2[] = {'l', 'n', 'j', '\0'};
    // Or: char name2[] = "lnj";

    // The original example's output "lnjcool" implies that 'name' was coincidentally
    // located in memory immediately after 'name2', and printf read past 'name2' into 'name'.
    // This is highly unreliable and undefined.

    printf("name = %s\n", name);
    // printf("name2 = %s\n", name2); // This is dangerous
    
    char safe_name2[] = "lnj";
    printf("safe_name2 = %s\n", safe_name2);
    return 0; // Added return
}
```

---

- **输入**

```c
##include <stdio.h> // Added for scanf
int main() { // Added main wrapper
    char ch[10]; // Buffer of size 10, can hold string of length 9 + null terminator
    printf("请输入字符串 (最多9个字符): ");
    scanf("%9s",ch); // %9s reads at most 9 characters to prevent buffer overflow, then adds '\0'
                    // Using just %s is dangerous: scanf("%s", ch);
    printf("输入的是: %s\n", ch);
    return 0; // Added return
}
```

- 注意点:
    - 对一个字符串数组, 如果不做初始化赋值, 必须指定数组长度 (When declaring it, yes. If used with `scanf`, it must have allocated space.)
    - ch最多存放由9个字符构成的字符串，其中最后一个字符的位置要留给字符串的结尾标示‘\0’ (If `ch` is `char ch[10]`)
    - 当用scanf函数输入字符串时,字符串中不能含有空格,否则将以空格作为串的结束符 (Correct, `%s` stops at whitespace. To read lines with spaces, use `fgets`.)

---

#### 20.4. 字符串常用方法
- C语言中供了丰富的字符串处理函数,大致可分为字符串的输入、输出、合并、修改、比较、转 换、复制、搜索几类。
    - 使用这些函数可大大减轻编程的负担。
    - 使用输入输出的字符串函数,在使用前应包含头文件"stdio.h"
    - 使用其它字符串函数则应包含头文件"string.h"

---

- 字符串输出函数:puts
    - 格式: puts(字符数组名)
    - 功能:把字符数组中的字符串输出到显示器。即在屏幕上显示该字符串。 `puts` also appends a newline character to the output.
- 优点:
    - 自动换行
    - 可以是数组的任意元素地址 (It expects a `const char*` pointing to a null-terminated string.)
- 缺点
    - 不能自定义输出格式, 例如 puts(“hello %i”); (Correct, it only prints the string.)

```c
##include <stdio.h> // For puts
int main() { // Added main wrapper
    char ch[] = "lnj";
    puts(ch); //输出结果: lnj (followed by a newline)
    return 0; // Added return
}
```

> - puts函数完全可以由printf函数取代。当需要按一定格式输出时,通常使用printf函数 (printf offers more control, but `puts` is simpler for just printing a string with a newline.)

---

- 字符串输入函数:gets
    - 格式: gets (字符数组名)
    - 功能:从标准输入设备键盘上输入一个字符串。
    - **WARNING: `gets` is extremely dangerous because it does not perform bounds checking and can easily lead to buffer overflows. It has been removed from recent C standards (C11 and later) and should NEVER be used. Use `fgets` instead.**

```c
##include <stdio.h> // For gets (dangerous), puts
int main() { // Added main wrapper
    char ch[30];
    printf("请输入字符串: ");
    // gets(ch); // DANGEROUS! Use fgets instead.
    // Example with fgets:
    if (fgets(ch, sizeof(ch), stdin) != NULL) {
        // fgets might include the newline if there's space, remove it if needed:
        // size_t len = strlen(ch);
        // if (len > 0 && ch[len-1] == '\n') {
        //     ch[len-1] = '\0';
        // }
        puts(ch); 
    }
    return 0; // Added return
}
```

> - 可以看出当输入的字符串中含有空格时,输出仍为全部字符串。说明gets函数并不以空格作为字符串输入结束的标志,而只以回车作为输入结束。这是与scanf函数不同的。 (`fgets` also reads spaces until newline or buffer full).
> - 注意gets很容易导致数组下标越界，是一个不安全的字符串操作函数 (Absolutely correct, hence its deprecation/removal).

---

- 字符串长度
- 利用sizeof字符串长度
    - 因为字符串在内存中是逐个字符存储的,一个字符占用一个字节,所以字符串的结束符长度也是占用的内存单元的字节数。 (`sizeof` on a char array gives the total size of the array in bytes, including space for `\0` if it's a string literal initialization or if the array is larger than the string it holds.)

```c
##include <stdio.h> // For printf
##include <string.h> // For strlen (though not used in this sizeof example)
int main() { // Added main wrapper
    char name[] = "it666"; // Size is 6 (5 chars + '\0')
    int size = sizeof(name);// 包含\0
    printf("size = %d\n", size); //输出结果:6
    return 0; // Added return
}
```

---

- 利用系统函数 `strlen`
    - 格式: strlen(字符数组名)
    - 功能:测字符串的实际长度(不含字符串结束标志‘\0’)并作为函数返回值。
    - Return type is `size_t`.

```c
##include <stdio.h> // For printf
##include <string.h> // For strlen
int main() { // Added main wrapper
    char name[] = "it666"; // Length is 5
    size_t len = strlen(name); // strlen does not count '\0'
    printf("len = %zu\n", len); //输出结果:5 (%zu for size_t)
    return 0; // Added return
}
```

---

- 以“\0”为字符串结束条件进行统计 (Custom strlen implementations)

```c
##include <stdio.h> // For printf

/**
 *  自定义方法计算字符串的长度 (while loop version)
 *  @param str 需要计算的字符串 (must be null-terminated)
 *  @return 不包含\0的长度
 */
int myStrlen2(char str[])
{
    int length = 0;
    while (str[length] != '\0')
    {
        length++;
    }
    return length;
}
/**
 *  自定义方法计算字符串的长度 (for loop version, count parameter is confusing here, assumes str is null-terminated within count)
 *  @param str  需要计算的字符串
 *  @param count 字符串的最大检查长度 (this is not standard for strlen, usually strlen relies on '\0')
 *  @return 不包含\0的长度, or count if '\0' not found within count.
 */
int myStrlen(char str[], int count) // This is more like strnlen if it returns count when '\0' is not found.
{
    int length = 0;
    for (int i = 0; i < count; i++) {
        if (str[i] == '\0') {
            return length; // or return i;
        }
        length++;
    }
    return length; // Returns count if '\0' not found within the first 'count' characters.
}

int main() { // Added main wrapper
    char myString[] = "hello";
    printf("myStrlen2(\"hello\") = %d\n", myStrlen2(myString));
    printf("myStrlen(\"hello\", 10) = %d\n", myStrlen(myString, 10));
    printf("myStrlen(\"hello\", 3) = %d\n", myStrlen(myString, 3)); // Will return 3
    return 0;
}
```

---

- 字符串连接函数:strcat
    - 格式: strcat(字符数组名1,字符数组名2)
    - 功能:把字符数组2中的字符串连接到字符数组1 中字符串的后面,并删去字符串1后的串标志 “\0”。本函数返回值是字符数组1的首地址。
    - **WARNING: `strcat` is unsafe if `字符数组名1` is not large enough to hold the combined string. Use `strncat` for a safer alternative.**

```c
##include <stdio.h> // For puts
##include <string.h> // For strcat
int main() { // Added main wrapper
    char oldStr[100] = "welcome to"; // Must be large enough
    char newStr[] = " lnj"; // Corrected: was char newStr[20]
    strcat(oldStr, newStr);
    puts(oldStr); //输出: welcome to lnj
    return 0; // Added return
}
```

> - 本程序把初始化赋值的字符数组与动态赋值的字符串连接起来。要注意的是,字符数组1应定义足 够的长度,否则不能全部装入被连接的字符串。 (Correct, this is a major source of buffer overflows.)

---

- 字符串拷贝函数:strcpy  
    - 格式: strcpy(字符数组名1,字符数组名2)
    - 功能:把字符数组2中的字符串拷贝到字符数组1中。串结束标志“\0”也一同拷贝。字符数名2, 也可以是一个字符串常量。这时相当于把一个字符串赋予一个字符数组。
    - **WARNING: `strcpy` is unsafe if `字符数组名1` is not large enough. Use `strncpy` for a safer alternative (but be careful with `strncpy`'s null termination).**

```c
##include <stdio.h> // For puts
##include <string.h> // For strcpy
int main() { // Added main wrapper
    char oldStr[100] = "welcome to"; // Destination buffer
    char newStr[] = " lnj"; // Source string (Corrected: was char newStr[50])
    strcpy(oldStr, newStr); // Copies " lnj" into oldStr, overwriting "welcome to"
    puts(oldStr); // 输出结果:  lnj 
    return 0; // Added return
}
```

> - 本函数要求字符数组1应有足够的长度,否则不能全部装入所拷贝的字符串。 (Correct, another source of buffer overflows.)

---

- 字符串比较函数:strcmp
    - 格式: strcmp(字符数组名1,字符数组名2)
    - 功能:按照ASCII码顺序比较两个数组中的字符串,并由函数返回值返回比较结果。
        - 字符串1=字符串2,返回值=0;
        - 字符串1>字符串2,返回值>0; (Lexicographically greater)
        - 字符串1<字符串2,返回值<0。 (Lexicographically smaller)

```c
##include <stdio.h> // For printf
##include <string.h> // For strcmp
int main() { // Added main wrapper
    char strA1[] = "0"; // Corrected: was char oldStr[100]
    char strB1[] = "1"; // Corrected: was char newStr[50]
    printf("%d\n", strcmp(strA1, strB1)); //输出结果:-1 (or some negative value)
    
    char strA2[] = "1";
    char strB2[] = "1";
    printf("%d\n", strcmp(strA2, strB2));  //输出结果:0
    
    char strA3[] = "1";
    char strB3[] = "0";
    printf("%d\n", strcmp(strA3, strB3)); //输出结果:1 (or some positive value)
    return 0; // Added return
}
```

---

#### 20.5. 练习
- 编写一个函数char_contains(char str[],char key)， 如果字符串str中包含字符key则返回数值1，否则返回数值0
```c
##include <stdio.h>
##include <string.h> // For strlen (optional, can iterate until '\0')

int char_contains(char str[], char key) {
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] == key) {
            return 1; // Character found
        }
    }
    return 0; // Character not found
}

int main() {
    char my_string[] = "hello world";
    char char_to_find = 'o';
    char char_not_to_find = 'z';

    if (char_contains(my_string, char_to_find)) {
        printf("字符串 '%s' 包含字符 '%c'\n", my_string, char_to_find);
    } else {
        printf("字符串 '%s' 不包含字符 '%c'\n", my_string, char_to_find);
    }

    if (char_contains(my_string, char_not_to_find)) {
        printf("字符串 '%s' 包含字符 '%c'\n", my_string, char_not_to_find);
    } else {
        printf("字符串 '%s' 不包含字符 '%c'\n", my_string, char_not_to_find);
    }
    return 0;
}
```

---

#### 20.6. 字符串数组基本概念
- 字符串数组其实就是定义一个数组保存所有的字符串 (An array where each element is a string, typically implemented as an array of character arrays or an array of character pointers.)
    - 1.一维字符数组中存放一个字符串，比如一个名字`char name[20] = "nj";`
    - 2.如果要存储多个字符串，比如一个班所有学生的名字，则需要二维字符数组，`char names[15][20];`可以存放15个学生的姓名(假设姓名不超过20字符)
    - 如果要存储两个班的学生姓名，那么可以用三维字符数组`char names[2][15][20];`  

 20.6.1. 字符串数组的初始化 (Array of char arrays)
 
```c
##include <stdio.h> // For printf
int main() { // Added main wrapper
    // Each string can be up to 9 chars + null terminator
    char names[2][10] = { 
        {'l','n','j','\0'}, // Explicitly initializing first string
        {'l','y','h','\0'}  // Explicitly initializing second string
    };

    char names2[2][10] = { 
        "lnj",  // Using string literal for first string
        "lyh"   // Using string literal for second string
    };
    // char names3[2][10] = { "lnj", "lyh" }; // This is identical to names2

    printf("names[0]: %s\n", names[0]);
    printf("names[1]: %s\n", names[1]);
    printf("names2[0]: %s\n", names2[0]);
    printf("names2[1]: %s\n", names2[1]);
    return 0; // Added return
}
```
**Array of character pointers (more flexible for varying string lengths):**
```c
##include <stdio.h>
int main() {
    const char *names_ptrs[] = { // Array of pointers to string literals
        "Liu Zimao",
        "Cheng Yubo",
        "Han Jinpeng"
    };
    for (int i = 0; i < 3; i++) {
        printf("%s\n", names_ptrs[i]);
    }
    return 0;
}
```

---

## 21. 查找与排序
#### 21.1. 折半查找 (二分查找)
- **基本思路**
- 在有序表中,取中间元素作为比较对象,若给定值与中间元素的要查找的数相等,则查找成功;若给定值小于中间元素的要查找的数,则在中间元素的左半区继续查找;
- 若给定值大于中间元素的要查找的数,则在中间元素的右半区继续查找。不断重复上述查找过 程,直到查找成功,或所查找的区域无数据元素,查找失败. **前提：数组必须是有序的。**

---

- **实现步骤**
    
- 在有序表中,取中间元素作为比较对象,若给定值与中间元素的要查找的数相等,则查找成功;
    
- 若给定值小于中间元素的要查找的数,则在中间元素的左半区继续查找;
    
- 若给定值大于中间元素的要查找的数,则在中间元素的右半区继续查找。
    
- 不断重复上述查找过 程,直到查找成功,或所查找的区域无数据元素,查找失败。  
    ![](https://i-blog.csdnimg.cn/blog_migrate/25809f1093164c04de44df08b9788f00.png)
    
- **代码实现**
    

```c
##include <stdio.h> // Added for printf

int findKey(int values[], int length, int key) {
    // 定义一个变量记录最小索引
    int min = 0;
    // 定义一个变量记录最大索引
    int max = length - 1;
    // 定义一个变量记录中间索引
    // int mid = (min + max) * 0.5; // This can cause issues with large min/max due to overflow before division.
                                 // Better: mid = min + (max - min) / 2;
    int mid;
    
    while (min <= max) {
        mid = min + (max - min) / 2; // Calculate mid inside the loop
        // 如果mid对应的值 大于 key, 那么max要变小
        if (values[mid] > key) {
            max = mid - 1;
        // 如果mid对应的值 小于 key, 那么min要变大 (Corrected comment)
        }else if (values[mid] < key) {
            min = mid + 1;
        }else { // values[mid] == key
            return mid; // 找到，返回索引
        }
        // 修改完min/max之后, 重新计算mid的值 (mid is recalculated at the start of the loop)
    }
    return -1; // 未找到，返回-1
}

int main() { // Added main for testing
    int sorted_array[] = {2, 5, 7, 8, 11, 12, 15, 18, 22, 25};
    int len = sizeof(sorted_array) / sizeof(sorted_array[0]);
    int key_to_find = 12;
    int result_index = findKey(sorted_array, len, key_to_find);

    if (result_index != -1) {
        printf("元素 %d 在索引 %d 处找到。\n", key_to_find, result_index);
    } else {
        printf("元素 %d 未在数组中找到。\n", key_to_find);
    }

    key_to_find = 9;
    result_index = findKey(sorted_array, len, key_to_find);
    if (result_index != -1) {
        printf("元素 %d 在索引 %d 处找到。\n", key_to_find, result_index);
    } else {
        printf("元素 %d 未在数组中找到。\n", key_to_find);
    }
    return 0;
}
```

---

#### 21.2. 选择排序
- 选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（或最大）元素,存放到排序序列的起始位置,然后,再从剩余未排序元素中继续寻找最小（或最大）元素,然后放到已排序序列末尾。以此类推,直到所有元素均排序完毕。  
    ![](https://i-blog.csdnimg.cn/blog_migrate/fab10f40260257f26b45541254cea4d8.gif)
    
- 排序思路:
    
    - 假设按照升序排序
    - 1.用第0个元素和后面所有元素依次比较
    - 2.判断第0个元素是否大于当前被比较元素, 一旦大于就交换位置 (More accurately: find the index of the minimum element in the unsorted part.)
    - 3.第0个元素和后续所有元素比较完成后, 第0个元素就是最小值 (After finding the minimum, swap it with the element at the current starting position of the unsorted part.)
    - 4.排除第0个元素, 用第1个元素重复1~3操作, 比较完成后第1个元素就是倒数第二小的值
    - 以此类推, 直到当前元素没有可比较的元素, 排序完成
- 代码实现:
    

```c
##include <stdio.h> // Added for printf

// 交换两个元素的值, i/j需要交换的索引
void swapEle(int array[], int i, int j) {
    int temp = array[i];
    array[i] = array[j];
    array[j] = temp;
}

// 选择排序 (升序)
void selectSort(int numbers[], int length) {
    int i, j, min_idx;
    // 外循环控制已排序部分的末尾
    for (i = 0; i < length - 1; i++) {
        // 假设当前元素是最小的
        min_idx = i;
        // 内循环在未排序部分找到最小元素的索引
        for (j = i + 1; j < length; j++) {
            if (numbers[j] < numbers[min_idx]) {
                min_idx = j;
            }
        }
        // 如果找到的最小元素不是当前元素，则交换
        if (min_idx != i) {
            swapEle(numbers, i, min_idx);
        }
    }
}

void printArray(int arr[], int size) { // Helper to print array
    for (int i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() { // Added main for testing
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr)/sizeof(arr[0]);
    printf("原始数组: \n");
    printArray(arr, n);
    selectSort(arr, n);
    printf("排序后的数组: \n");
    printArray(arr, n);
    return 0;
}
```

---

#### 21.3. 冒泡排序
- 冒泡排序(Bubble Sort)是一种简单的排序算法。它重复 地走访过要排序的数列,一次比较两个元素,如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换,也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。  
    ![](https://i-blog.csdnimg.cn/blog_migrate/5c1dcb6981e94fcb7b6b3776b85a1bfd.gif)
- 排序思路:
    - 假设按照升序排序
    - 1.从第0个元素开始, 每次都用相邻两个元素进行比较
    - 2.一旦发现后面一个元素小于前面一个元素就交换位置
    - 3.经过一轮比较之后最后一个元素就是最大值
    - 4.排除最后一个元素, 以此类推, 每次比较完成之后最大值都会出现再被比较所有元素的最后
    - 直到当前元素没有可比较的元素, 排序完成
- 代码实现:

```c
##include <stdio.h> // Added for printf

// (swapEle and printArray functions can be reused from selectSort example)
// void swapEle(int array[], int i, int j) { ... }
// void printArray(int arr[], int size) { ... }

// 冒泡排序 (升序)
void bubbleSort(int numbers[], int length) {
    int i, j;
    for (i = 0; i < length - 1; i++) {
        // -1防止`角标越界`: 访问到了不属于自己的索引
        // -i因为每轮最大的元素已经冒泡到末尾，无需再比较
        for (j = 0; j < length - i - 1; j++) {
           //  1.用当前元素和相邻元素比较
            if (numbers[j] > numbers[j + 1]) { // For ascending order
                //  2.一旦发现前面大于后面就交换位置
                swapEle(numbers, j, j + 1);
            }
        }
    }
}

int main() { // Added main for testing
    int arr[] = {5, 1, 4, 2, 8};
    int n = sizeof(arr)/sizeof(arr[0]);
    printf("原始数组: \n");
    printArray(arr, n);
    bubbleSort(arr, n);
    printf("排序后的数组: \n");
    printArray(arr, n);
    return 0;
}
```

---

#### 21.4. 插入排序
- 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。  
    ![](https://i-blog.csdnimg.cn/blog_migrate/6b171655073b94cfdca35fc697635fca.gif)
- 排序思路:
    - 假设按照升序排序
    - 1.从索引为1的元素开始向前比较, 一旦前面一个元素大于自己就让前面的元素先后移动
    - 2.直到没有可比较元素或者前面的元素小于自己的时候, 就将自己插入到当前空出来的位置
- 代码实现:

```c
##include <stdio.h> // Added for printf
// (printArray function can be reused)

void insertionSort(int nums[], int len) { // Renamed function
    int i, key, j;
    for (i = 1; i < len; i++) {
        key = nums[i]; // 当前要插入的元素
        j = i - 1;

        // 将大于key的元素向后移动
        while (j >= 0 && nums[j] > key) {
            nums[j + 1] = nums[j];
            j = j - 1;
        }
        nums[j + 1] = key; // 插入key到正确位置
    }
}

int main()
{
    // 待排序数组
    int nums[5] = {3, 1, 2, 0, 3};
    // 0.计算待排序数组长度
    int len = sizeof(nums) / sizeof(nums[0]);
    
    printf("原始数组: \n");
    printArray(nums, len);
    insertionSort(nums, len);
    printf("排序后的数组: \n");
    printArray(nums, len);
    return 0; // Added return
}
```
(The second version of insertion sort in the original document was a variation of bubble sort, not insertion sort. I've used the standard insertion sort logic above.)

---

#### 21.5. 希尔排序
- 1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。  
    ![](https://i-blog.csdnimg.cn/blog_migrate/cc95aca85936959f9552df5625970bd2.gif)
- 排序思路:
    - 1.希尔排序可以理解为插入排序的升级版, 先将待排序数组按照指定步长(gap)划分为几个小数组 (interleaved sub-arrays)
    - 2.利用插入排序对这些子数组进行排序, 然后将几个排序的小数组重新合并为原始数组 (The sub-arrays are not explicitly separated; insertion sort is applied with the current gap.)
    - 3.重复上述操作, 逐步减小步长，直到步长为1时,再利用插入排序排序即可 (The final pass with gap=1 ensures the array is fully sorted.)
- 代码实现:

```c
##include <stdio.h> // Added for printf
// (printArray function can be reused)

void shellSort(int nums[], int len) { // Renamed function
    // 1. 计算初始步长 (gap)
    for (int gap = len / 2; gap > 0; gap /= 2) {
        // 对每个步长进行插入排序
        for (int i = gap; i < len; i++) {
            int temp = nums[i];
            int j;
            for (j = i; j >= gap && nums[j - gap] > temp; j -= gap) {
                nums[j] = nums[j - gap];
            }
            nums[j] = temp;
        }
    }
}

int main()
{
    // 待排序数组
    int nums[5] = {3, 1, 2, 0, 3};
    // 0.计算待排序数组长度
    int len = sizeof(nums) / sizeof(nums[0]);

    printf("原始数组: \n");
    printArray(nums, len);
    shellSort(nums, len);
    printf("排序后的数组: \n");
    printArray(nums, len);
    return 0; // Added return
}
```

> 江哥提示:  
> 对于初学者而言, 排序算法一次不易于学习太多, 咋们先来5个玩一玩, 后续继续讲解其它5个

---

#### 21.6. 计数排序（Counting Sort）
- 计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在`对一定范围内的整数排序`时，快于任何比较排序算法。
    
- 排序思路:
    
    - 1.找出待排序数组最大值 (and minimum value, to determine the range).
    - 2.定义一个计数数组 (count array)，其大小为 (最大值 - 最小值 + 1)，用于统计每个元素出现的次数。
    - 3.遍历待排序数组, 将待排序数组遍历到的值作为计数数组的索引 (after adjusting for the minimum value if it's not 0), 并在对应索引处的值上加1。
    - 4.根据计数数组，按顺序重构排序后的数组。  
        ![](https://i-blog.csdnimg.cn/blog_migrate/368522e9b5993e1ec68f46d592e528ce.png)
- 简单代码实现:
    

```c
##include <stdio.h> // Added for printf
##include <stdlib.h> // For malloc, free if dynamic range
##include <limits.h> // For INT_MAX, INT_MIN

// (printArray function can be reused)

void countingSort(int nums[], int len) {
    if (len <= 0) return;

    // 1. 找出待排序数组中的最大值和最小值
    int max_val = nums[0];
    int min_val = nums[0];
    for (int i = 1; i < len; i++) {
        if (nums[i] > max_val) max_val = nums[i];
        if (nums[i] < min_val) min_val = nums[i];
    }

    int range = max_val - min_val + 1;

    // 2. 定义计数数组并初始化为0
    int *count_array = (int *)calloc(range, sizeof(int));
    if (count_array == NULL) {
        printf("内存分配失败\n");
        return;
    }

    // 3. 统计每个元素出现的次数
    for (int i = 0; i < len; i++) {
        count_array[nums[i] - min_val]++;
    }

    // 4. 根据计数数组重构排序后的数组
    int k = 0; // Index for the original array nums
    for (int i = 0; i < range; i++) {
        while (count_array[i] > 0) {
            nums[k++] = i + min_val;
            count_array[i]--;
        }
    }
    free(count_array);
}

int main()
{
    // 待排序数组
    int nums[5] = {3, 1, 2, 0, 3};
    int len = sizeof(nums) / sizeof(nums[0]);
    
    printf("原始数组: \n");
    printArray(nums, len);
    countingSort(nums, len);
    printf("排序后的数组 (计数排序): \n");
    printArray(nums, len);

    int nums2[] = {4, -2, 0, 4, 1, -1, 0, 3};
    int len2 = sizeof(nums2)/sizeof(nums2[0]);
    printf("原始数组2: \n");
    printArray(nums2, len2);
    countingSort(nums2, len2);
    printf("排序后的数组2 (计数排序): \n");
    printArray(nums2, len2);

    return 0;
}
```
(The original counting sort example was simplified and assumed non-negative numbers starting from 0. The version above handles a range of integers including negatives.)

---

# **第六部分：指针**

## 22. 指针基本概念
#### 22.1. 什么是指针？
- 什么是地址
    
    - 生活中的地址:  
        ![](https://i-blog.csdnimg.cn/blog_migrate/67d424d780130cdac35540c489c757b3.png)
    - 内存地址:  
        ![](https://i-blog.csdnimg.cn/blog_migrate/d8d1fec72abf908f30eaf0946a4ecd18.png)
- 地址与内存单元中的数据是两个完全不同的概念
    
    - 地址如同房间编号, 根据这个编号我们可以找到对应的房间
    - 内存单元如同房间, 房间是专门用于存储数据的
- 变量地址:
    
    - 系统分配给"变量"的"内存单元"的起始地址

```c
// int num = 6; // 占用4个字节
// //那么变量num的地址为: 0ff06 (Example address)

// char c = 'a'; // 占用1个字节
// //那么变量c的地址为:0ff05 (Example address, assuming stack grows downwards and c is declared after num)
```

![](https://i-blog.csdnimg.cn/blog_migrate/06e0f1bdac71761954f6673eb9f99d45.png)

---

- 什么是指针 (Reiteration)
    - 在计算机中所有数据都存储在内存单元中,而每个内存单元都有一个对应的地址, 只要通过这个地址就能找到对应单元中存储的数据.
    
    - 由于通过地址能找到所需的变量单元，所以我们说该地址指向了该变量单元。将地址形象化的称为“指针”
    
    - 内存单元的指针(地址)和内存单元的内容是两个不同的概念。  
        ![](https://i-blog.csdnimg.cn/blog_migrate/5811c587a63202c0f796f5062777e4e1.png)
    

#### 22.2. 什么是指针变量？
- 在C语言中,允许用一个变量来存放其它变量的地址, 这种专门用于存储其它变量地址的变量, 我们称之为指针变量  
    ![](https://i-blog.csdnimg.cn/blog_migrate/8f753c09b82a69c9dadcb4202561b681.png)
- 示例:

```c
    int age; // 定义一个普通变量
    age = 10; // Corrected: num = 10 to age = 10
    int *pnAge; // 定义一个指针变量
    pnAge = &age; // pnAge now holds the address of age
```

![](https://i-blog.csdnimg.cn/blog_migrate/90881853ee0ebbbfc6e70980094b5507.png)

#### 22.3. 定义指针变量的格式
- 指针变量的定义包括两个内容:
    - 指针类型说明,即定义变量为一个指针变量; (Specifies the type of data the pointer will point to)
    - 指针变量名;  
        ![](https://i-blog.csdnimg.cn/blog_migrate/af825cad3f90114734f89bb5841eb6f0.png)
- 示例:

```c
char ch = 'a';
char *p; // 一个用于指向字符型变量的指针
p = &ch;  

int num = 666;
int *q; // 一个用于指向整型变量的指针
q = &num;  
```

> - 其中,*表示这是一个指针变量
> - 变量名即为定义的指针变量名
> - 类型说明符表示本指针变量所指向的变量的数据类型

---

#### 22.4. 指针变量的初始化方法
- 指针变量初始化的方法有两种:定义的同时进行初始化和先定义后初始化
    - 定义的同时进行初始化

```c
int a = 5;
int *p = &a; // p is initialized to hold the address of a
```

- 先定义后初始化

```c
int a = 5;
int *p;
p=&a; // p is assigned the address of a
```

- 把指针初始化为NULL (A good practice if not immediately assigning a valid address)

```c
int *p=NULL; // NULL is a macro, typically (void*)0
// int *q=0; // 0 is also a valid null pointer constant
```

- 不合法的初始化:
    - 指针变量只能存储地址, 不能存储其它类型 (like arbitrary integers, unless they are cast to a pointer type, which is usually unsafe)

```c
int *p_illegal; // Renamed to avoid conflict
// p_illegal =  250; // 错误写法: Assigning an integer to a pointer without a cast.
                   // This is highly platform-dependent and usually incorrect.
```

- 给指针变量赋值时,指针变量前不能再加“*” (When assigning an address to a pointer variable, use the pointer variable's name directly. `*p` refers to the value *at* the address p points to.)

```c
int a_val = 10; // Renamed
int *p_assign; // Renamed
// *p_assign=&a_val; //错误写法: This attempts to assign the address of a_val
                   // to the memory location pointed to by p_assign (which is uninitialized).
p_assign = &a_val; // Correct: Assigns the address of a_val to the pointer p_assign.
```

- 注意点:
    
    - 多个指针变量可以指向同一个地址  
        ![](https://i-blog.csdnimg.cn/blog_migrate/8735d401fa1890deca4048b8fdeb411f.png)
- 指针的指向是可以改变的
    

```c
int a_point = 5; // Renamed
int *p_change = &a_point; // Renamed
int b_point = 10; // Renamed
p_change = &b_point; // 修改指针指向, p_change now points to b_point
```

- 指针没有初始化里面是一个垃圾值,这时候我们这是一个野指针
    - 野指针可能会导致程序崩溃
    - 野指针访问你不该访问数据
    - 所以指针必须初始化才可以访问其所指向存储区域  
        ![](https://i-blog.csdnimg.cn/blog_migrate/c52fe9e62b7809a1f43a44a7ef2f5db8.png)

---

#### 22.5. 访问指针所指向的存储空间
- C语言中提供了地址运算符&来表示变量的地址。其一般形式为:
    - `&变量名;`
- C语言中提供了*来定义指针变量和访问指针变量指向的内存存储空间 (Dereference operator)
    - 在定义变量的时候 * 是一个类型说明符,说明定义的这个变量是一个指针变量

```c
int *p_def = NULL; // 定义指针变量 p_def
```

- 在不是定义变量的时候 *是一个操作符,代表访问指针所指向存储空间 (Dereferencing)

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int a_access = 5; // Renamed
    int *p_access = &a_access; // Renamed
    printf("a_access = %d\n", *p_access); // 访问指针变量 (dereferences p_access to get value of a_access)
    return 0; // Added return
}
```

---

#### 22.6. 指针类型
- 在同一种编译器环境下,一个指针变量所占用的内存空间是固定的。 (e.g., 4 bytes on a 32-bit system, 8 bytes on a 64-bit system, regardless of the type it points to).  
    ![](https://i-blog.csdnimg.cn/blog_migrate/c004690dc780fdfabb080e7d0c42229c.png)
    
- 虽然在同一种编译器下, 所有指针占用的内存空间是一样的,但不同类型的变量却占不同的字节数
    
    - 一个int占用4个字节，一个char占用1个字节，而一个double占用8字节；
    - 现在只有一个地址，我怎么才能知道要从这个地址开始向后访问多少个字节的存储空间呢，是4个，是1个，还是8个。
    - 所以指针变量需要它所指向的数据类型告诉它要访问多少个字节存储空间 (The type of the pointer determines how many bytes are read/written when dereferenced, and how pointer arithmetic works, e.g., `ptr++` increments by `sizeof(*ptr)`.)  
        ![](https://i-blog.csdnimg.cn/blog_migrate/e4d01e8ac24ceebce4e3e053d19dd41f.png)

---

#### 22.7. 二级指针
- 如果一个指针变量存放的又是另一个指针变量的地址,则称这个指针变量为指向指针的指针￼变量。也称为“二级指针”

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    char c = 'a';
    char *cp;   // Pointer to char
    cp = &c;    // cp holds address of c
    
    char **cp2; // Pointer to pointer to char (二级指针)
    cp2 = &cp;  // cp2 holds address of cp
    
    printf("c = %c\n", **cp2); // **cp2 first dereferences cp2 to get cp,
                               // then dereferences cp to get the value of c.
    return 0; // Added return
}
```

![](https://i-blog.csdnimg.cn/blog_migrate/49873b61702e7edba03edd7fb7b68723.png)

- 多级指针的取值规则 (Dereferencing)

```c
// int ***m1;  //取值***m1 (Correct, apply * three times)
// int *****m2; //取值*****m2 (Correct, apply * five times)
```

---

#### 22.8. 练习
- 定义一个函数交换两个变量的值 (Using pointers)
- 写一个函数，同时返回两个数的和与差 (Using pointers to return multiple values)

**解答:**
1.  **交换两个变量的值 (使用指针):**
    ```c
    ##include <stdio.h>
    void swap(int *ptr_a, int *ptr_b) {
        int temp = *ptr_a;
        *ptr_a = *ptr_b;
        *ptr_b = temp;
    }
    int main() {
        int x = 10, y = 20;
        printf("交换前: x = %d, y = %d\n", x, y);
        swap(&x, &y); // Pass addresses of x and y
        printf("交换后: x = %d, y = %d\n", x, y);
        return 0;
    }
    ```
2.  **同时返回两个数的和与差 (使用指针):**
    ```c
    ##include <stdio.h>
    void calculateSumAndDiff(int a, int b, int *sum_ptr, int *diff_ptr) {
        *sum_ptr = a + b;
        *diff_ptr = a - b;
    }
    int main() {
        int num1 = 15, num2 = 7;
        int sum_result, diff_result;
        calculateSumAndDiff(num1, num2, &sum_result, &diff_result);
        printf("%d 和 %d 的和是: %d\n", num1, num2, sum_result);
        printf("%d 和 %d 的差是: %d\n", num1, num2, diff_result);
        return 0;
    }
    ```

---

## 23. 指针与数组/字符串
#### 23.1. 指针访问数组元素
- 数组元素指针
    - 一个变量有地址,一个数组包含若干元素,每个数组元素也有相应的地址, 指针变量也可以保存数组元素的地址
    - 只要一个指针变量保存了数组元素的地址, 我们就称之为数组元素指针  
        ![](https://i-blog.csdnimg.cn/blog_migrate/ea866fc47f61618a5037790845d8a84c.png)

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    int a[5]; // Declaration
    // printf(“%p %p”, &(a[0]), a); //输出结果:0x1100, 0x1100 (Example addresses)
    printf("Address of a[0]: %p\n", (void*)&(a[0]));
    printf("Value of a (array name): %p\n", (void*)a); 
    // Both will print the same address, the base address of the array.
    return 0; // Added return
}
```

> - 注意: 数组名a不代表整个数组,只代表数组首元素的地址。 (When used in most expressions, it decays to a pointer to the first element.)
> - “p=a;”的作用是“把a数组的首元素的地址赋给指针变量p”,而不是“把数组a各元素的值赋给 p” (Correct)

---

- 指针访问数组元素 (Continued)
![](https://i-blog.csdnimg.cn/blog_migrate/3f9f69c81768f331a0e551ff6b76e99b.png)

```c
##include <stdio.h> // Added for printf
int main (void)
{
      int a[5] = {2, 4, 6, 8, 22};
      int *p;
      // p = &(a[0]); // p points to the first element
      p = a;       // Equivalent to p = &a[0];
      printf("%d %d\n",a[0],*p); // 输出结果: 2, 2
      
      // Accessing other elements using pointer arithmetic
      printf("a[1] = %d, *(p+1) = %d\n", a[1], *(p+1)); // 4, 4
      printf("a[2] = %d, p[2] = %d\n", a[2], p[2]);     // 6, 6 (p[i] is equivalent to *(p+i))
      return 0; // Added return
}
```

- 在指针指向数组元素时,允许以下运算:
    - 加一个整数(用+或+=),如p+1 (Moves pointer to the next element)
    - 减一个整数(用-或-=),如p-1 (Moves pointer to the previous element)
    - 自加运算,如p++,++p (Moves pointer to the next element)
    - 自减运算,如p–,--p (Moves pointer to the previous element)
    - Pointer subtraction: `ptr2 - ptr1` gives the number of elements between two pointers pointing into the same array.

![](https://i-blog.csdnimg.cn/blog_migrate/030089a7220444b5e149e510964b3506.png)

> - 如果指针变量p已指向数组中的一个元素,则p+1`指向`同一数组中的下一个元素,p-1`指向`同 一数组中的上一个元素。 (The actual address change is `sizeof(*p)` bytes.)

- 结论: 访问数组元素,可用下面两种方法:
    - 下标法, 如a[i]形式
    - 指针法, *(p+i)形式 (or p[i] if p points to the start of the array or an element)

![](https://i-blog.csdnimg.cn/blog_migrate/5db4d58a1dd887e89b88b77a78dbee3d.png)

- 注意:
    - 数组名虽然是数组的首地址，但是数组名所所保存的数组的首地址是不可以更改的 (An array name is not an lvalue, so you can't do `x++` if `x` is an array name.)

```c
// int x[10];
// x++;  //错误: lvalue required as increment operand
// int* p = x; // p gets the address of x[0]
// p++; //正确: p now points to x[1]
```

---

#### 23.2. 指针与字符串
- 定义字符串的两种方式
    - 字符数组

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    char string_arr[]="I love lnj!"; // Renamed to avoid conflict
    printf("%s\n",string_arr);
    return 0; // Added return
}
```

- - 字符串指针指向字符串 (String literal)

```c
// 数组名保存的是数组第0个元素的地址, 指针也可以保存第0个元素的地址
// char *str = "abc"; // str points to the first character of the string literal "abc"
                     // String literals are often stored in a read-only section of memory.
```

![](https://i-blog.csdnimg.cn/blog_migrate/651ce3e0ab389db46468d25b37747648.png)

- 字符串指针使用注意事项
    - 可以查看字符串的每一个字符

```c
##include <stdio.h> // Added for printf
##include <string.h> // Added for strlen
int main() { // Added main wrapper
    char *str_ptr = "lnj"; // Renamed
    for(int i = 0; i < strlen(str_ptr);i++) // Or: for(int i = 0; *(str_ptr+i) != '\0'; i++)
    {
      printf("%c-", *(str_ptr+i)); 
    }
    printf("\n"); // Added newline
    return 0; // Added return
}
// 输出结果:l-n-j-
```

- - 不可以修改字符串内容 (If the pointer points to a string literal, as these are often in read-only memory. Modifying them is undefined behavior.)

```c
//   + 使用字符数组来保存的字符串是保存栈里的 (or static/global memory),保存栈里面东西是可读可写,所有可以修改字符串中的的字符
//     char modifiable_str[] = "lnj"; modifiable_str[2] = 'y'; // OK
//   + 使用字符指针来保存字符串,它保存的是字符串常量地址,常量区是只读的,所以我们不可以修改字符串中的字符
// char *str_literal = "lnj";
// *(str_literal+2) = 'y'; // 错误 (Undefined Behavior, likely crash)
```

- - 不能够直接接收键盘输入 (Into an uninitialized pointer, or a pointer to a string literal)

```c
// 错误的原因是:str是一个野指针,他并没有指向某一块内存空间
// 所以不允许这样写如果给str分配内存空间是可以这样用 的
// char *str_input; // Uninitialized pointer
// scanf("%s", str_input); // DANGEROUS: writing to an uninitialized pointer

// Correct way: allocate memory for the string
// char buffer[100];
// scanf("%99s", buffer); // Read into an allocated buffer
// Or dynamically:
// char *dynamic_str = malloc(100 * sizeof(char));
// if (dynamic_str) {
//     scanf("%99s", dynamic_str);
//     // ... use dynamic_str ...
//     free(dynamic_str);
// }
```

---

## 24. 更高级的指针应用
#### 24.1. 指向函数指针
- 为什么指针可以指向一个函数？
    - 函数作为一段程序，在内存中也要占据部分存储空间，它也有一个起始地址 (The address of its first instruction).
    - 函数有自己的地址，那就好办了，我们的指针变量就是用来存储地址的。
    - 因此可以利用一个指针指向一个函数。其中，函数名就代表着函数的地址。 (When used without `()`, a function name decays to a pointer to the function).
- 指针函数的定义 (Function pointer definition)
    - 格式: `返回值类型 (*指针变量名)(形参类型列表);`

```c
##include <stdio.h> // Added for printf

int sum(int a,int b)
{
    return a + b;
}

int main() { // Added main wrapper
    int (*p_func)(int,int); // p_func is a pointer to a function that takes two ints and returns an int
    p_func = sum;         // Assign address of sum to p_func (or p_func = &sum;)
    
    int result = p_func(10, 20); // Call sum via the function pointer
    // int result = (*p_func)(10, 20); // Also valid, older syntax for calling
    printf("Sum result via pointer: %d\n", result);
    return 0; // Added return
}
```

- 指针函数定义技巧 (More like "function pointer declaration/definition syntax")
    
    - 1、把要指向函数头拷贝过来 (Start with the function signature)
    - 2、把函数名称使用小括号括起来 (Put `*` and the pointer name inside parentheses)
    - 3、在函数名称前面加上一个*
    - 4、修改函数名称 (The pointer name)
    - Example: `int sum(int a, int b)` -> `int (*my_func_ptr)(int a, int b);`
- 应用场景
    
    - 调用函数 (As shown above)
    - 将函数作为参数在函数间传递 (Callbacks, higher-order functions)
- 注意点:
    
    - 由于这类指针变量存储的是一个函数的入口地址，所以对它们作加减运算(比如p++)是无意义的 (And typically not allowed by the compiler for function pointers).
    - 函数调用中"(指针变量名)"的两边的括号不可少,其中的不应该理解为求值运算,在此处它 只是一种表示符号 (Actually, `p_func(10, 20)` is the more common and modern syntax for calling via a function pointer. The `(*p_func)(10, 20)` syntax is also valid and emphasizes the dereferencing, but the parentheses around `*p_func` are crucial if used.)

---

# **第七部分：复合数据类型**

## 25. 结构体 (Struct)
#### 25.1. 什么是结构体？
- 结构体和数组一样属于构造类型
- 数组是用于保存一组相同类型数据的, 而结构体是用于保存一组不同类型数组的 (More accurately, a structure is a collection of one or more variables, possibly of different types, grouped together under a single name for convenient handling.)
    - 例如,在学生登记表中,姓名应为字符型;学号可为整型或字符型;年龄应为整型;性别应为字符型;成绩可为整型或实型。
    - 显然这组数据不能用数组来存放, 为了解决这个问题,C语言中给出了另一种构造数据类型——“结构(structure)”或叫“结构体”。

---

#### 25.2. 定义结构体类型
- 在使用结构体之前必须先定义结构体类型, 因为C语言不知道你的结构体中需要存储哪些类型数据, 我们必须通过定义结构体类型来告诉C语言, 我们的结构体中需要存储哪些类型的数据
- 格式:

```c
struct　结构体名{ // struct tag
     类型名1　成员名1;
     类型名2　成员名2;
     // ……
     类型名n　成员名n;
 };
```

- 示例:

```c
struct Student {
    char *name; // 姓名 (Pointer to char, typically for a string)
    int age; // 年龄
    float height; // 身高
};
```

---

#### 25.3. 定义结构体变量
- 定好好结构体类型之后, 我们就可以利用我们定义的结构体类型来定义结构体变量
    
- 格式: `struct 结构体名 结构体变量名;`  
    ![](https://i-blog.csdnimg.cn/blog_migrate/e5d74b14bec7729d0abf342403dc46ed.png)
    
- 先定义结构体类型，再定义变量
    

```c
struct Student {
     char *name;
     int age;
 }; // This defines the type 'struct Student'

 struct Student stu; // This defines a variable 'stu' of type 'struct Student'
```

- 定义结构体类型的同时定义变量

```c
struct Student {
    char *name;
    int age;
} stu; // Defines type 'struct Student' AND a variable 'stu' of this type
```

- 匿名结构体定义结构体变量 (The structure type itself has no name)

```c
struct { // Anonymous structure
    char *name;
    int age;
} stu_anon; // stu_anon is a variable of this anonymous structure type.
           // You cannot create other variables of this exact anonymous type later.
```

> - 第三种方法与第二种方法的区别在于,第三种方法中省去了结构体类型名称,而直接给出结构变量,这种结构体最大的问题是结构体类型不能复用 (Correct, you can't declare another variable of the same anonymous struct type easily.)

---

#### 25.4. 结构体成员访问
- 一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：`结构体变量名.成员名` (Dot operator)

```c
##include <stdio.h> // Added for printf
struct Student {
     char *name;
     int age;
 };
int main() { // Added main wrapper
    struct Student stu;
    // 访问stu的age成员
    stu.age = 27;
    stu.name = "LNJ"; // Assigning a string literal to char*
    printf("age = %d, name = %s\n", stu.age, stu.name); // Corrected format specifier
    return 0; // Added return
}
```

---

#### 25.5. 结构体变量的初始化
- 定义的同时按顺序初始化 (Using an initializer list)

```c
struct Student_init1 { // Renamed to avoid conflict
     char *name;
     int age;
 };
// struct Student_init1 stu1 = {"lnj", 27}; // stu1 is not defined here, this is just the type
```
Corrected example:
```c
##include <stdio.h>
struct Student_init1 {
     char *name;
     int age;
};
int main() {
    struct Student_init1 stu1 = {"lnj", 27}; 
    printf("Name: %s, Age: %d\n", stu1.name, stu1.age);
    return 0;
}
```

- 定义的同时不按顺序初始化 (Designated initializers - C99)

```c
##include <stdio.h> // Added for printf
struct Student_init2 { // Renamed
     char *name;
     int age;
 };
int main() { // Added main wrapper
    struct Student_init2 stu2 = {.age = 35, .name = "lnj"};
    printf("Name: %s, Age: %d\n", stu2.name, stu2.age);
    return 0; // Added return
}
```

- 先定义后逐个初始化

```c
##include <stdio.h> // Added for printf
struct Student_init3 { // Renamed
     char *name;
     int age;
 };
int main() { // Added main wrapper
    struct Student_init3 stu3;
    stu3.name = "lnj";
    stu3.age = 35;
    printf("Name: %s, Age: %d\n", stu3.name, stu3.age);
    return 0; // Added return
}
```

- 先定义后一次性初始化 (Using compound literal - C99)

```c
##include <stdio.h> // Added for printf
struct Student_init4 { // Renamed
     char *name;
     int age;
 };
int main() { // Added main wrapper
    struct Student_init4 stu4;
    stu4 = (struct Student_init4){"lnj", 35}; // Compound literal assignment
    printf("Name: %s, Age: %d\n", stu4.name, stu4.age);
    return 0; // Added return
}
```

---

#### 25.6. 结构体类型作用域
- 结构类型定义在函数内部的作用域与局部变量的作用域是相同的
    - 从定义的那一行开始, 直到遇到return或者大括号结束为止
- 结构类型定义在函数外部的作用域与全局变量的作用域是相同的
    - 从定义的那一行开始,直到本文件结束为止

```c
##include <stdio.h> // Added for printf

//定义一个全局结构体,作用域到文件末尾
struct Person_global{ // Renamed to avoid conflict
    int age;
    char *name;
};

void test_scope(); // Declaration

int main(int argc, const char * argv[])
{
    //定义局部结构体名为Person,会屏蔽全局结构体 (This is incorrect. Struct tags live in a separate namespace.
    // A local struct Person would not directly "shield" a global struct Person_global unless they had the same tag.)
    // For clarity, let's use different tags or typedefs.

    // Using the global struct type
    struct Person_global global_p_in_main;
    global_p_in_main.age = 30;
    global_p_in_main.name = "Main Global";
    printf("In main (global_p_in_main): Age: %d, Name: %s\n", global_p_in_main.age, global_p_in_main.name);

    //定义局部结构体类型 (This is a new, distinct type, local to main)
    struct Person_local_in_main{
        int age;
        // char *name; // If you want a name field for this local struct
    };
    
    struct Person_local_in_main pp;
    pp.age = 50;
    // pp.name = "zbz"; // This would cause an error as Person_local_in_main doesn't have 'name' member as defined.
    printf("In main (pp - local struct): Age: %d\n", pp.age);


    test_scope();
    return 0;
}

void test_scope() {
    //使用全局的结构体定义结构体变量p
    struct Person_global p_in_test = {10,"sb"}; // Using global struct Person_global
    printf("In test_scope (p_in_test): Age: %d, Name: %s\n",p_in_test.age,p_in_test.name);
}
```

---

#### 25.7. 结构体数组
- 结构体数组和普通数组并无太大差异, 只不过是数组中的元素都是结构体而已
- 格式: `struct 结构体类型名称 数组名称[元素个数]`

```c
struct Student_arr { // Renamed
    char *name;
    int age;
};
// struct Student_arr stu_arr[2]; // Declaration of an array of 2 Student_arr structs
```

- 结构体数组初始化和普通数组也一样, 分为先定义后初始化和定义同时初始化
    - 定义同时初始化

```c
##include <stdio.h> // Added for printf
struct Student_arr_init { // Renamed
    char *name;
    int age;
};
int main() { // Added main wrapper
    struct Student_arr_init stu_arr[2] = {{"lnj", 35},{"zs", 18}}; 
    printf("Student 1: %s, %d\n", stu_arr[0].name, stu_arr[0].age);
    printf("Student 2: %s, %d\n", stu_arr[1].name, stu_arr[1].age);
    return 0; // Added return
}
```

- - 先定义后初始化 (Element by element, or using compound literals for each element if C99+)

```c
##include <stdio.h> // Added for printf
struct Student_arr_def_init { // Renamed
    char *name;
    int age;
};
int main() { // Added main wrapper
    struct Student_arr_def_init stu_arr_di[2]; 
    stu_arr_di[0].name = "lnj"; // Assigning members individually
    stu_arr_di[0].age = 35;
    stu_arr_di[1] = (struct Student_arr_def_init){"zs", 18}; // Using compound literal for the second element
    
    printf("Student 1: %s, %d\n", stu_arr_di[0].name, stu_arr_di[0].age);
    printf("Student 2: %s, %d\n", stu_arr_di[1].name, stu_arr_di[1].age);
    return 0; // Added return
}
```

---

#### 25.8. 结构体指针
- 一个指针变量当用来指向一个结构体变量时,称之为结构体指针变量
- 格式: `struct 结构名 *结构指针变量名`
- 示例:

```c
##include <stdio.h> // Added for printf

      // 定义一个结构体类型
      struct Student_ptr_ex { // Renamed
          char *name;
          int age;
      };

int main() { // Added main wrapper
     // 定义一个结构体变量
     struct Student_ptr_ex stu = {"lnj", 18};

     // 定义一个指向结构体的指针变量
     struct Student_ptr_ex *p;

    // 指向结构体变量stu
    p = &stu;

     /*
      这时候可以用3种方式访问结构体的成员
      */
     // 方式1：结构体变量名.成员名
     printf("方式1: name=%s, age = %d \n", stu.name, stu.age);

     // 方式2：(*指针变量名).成员名 (Parentheses around *p are crucial)
     printf("方式2: name=%s, age = %d \n", (*p).name, (*p).age);

     // 方式3：指针变量名->成员名 (Arrow operator)
     printf("方式3: name=%s, age = %d \n", p->name, p->age);

     return 0;
 }
```

- 通过结构体指针访问结构体成员, 可以通过以下两种方式
    - `(*结构指针变量).成员名`
    - `结构指针变量->成员名`(用熟)

> - `(*pstu).num` 两侧的括号不可少,因为成员符“.”的优先级高于“*”。 (Correct, `.` has higher precedence than `*` dereference)
> - 如去掉括号写作`*pstu.num`则等效于`*(pstu.num)`,这样,意义就完全不对了。 (It would mean dereferencing the `num` member of `pstu`, assuming `pstu` itself was a struct with a member `num` that was a pointer, which is not the case here. `pstu` is the pointer.)

---

#### 25.9. 结构体内存分析
- 给结构体变量开辟存储空间和给普通开辟存储空间一样, 会从内存地址大的位置开始开辟 (This describes typical stack allocation behavior where the stack grows towards lower addresses. Heap allocation is different.)
- 给结构体成员开辟存储空间和给数组元素开辟存储空间一样, 会从所占用内存地址小的位置开始开辟 (Within the allocated block for the struct, members are generally laid out in order of declaration, from lower to higher addresses, subject to padding.)
- 结构体变量占用的内存空间永远是所有成员中占用内存最大成员的倍数(对齐问题) (This is a common simplification for understanding padding, but not strictly "always". The actual size is influenced by padding rules to ensure members are aligned according to their type's requirements. The total size is often padded to be a multiple of the alignment requirement of the largest member or the struct's overall alignment requirement.)

> +多实际的计算机系统对基本类型数据在内存中存放的位置有限制,它们会要求这些数据的起始地址的值是 某个数k的倍数,这就是所谓的内存对齐,而这个k则被称为该数据类型的对齐模数(alignment modulus)。
> 
> - 这种强制的要求一来简化了处理器与内存之间传输系统的设计,二来可以提升读取数据的速度。比如这么一种处理器,它每次读写内存的时候都从某个8倍数的地址开始,一次读出或写入8个字节的数据,假如软件能 保证double类型的数据都从8倍数地址开始,那么读或写一个double类型数据就只需要一次内存操作。否则,我们就可能需要两次内存操作才能完成这个动作,因为数据或许恰好横跨在两个符合对齐要求的8字节 内存块上

###### 25.9.1. 结构体变量占用存储空间大小

```c
##include <stdio.h> // Added for printf
    struct Person_mem1{ // Renamed
        int age; // 4 bytes (assuming 4-byte int)
        char ch; // 1 byte
        // Padding of 3 bytes might be added here to align 'score'
        double score; // 8 bytes
    };
int main() { // Added main wrapper
    struct Person_mem1 p1; // Renamed
    printf("sizeof(p1) = %zu\n", sizeof(p1)); // Likely 16 (4 + 1 + 3_padding + 8)
    return 0; // Added return
}
```

- 占用内存最大属性是score, 占8个字节, 所以第一次会分配8个字节 (This explanation of allocation in chunks is not how struct layout works. Members are laid out sequentially, with padding inserted as needed.)
- 将第一次分配的8个字节分配给age4个,分配给ch1个, 还剩下3个字节
- 当需要分配给score时, 发现只剩下3个字节, 所以会再次开辟8个字节存储空间
- 一共开辟了两次8个字节空间, 所以最终p占用16个字节
**Corrected Explanation for `struct Person_mem1`:**
1.  `age` (int, 4 bytes): Placed at offset 0.
2.  `ch` (char, 1 byte): Placed at offset 4.
3.  `score` (double, 8 bytes): Requires 8-byte alignment. The next available 8-byte aligned offset after `ch` (at offset 4+1=5) is offset 8. So, 3 bytes of padding are inserted after `ch`. `score` is placed at offset 8.
4.  Total size = offset of `score` + size of `score` = 8 + 8 = 16 bytes. The total size is a multiple of the largest alignment (8 for double).

```c
##include <stdio.h> // Added for printf
    struct Person_mem2{ // Renamed
        int age; // 4 bytes
        double score; // 8 bytes (requires 8-byte alignment, so 4 bytes padding after age)
        char ch; // 1 byte
        // Padding at the end to make total size a multiple of max alignment (8)
    };
int main() { // Added main wrapper
    struct Person_mem2 p2; // Renamed
    printf("sizeof(p2) = %zu\n", sizeof(p2)); // Likely 24 (4_age + 4_pad1 + 8_score + 1_ch + 7_pad2)
    return 0; // Added return
}
```
**Corrected Explanation for `struct Person_mem2`:**
1.  `age` (int, 4 bytes): Placed at offset 0.
2.  `score` (double, 8 bytes): Requires 8-byte alignment. The next available offset is 4. To align `score` to an 8-byte boundary, 4 bytes of padding are inserted after `age`. `score` is placed at offset 8.
3.  `ch` (char, 1 byte): Placed at offset 8 + 8 = 16.
4.  End of struct is at offset 16 + 1 = 17. The largest alignment requirement is 8 (for `double`). The total size must be a multiple of 8. The next multiple of 8 after 17 is 24. So, 24 - 17 = 7 bytes of padding are added at the end.
5.  Total size = 24 bytes.

---

#### 25.10. 结构体嵌套定义
- 成员也可以又是一个结构,即构成了嵌套的结构

```c
struct Date{
     int month;
     int day;
     int year;
}; // Semicolon added

struct Student_nested{ // Renamed
     int num;
    char *name;
    char sex;
    struct Date birthday; // Nested struct Date
    float score; // Corrected: Float to float
};
```

- 在stu中嵌套存储Date结构体内容  
    ![](https://i-blog.csdnimg.cn/blog_migrate/318ed3ae55df4775096b1d531419ca11.png)

> - 注意:
> - 结构体不可以嵌套自己变量 (A struct cannot contain a member of its own type directly, as this would lead to infinite size),可以嵌套指向自己这种类型的指针 (This is how linked lists are made).
> 
> ```c
> struct Student_self {
>     int age;
>     // struct Student_self stu; // Error: field 'stu' has incomplete type
>     struct Student_self *next_student; // OK: pointer to its own type
> };
> ```

- 对嵌套结构体成员的访问
    - 如果某个成员也是结构体变量，可以连续使用成员运算符"."访问最低一级成员

```c
##include <stdio.h> // Added for printf

struct Date_access { // Renamed
       int year;
       int month;
       int day;
  };

  struct Student_access { // Renamed
      char *name;
      struct Date_access birthday;
 };

int main() { // Added main wrapper
    struct Student_access stu_acc; // Renamed
    stu_acc.name = "LNJ";
    stu_acc.birthday.year = 1986;
    stu_acc.birthday.month = 9;
    stu_acc.birthday.day = 10;

    printf("Name: %s\n", stu_acc.name);
    printf("Birthday: %d-%02d-%02d\n", stu_acc.birthday.year, stu_acc.birthday.month, stu_acc.birthday.day);
    return 0; // Added return
}
```

---

#### 25.11. 结构体和函数
- 结构体虽然是构造类型, 但是结构体之间赋值是值拷贝, 而不是地址传递 (Correct, struct assignment copies member values. If members are pointers, the pointer values are copied, not the data they point to.)

```c
##include <stdio.h> // Added for printf
##include <string.h> // For strcpy if names were char arrays

    struct Person_assign{ // Renamed
        char *name; // Pointer to string literal
        int age;
    };
int main() { // Added main wrapper
    struct Person_assign p1 = {"lnj", 35};
    struct Person_assign p2;
    p2 = p1; // Member-wise copy. p2.name now points to the same string literal "lnj" as p1.name.
    
    // p2.name = "zs"; // This makes p2.name point to a *different* string literal "zs".
                      // It does not modify the string "lnj".
                      // If name were a char array (e.g., char name[20];), then
                      // strcpy(p2.name, "zs"); would modify p2's copy.

    printf("p1.name = %s, p1.age = %d\n", p1.name, p1.age); 
    printf("p2.name = %s, p2.age = %d\n", p2.name, p2.age); 

    p2.name = "zs"; // p2.name now points to "zs"
    p2.age = 40;

    printf("After p2 modification:\n");
    printf("p1.name = %s, p1.age = %d\n", p1.name, p1.age); // p1 is unaffected
    printf("p2.name = %s, p2.age = %d\n", p2.name, p2.age); 
    return 0; // Added return
}
```

- 所以结构体变量作为函数形参时也是值传递, 在函数内修改形参, 不会影响外界实参 (A copy of the struct is passed to the function.)

```c
##include <stdio.h>

struct Person_func_param{ // Renamed
    char *name;
    int age;
};

void test_struct_param(struct Person_func_param per); // Declaration

int main()
{
    struct Person_func_param p1 = {"lnj", 35};
    printf("Before test_struct_param: p1.name = %s, p1.age = %d\n", p1.name, p1.age); 
    test_struct_param(p1); // A copy of p1 is passed
    printf("After test_struct_param: p1.name = %s, p1.age = %d\n", p1.name, p1.age); // p1 remains "lnj", 35
    return 0;
}
void test_struct_param(struct Person_func_param per){ // 'per' is a copy of p1
    per.name = "zs"; // Modifies the 'name' pointer of the local copy 'per'
    per.age = 99;    // Modifies the 'age' of the local copy 'per'
    printf("Inside test_struct_param: per.name = %s, per.age = %d\n", per.name, per.age);
}
```

---

## 26. 共用体 (Union)
#### 26.1. 共用体基本概念
- 和结构体不同的是, 结构体的每个成员都是占用一块独立的存储空间, 而共用体所有的成员都占用同一块存储空间 (The size of a union is the size of its largest member. All members start at the same memory address.)
- 和结构体一样, 共用体在使用之前必须先定义共用体类型, 再定义共用体变量
- 定义共用体类型格式:

```c
union 共用体名{ // union tag
    数据类型 成员名1; // Corrected: 属性名称 to 成员名
    数据类型 成员名2;
    // ...   ....
};
```

- 定义共用体类型变量格式:

```c
union 共用体名 共用体变量名称;
```

- 特点: 由于所有属性共享同一块内存空间, 所以只要其中一个属性发生了改变, 其它的属性都会受到影响 (Accessing a member other than the one most recently written to is implementation-defined or can lead to misinterpretation of data, except for some specific cases like inspecting the common initial sequence of structs within a union - C99).
- 示例:

```c
##include <stdio.h> // Added for printf

    union Test_union{ // Renamed
        int age;
        char ch;
    };
int main() { // Added main wrapper
    union Test_union t;
    printf("sizeof(t) = %zu\n", sizeof(t)); // Will be sizeof(int), typically 4

    t.age = 33; // 33 in binary (e.g., 00000000 00000000 00000000 00100001)
    printf("t.age = %d\n", t.age); // 33
    
    t.ch = 'a'; // 'a' is ASCII 97 (binary 01100001). This overwrites the first byte of t.age.
    printf("t.ch = %c\n", t.ch); // a
    
    // The value of t.age is now different because its first byte was overwritten by 'a'.
    // The exact value depends on endianness.
    // If little-endian, t.age might become something like 0x......61 (where ... are original bytes of 33)
    // If 33 was 0x00000021, and 'a' (0x61) overwrites the LSB, t.age becomes 0x00000061 = 97.
    printf("t.age after t.ch='a' = %d\n", t.age); // Often 97 if int is 4 bytes and char overwrites LSB
    return 0; // Added return
}
```

- 共用体的应用场景
    - （1）通信中的数据包会用到共用体，因为不知道对方会发送什么样的数据包过来，用共用体的话就简单了，定义几种格式的包，收到包之后就可以根据包的格式取出数据。 (e.g., a packet might have a type field, and a union for different data structures based on type.)
    - （2）节约内存。如果有2个很长的数据结构，但不会同时使用，比如一个表示老师，一个表示学生，要统计老师和学生的情况，用结构体就比较浪费内存，这时就可以考虑用共用体来设计。  
        +（3）某些应用需要大量的临时变量，这些变量类型不同，而且会随时更换。而你的堆栈空间有限，不能同时分配那么多临时变量。这时可以使用共用体让这些变量共享同一个内存空间，这些临时变量不用长期保存，用完即丢，和寄存器差不多，不用维护。

---

## 27. 枚举 (Enum)
#### 27.1. 枚举基本概念
- 什么是枚举类型?
    
    - 在实际问题中,有些变量的取值被限定在一个有限的范围内。例如,一个星期内只有七天,一年只有十二个月,一个班每周有六门课程等等。如果把这些量说明为整型,字符型或其它类型 显然是不妥当的。
    - C语言提供了一种称为“枚举”的类型。在“枚举”类型的定义中列举出所有可能的取值, 被说明为该“枚举”类型的变量取值不能超过定义的范围。 (Enumerators are integer constants. An enum variable can hold any int value, but ideally, it holds one of the enumerator values.)
    - 该说明的是,枚举类型是一种基本数据类型 (It's an integer type),而不是一种构造类型,因为它不能再分解为任何基本类型。  
        ![](https://i-blog.csdnimg.cn/blog_migrate/05f249ebc33ff593c9659788bf985428.png)
- 枚举类型的定义
    
    - 格式:

```c
enum　枚举名　{ // enum tag
    枚举元素1, // Enumerator
    枚举元素2,
    // ……
};
```

- - 示例:

```c
// 表示一年四季
enum Season {
    Spring, // Defaults to 0
    Summer, // Defaults to 1
    Autumn, // Defaults to 2
    Winter  // Defaults to 3
};
```

- 枚举变量
    - 先定义枚举类型，再定义枚举变量

```c
enum Season_def1 { // Renamed
    Spring_d1, Summer_d1, Autumn_d1, Winter_d1 // Renamed enumerators
};
// enum Season_def1 s1; // s1 is a variable of type enum Season_def1
```

- - 定义枚举类型的同时定义枚举变量

```c
enum Season_def2 { // Renamed
    Spring_d2, Summer_d2, Autumn_d2, Winter_d2
} s2; // s2 is a variable of type enum Season_def2
```

- 省略枚举名称，直接定义枚举变量 (Anonymous enum)

```c
enum { // Anonymous enum type
    Spring_anon, Summer_anon, Autumn_anon, Winter_anon // Renamed
} s_anon; // s_anon is a variable of this anonymous enum type
```

- 枚举类型变量的赋值和使用

```c
##include <stdio.h> // Added for printf

enum Season_use { // Renamed
    Spring_u, // 0
    Summer_u, // 1
    Autumn_u, // 2
    Winter_u  // 3
}; // Semicolon added

int main() { // Added main wrapper
    enum Season_use s_use; // Renamed variable
    s_use = Spring_u; // 等价于 s_use = 0;
    printf("%d\n", s_use); // Prints 0

    s_use = Winter_u; // This is equivalent to s_use = 3
    // s_use = 3; // 等价于 s_use = Winter_u; (This is also valid, assigning an int to an enum variable)
    printf("%d\n", s_use); // Prints 3
    return 0; // Added return
}
```

- 枚举使用的注意
    - C语言编译器会将枚举元素(spring、summer等)作为整型常量处理，称为枚举常量。
    - 枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1。
    - 也可以在定义枚举类型时改变枚举元素的值

```c
enum Season_val1 { // Renamed
    Spring_v1, // 0
    Summer_v1, // 1
    Autumn_v1, // 2
    Winter_v1  // 3
};
// 也就是说Spring_v1的值为0，Summer_v1的值为1，Autumn_v1的值为2，Winter_v1的值为3
```

```c
enum Season_val2 { // Renamed
    Spring_v2 = 9, // Spring_v2 is 9
    Summer_v2,     // Summer_v2 is 10 (previous + 1)
    Autumn_v2,     // Autumn_v2 is 11
    Winter_v2      // Winter_v2 is 12
};
// 也就是说Spring_v2的值为9，Summer_v2的值为10，Autumn_v2的值为11，Winter_v2的值为12
```

---

# **第八部分：内存管理**

## 28. 内存区域
#### 28.1. 进程空间
- 程序，是经源码编译后的可执行文件，可执行文件可以多次被执行，比如我们可以多次打开 office。
- 而进程，是程序加载到内存后开始执行，至执行结束，这样一段时间概念，多次打开的wps,每打开一次都是一个进程，当我们每关闭一个 office，则表示该进程结束。
- 程序是静态概念，而进程动态/时间概念。  
    ###### 28.1.1. 进程空间图示  
    有了进程和程序的概念以后，我们再来看一下，程序被加载到内存以后内存空间布局是什么样的  
    ![](https://i-blog.csdnimg.cn/blog_migrate/433ff08929b628f87ee9a63786f5a2f1.png)
    (Typical memory layout for a process on many systems includes: Text Segment (code), Data Segment (initialized global/static), BSS Segment (uninitialized global/static), Heap, Stack, and sometimes areas for command-line arguments/environment variables, and shared libraries.)

---

#### 28.2. 栈内存(Stack)
- 栈中存放任意类型的变量，但必须是 auto 类型修饰的，即自动类型的局部变量， 随用随开，用完即消。 (Also function parameters, return addresses, and saved registers for function calls.)
- 内存的分配和销毁系统自动完成，不需要人工干预 (Managed by the compiler and runtime system).
- 栈的最大尺寸固定，超出则引起栈溢出 (Stack Overflow).
    - 局部变量过多，过大 或 递归层数太多等就会导致栈溢出

```c
// int ages[10240*10240]; // Likely to cause stack overflow if declared as a local variable
                        // due to its large size (approx 400MB if int is 4 bytes).
```

```c
##include <stdio.h>

int main()
{
    // 存储在栈中, 内存地址从大到小 (Stack typically grows towards lower addresses on x86/x64)
    int a = 10;
    int b = 20;
    printf("&a = %p\n", (void*)&a); 
    printf("&b = %p\n", (void*)&b); // &b will likely be a lower address than &a

    return 0;
}
```

---

#### 28.3. 堆内存(Heap)
- 堆内存可以存放任意类型的数据，但需要自己申请与释放 (Dynamically allocated memory).
- 堆大小，想像中的无穷大，但实际使用中，受限于实际内存的大小和内存是否连续性 (Limited by available system memory and address space. Fragmentation can also be an issue.)

```c
##include <stdlib.h> // For malloc
// int *p = (int *)malloc(10240 * 10240 * sizeof(int)); // Requesting a very large block (e.g., ~400MB)
                                                     // May or may not succeed depending on system resources.
```

```c
##include <stdio.h>
##include <stdlib.h>

int main()
{
    // 存储在堆中, 内存地址从小到大 (Heap addresses are typically allocated from lower to higher addresses,
    // but the exact behavior is up to the memory allocator. Subsequent allocations are not guaranteed
    // to be at higher addresses than previous ones if memory has been freed in between.)
    int *p1 = malloc(sizeof(int)); // Corrected: malloc takes size in bytes
    if (p1) *p1 = 10; // Check if malloc succeeded

    int *p2 = malloc(sizeof(int));
    if (p2) *p2 = 20;
   
    printf("p1 = %p\n", (void*)p1); 
    printf("p2 = %p\n", (void*)p2); 

    free(p1); // Always free allocated memory
    free(p2);
    return 0;
}
```

---

## 29. 动态内存分配
#### 29.1. `malloc` 函数

|函数声明|`void * malloc(size_t _Size);`|
|---|---|
|所在文件|`stdlib.h`|
|函数功能|申请堆内存空间并返回,所申请的空间并未初始化。|
|常见的初始化方法是|`memset` 字节初始化。 (Or `calloc` which initializes to zero)|
|参数及返回解析||
|参数|`size_t _size` 表示要申请的字节数 (Corrected: not char数 but byte数)|
|返回值|`void *` 成功返回非空指针指向申请的空间 ，失败返回 `NULL`|

```c
##include <stdio.h>
##include <stdlib.h>
##include <string.h> // For memset

int main()
{
    /*
     * malloc
     * 第一个参数: 需要申请多少个字节空间
     * 返回值类型: void *
     */ 
    int *p = (int *)malloc(sizeof(int)); // Allocate space for one int
    if (p == NULL) { // Always check if malloc failed
        printf("内存分配失败！\n");
        return 1;
    }
    // printf("p (before memset) = %d\n", *p); // Value is indeterminate (垃圾数据)
    
    /*
     * memset
     * 第一个参数: 需要初始化的内存地址
     * 第二个参数: 需要初始化的值 (interpreted as an unsigned char)
     * 第三个参数: 需要初始化多少个字节
     */ 
    memset(p, 0, sizeof(int)); // 对申请的内存空间进行初始化为0
    printf("p (after memset) = %d\n", *p); // 初始化为0
    
    free(p); // Don't forget to free
    return 0;
}
```

#### 29.2. `free` 函数
- 注意: 通过malloc申请的存储空间一定要释放, 所以malloc和free函数总是成对出现

|函数声明|`void free(void *p);`|
|---|---|
|所在文件|`stdlib.h`|
|函数功能|释放申请的堆内存|
|参数及返回解析||
|参数|`void* p` 指向手动申请的空间 (Must be a pointer previously returned by `malloc`, `calloc`, or `realloc`, or `NULL`)|
|返回值|`void` 无返回|

```c
##include <stdio.h>
##include <stdlib.h>
##include <string.h>

int main()
{
    // 1.申请4个字节存储空间
    int *p = (int *)malloc(sizeof(int));
    if (p == NULL) return 1; // Allocation check

    // 2.初始化4个字节存储空间为0
    memset(p, 0, sizeof(int));
    printf("*p after init: %d\n", *p);

    // 3.释放申请的存储空间
    free(p);
    p = NULL; // Good practice to set pointer to NULL after freeing to prevent dangling pointer issues.
    return 0;
}
```

#### 29.3. `calloc` 函数

|函数声明|`void *calloc(size_t nmemb, size_t size);`|
|---|---|
|所在文件|`stdlib.h`|
|函数功能|申请堆内存空间并返回，所申请的空间，自动清零 (Initializes allocated memory to all bits zero).|
|参数及返回解析||
|参数|`size_t nmemb` 所需内存单元数量 (Number of elements)|
|参数|`size_t size` 内存单元字节数量 (Size of each element)|
|返回值|`void *` 成功返回非空指针指向申请的空间 ，失败返回 `NULL`|

```c
##include <stdio.h>
##include <stdlib.h>
// ##include <string.h> // Not needed for this calloc example

int main()
{
    /*
    // Using malloc and then initializing (for comparison)
    // 1.申请3块4个字节存储空间
    int *p_malloc = (int *)malloc(sizeof(int) * 3);
    if (p_malloc == NULL) return 1;
    // memset(p_malloc, 0, sizeof(int) * 3); // Manual zeroing
    // 2.使用申请好的3块存储空间
    p_malloc[0] = 1;
    p_malloc[1] = 3;
    p_malloc[2] = 5;
    printf("p_malloc[0] = %d\n", p_malloc[0]);
    printf("p_malloc[1] = %d\n", p_malloc[1]);
    printf("p_malloc[2] = %d\n", p_malloc[2]);
    // 3.释放空间
    free(p_malloc);
    */

    // Using calloc
    // 1.申请3块4个字节存储空间 (and initializes to zero)
    int *p_calloc = (int *)calloc(3, sizeof(int));
    if (p_calloc == NULL) {
        printf("calloc 内存分配失败！\n");
        return 1;
    }
    // Memory is already zero-initialized by calloc
    // printf("p_calloc[0] before assignment = %d\n", p_calloc[0]); // Should be 0

    // 2.使用申请好的3块存储空间
    p_calloc[0] = 1;
    p_calloc[1] = 3;
    p_calloc[2] = 5;
    printf("p_calloc[0] = %d\n", p_calloc[0]);
    printf("p_calloc[1] = %d\n", p_calloc[1]);
    printf("p_calloc[2] = %d\n", p_calloc[2]);
    // 3.释放空间
    free(p_calloc);
    p_calloc = NULL;

    return 0;
}
```

#### 29.4. `realloc` 函数

|函数声明|`void *realloc(void *ptr, size_t size);`|
|---|---|
|所在文件|`stdlib.h`|
|函数功能|扩容(缩小)原有内存的大小。通常用于扩容，缩小会会导致内存缩去的部分数据丢失。|
|参数及返回解析||
|参数|`void * ptr` 表示待扩容(缩小)的指针， `ptr` 为之前用 `malloc` 或者 `calloc` 分配的内存地址，或者 `NULL`.|
|参数|`size_t size` 表示扩容(缩小)后内存的大小 (new size in bytes). If size is 0, behavior is implementation-defined (might free or return NULL/unique pointer).|
|返回值|`void*` 成功返回非空指针指向新申请(或调整后)的空间 ，失败返回 `NULL` (original block is NOT freed if realloc fails).|

- 注意点:
    - 若参数`ptr==NULL`，则该函数等同于 `malloc(size)`
    - 返回的指针，可能与 `ptr` 的值相同，也有可能不同。若相同，则说明在原空间后面申请(或原地调整)，否则，则可能后续空间不足，重新申请的新的连续空间，原数据拷贝到新空间， 原有空间自动释放 (If a new block is allocated, the content of the old block is copied to the new block up to the minimum of the old and new sizes. The old block is then deallocated.)

```c
##include <stdio.h>
##include <stdlib.h>
// ##include <string.h> // Not needed for this realloc example

int main()
{
    // 1.申请4个字节存储空间 (using realloc with NULL ptr)
    int *p = NULL;
    p = (int *)realloc(p, sizeof(int)); // 此时等同于malloc(sizeof(int))
    if (p == NULL) {
        printf("realloc (as malloc) 失败！\n");
        return 1;
    }
    // 2.使用申请好的空间
    *p = 666;
    printf("*p = %d\n",  *p);
    // 3.释放空间
    free(p);
    p = NULL;

    return 0;
}
```

```c
##include <stdio.h>
##include <stdlib.h>
// ##include <string.h> // Not needed

int main()
{
    // 1.申请4个字节存储空间
    int *p = (int *)malloc(sizeof(int));
    if (p == NULL) return 1;
    *p = 123; // Initialize the first int
    printf("p (original) = %p, value = %d\n", (void*)p, *p);

    // 扩容到2个int的空间
    // 如果能在传入存储空间地址后面扩容, 返回传入存储空间地址
    // 如果不能在传入存储空间地址后面扩容, 返回一个新的存储空间地址, 原数据被拷贝
    int *new_p = (int *)realloc(p, sizeof(int) * 2);
    if (new_p == NULL) {
        printf("realloc 失败！原内存块 p 仍然有效且需要释放。\n");
        free(p); // Free original block if realloc fails
        return 1;
    }
    p = new_p; // Update p to point to the new (or possibly same) block

    printf("p (after realloc) = %p\n", (void*)p);
    // 2.使用申请好的空间
    // p[0] should still be 123
    p[1] = 666; // Initialize the new part
    printf("p[0] = %d, p[1] = %d\n",  p[0], p[1]);
    // 3.释放空间
    free(p);
    p = NULL;

    return 0;
}
```

---

## 30. 链表
- 链表实现了，内存零碎数据的有效组织。比如，当我们用 malloc 来进行内存申请的时候，当内存足够，但是由于碎片太多，没有连续内存时，只能以申请失败而告终，而用链表这种数据结构来组织数据，就可以解决上类问题。  
    ![](https://i-blog.csdnimg.cn/blog_migrate/2e449e927714d60339b5eeeef6cd044b.png)

#### 30.1. 链表基本概念
(与数组的对比)
- **数组**:
    - 存储空间连续。
    - 大小在编译时固定 (for static arrays) 或在运行时声明时固定 (for VLAs)。
    - 访问元素快 (O(1) by index).
    - 插入和删除元素慢 (O(n) as elements may need shifting).
- **链表**:
    - 存储空间可以不连续，节点通过指针链接。
    - 大小可以动态改变。
    - 访问元素慢 (O(n) on average, requires traversal).
    - 插入和删除元素快 (O(1) if pointer to previous/current node is known, otherwise O(n) to find the node).

#### 30.2. 静态链表
(了解，不常用) - Typically refers to an array-based implementation of a list where links are array indices. Less common in C for general-purpose linked lists compared to dynamic allocation.
![](https://i-blog.csdnimg.cn/blog_migrate/dccf267c474e09248766a28555841aeb.png)

```c
##include <stdio.h>
// ##include <stdlib.h> // Not needed for this static example
// ##include <string.h> // Not needed

// 1.定义链表节点
typedef struct node_static{ // Renamed to avoid conflict
    int data;
    struct node_static *next; // Pointer to the same struct type
} NodeStatic; // Typedef name

int main()
{
    // 2.创建链表节点 (on the stack - static allocation in terms of lifetime within main)
    NodeStatic a, b, c; // Variables a, b, c are of type NodeStatic

    // 3.初始化节点数据
    a.data = 1;
    b.data = 3;
    c.data = 5;

    // 4.链接节点
    a.next = &b; // 'a' points to 'b'
    b.next = &c; // 'b' points to 'c'
    c.next = NULL; // 'c' is the last node

    // 5.创建链表头 (head pointer points to the first node 'a')
    NodeStatic *head = &a;

    // 6.使用链表 (traverse and print)
    NodeStatic *current = head; // Use a temporary pointer for traversal
    while(current != NULL){
        int currentData = current->data;
        printf("currentData = %d\n", currentData);
        current = current->next; // Move to the next node
    }
    return 0;
}
```

#### 30.3. 动态链表
- 静态链表的意义不是很大，主要原因，数据存储在栈上，栈的存储空间有限，不能动态分配。所以链表要实现存储的自由，要动态的申请堆里的空间。
    
- 有一个点要说清楚，我们的实现的链表是带头节点。至于，为什么带头节点，需等大家对链表有个整体的的认知以后，再来体会，会更有意义。 (A dummy head node can simplify insertion/deletion at the beginning of the list.)
    
- 空链表 (with a dummy head node)
    
    - 头指针带了一个空链表节点 (dummy head node), 空链表节点中的next指向NULL  
        ![](https://i-blog.csdnimg.cn/blog_migrate/19188f9a229feaf9f373d85a96969ab7.png)

```c
##include <stdio.h>
##include <stdlib.h> // For malloc, exit

// 1.定义链表节点
typedef struct node_dynamic{ // Renamed
    int data; // Dummy head node might not use this field
    struct node_dynamic *next;
} NodeDynamic; // Typedef name

// 函数声明
NodeDynamic *createList_dynamic(); // Renamed

int main()
{
    NodeDynamic *head = createList_dynamic();
    if (head != NULL) {
        printf("空链表 (带头节点) 创建成功。\n");
        // ... (可以添加更多操作)
        free(head); // 释放头节点
    }
    return 0;
}
// 创建空链表 (带头节点)
NodeDynamic *createList_dynamic(){ // Renamed
    // 1.创建一个头节点
    NodeDynamic *node = (NodeDynamic *)malloc(sizeof(NodeDynamic));
    if(node == NULL){
        perror("内存分配失败 (头节点)"); // Use perror for malloc errors
        exit(EXIT_FAILURE); // Exit if critical allocation fails
    }
    // node->data can be uninitialized or set to a sentinel value for a dummy node
    // 2.设置下一个节点为NULL (表示链表为空)
    node->next = NULL;
    // 3.返回创建好的头节点
    return node;
}
```

- 非空链表 (with a dummy head node)
    - 头指针带了一个非空节点 (The dummy head node points to the first actual data node), 最后一个实际数据节点中的next指向NULL  
        ![](https://i-blog.csdnimg.cn/blog_migrate/1513159d7b7b8aaebd0de28344a20f75.png)

###### 30.3.1. 动态链表头插法
(Inserts new nodes after the dummy head node, making new nodes the first *actual* element)
- 1.让新节点的下一个节点等于头结点的下一个节点 (The current first actual node)
- 2.让头节点的下一个节点等于新节点

```c
##include <stdio.h>
##include <stdlib.h>

// 1.定义链表节点
typedef struct node_head_insert{ // Renamed
    int data;
    struct node_head_insert *next;
} NodeHeadInsert; // Renamed

NodeHeadInsert *createList_head_insert(); // Renamed
void printNodeList_head_insert(NodeHeadInsert *node); // Renamed
void freeList_head_insert(NodeHeadInsert *head); // Added function to free list

int main()
{
    NodeHeadInsert *head = createList_head_insert();
    printf("头插法创建的链表内容:\n");
    printNodeList_head_insert(head);
    freeList_head_insert(head); // Free the allocated memory
    return 0;
}

/**
 * @brief createList_head_insert 创建链表 (头插法)
 * @return  创建好的链表 (头节点指针)
 */
NodeHeadInsert *createList_head_insert(){
    // 1.创建头节点 (dummy node)
    NodeHeadInsert *head = (NodeHeadInsert *)malloc(sizeof(NodeHeadInsert));
    if(head == NULL){
        perror("头节点内存分配失败");
        return NULL;
    }
    head->next = NULL; // Initially, list is empty

    // 2.接收用户输入数据
    int num = -1;
    printf("请输入节点数据 (-1 结束输入):\n");
    
    while(scanf("%d", &num) == 1 && num != -1){ // Loop while input is valid and not -1
        // 3.1创建一个新的节点
        NodeHeadInsert *cur = (NodeHeadInsert *)malloc(sizeof(NodeHeadInsert));
        if (cur == NULL) {
            perror("新节点内存分配失败");
            // Potentially free already allocated nodes before returning or exiting
            return head; // Or handle error more robustly
        }
        cur->data = num;

        // 3.2让新节点的下一个节点指向头节点的下一个节点 (current first actual node)
        cur->next = head->next;
        // 3.3让头节点的下一个节点指向新节点 (new node becomes the first actual node)
        head->next = cur;
    }
    // Clear remaining input buffer if scanf didn't consume newline
    int c;
    while ((c = getchar()) != '\n' && c != EOF);


    // 3.返回创建好的头节点
    return head;
}

/**
 * @brief printNodeList_head_insert 遍历链表 (跳过头节点)
 * @param node 链表头节点指针
 */
void printNodeList_head_insert(NodeHeadInsert *node){
    if (node == NULL) {
        printf("链表为空或头节点为NULL\n");
        return;
    }
    NodeHeadInsert *current = node->next; // Start from the first actual data node
    while(current != NULL){
        int currentData = current->data;
        printf("currentData = %d\n", currentData);
        current = current->next;
    }
}

/**
 * @brief freeList_head_insert 释放链表所有节点 (包括头节点)
 * @param head 链表头节点指针
 */
void freeList_head_insert(NodeHeadInsert *head) {
    NodeHeadInsert *current = head;
    NodeHeadInsert *nextNode;
    while (current != NULL) {
        nextNode = current->next;
        free(current);
        current = nextNode;
    }
}
```

###### 30.3.2. 动态链表尾插法
(Appends new nodes to the end of the list)
- 1.定义变量记录新节点的上一个节点 (Or rather, find the current last node)
- 2.将新节点添加到上一个节点后面
- 3.让新节点成为下一个节点的上一个节点 (This phrasing is a bit confusing. Simpler: make the new node the last node, and update the tail pointer.)

```c
##include <stdio.h>
##include <stdlib.h>

// 1.定义链表节点
typedef struct node_tail_insert{ // Renamed
    int data;
    struct node_tail_insert *next;
} NodeTailInsert; // Renamed

NodeTailInsert *createList_tail_insert(); // Renamed
void printNodeList_tail_insert(NodeTailInsert *node); // Renamed
void freeList_tail_insert(NodeTailInsert *head); // Added

int main()
{
    NodeTailInsert *head = createList_tail_insert();
    printf("尾插法创建的链表内容:\n");
    printNodeList_tail_insert(head);
    freeList_tail_insert(head);
    return 0;
}

/**
 * @brief createList_tail_insert 创建链表 (尾插法)
 * @return  创建好的链表 (头节点指针)
 */
NodeTailInsert *createList_tail_insert(){
    // 1.创建头节点 (dummy node)
    NodeTailInsert *head = (NodeTailInsert *)malloc(sizeof(NodeTailInsert));
    if(head == NULL){
        perror("头节点内存分配失败");
        return NULL;
    }
    head->next = NULL;

    NodeTailInsert *tail = head; // Tail pointer, initially points to the head node

    // 2.接收用户输入数据
    int num = -1;
    printf("请输入节点数据 (-1 结束输入):\n");

    while(scanf("%d", &num) == 1 && num != -1){
        // 3.1创建一个新的节点
        NodeTailInsert *cur = (NodeTailInsert *)malloc(sizeof(NodeTailInsert));
        if(cur == NULL){
            perror("新节点内存分配失败");
            return head; // Or handle error more robustly
        }
        cur->data = num;
        cur->next = NULL; // New node will be the last, so its next is NULL

        // 3.2让尾节点的下一个节点指向新节点
        tail->next = cur;
        // 3.3更新尾指针指向新的尾节点
        tail = cur; 
    }
    int c;
    while ((c = getchar()) != '\n' && c != EOF);

    // 3.返回创建好的头节点
    return head;
}

/**
 * @brief printNodeList_tail_insert 遍历链表 (跳过头节点)
 * @param node 链表头节点指针
 */
void printNodeList_tail_insert(NodeTailInsert *node){
    if (node == NULL) {
        printf("链表为空或头节点为NULL\n");
        return;
    }
    NodeTailInsert *current = node->next; 
    while(current != NULL){
        int currentData = current->data;
        printf("currentData = %d\n", currentData);
        current = current->next;
    }
}

/**
 * @brief freeList_tail_insert 释放链表所有节点 (包括头节点)
 * @param head 链表头节点指针
 */
void freeList_tail_insert(NodeTailInsert *head) {
    NodeTailInsert *current = head;
    NodeTailInsert *nextNode;
    while (current != NULL) {
        nextNode = current->next;
        free(current);
        current = nextNode;
    }
}
```

###### 30.3.3. 动态链优化 

```c
##include <stdio.h>
##include <stdlib.h>

// 1.定义链表节点
typedef struct node_optimized{ // Renamed
    int data;
    struct node_optimized *next;
} NodeOptimized; // Renamed

NodeOptimized *createList_optimized(); // Renamed
void printNodeList_optimized(NodeOptimized *node); // Renamed
void insertNode_tail(NodeOptimized *head, int data); // Renamed for tail insertion
void insertNode_head(NodeOptimized *head, int data); // Renamed for head insertion
void freeList_optimized(NodeOptimized *head); // Added

int main()
{
    // 1.创建一个空链表 (带头节点)
    NodeOptimized *head = createList_optimized();
    if (!head) return 1;

    // 2.往空链表中插入数据
    // Using tail insertion for ordered input
    insertNode_tail(head, 1);
    insertNode_tail(head, 3);
    insertNode_tail(head, 5);
    printf("尾插法插入后:\n");
    printNodeList_optimized(head);

    // Using head insertion (will reverse the order of these new insertions relative to existing)
    insertNode_head(head, 0);
    insertNode_head(head, -2);
    printf("头插法插入后:\n");
    printNodeList_optimized(head);
    
    freeList_optimized(head);
    return 0;
}

/**
 * @brief createList_optimized 创建空链表 (带头节点)
 * @return  创建好的空链表 (头节点指针)
 */
NodeOptimized *createList_optimized(){
    NodeOptimized *head = (NodeOptimized *)malloc(sizeof(NodeOptimized));
    if(head == NULL){
        perror("头节点内存分配失败");
        return NULL;
    }
    head->next = NULL;
    return head;
}

/**
 * @brief insertNode_tail 尾插法插入节点
 * @param head 需要插入的链表的头节点指针
 * @param data 需要插入的数据
 */
void insertNode_tail(NodeOptimized *head, int data){
    if (head == NULL) return;
    // 1.找到最后一个节点
    NodeOptimized *tail = head;
    while(tail->next != NULL){ // Iterate until tail is the last node
        tail = tail->next;
    }
    // 2.创建一个新的节点
    NodeOptimized *cur = (NodeOptimized *)malloc(sizeof(NodeOptimized));
    if (cur == NULL) {
        perror("新节点内存分配失败 (尾插)");
        return;
    }
    cur->data = data;
    cur->next = NULL;

    // 3.让原尾节点的下一个节点指向新节点
    tail->next = cur;
}

/**
 * @brief insertNode_head 头插法插入节点 (在头节点之后插入)
 * @param head 需要插入的链表的头节点指针
 * @param data 需要插入的数据
 */
void insertNode_head(NodeOptimized *head, int data){
    if (head == NULL) return;
    // 1.创建一个新的节点
    NodeOptimized *cur = (NodeOptimized *)malloc(sizeof(NodeOptimized));
    if (cur == NULL) {
        perror("新节点内存分配失败 (头插)");
        return;
    }
    cur->data = data;

    // 2.让新节点的下一个节点指向头节点的原下一个节点
    cur->next = head->next;
    // 3.让头节点的下一个节点指向新节点
    head->next = cur;
}

/**
 * @brief printNodeList_optimized 遍历链表 (跳过头节点)
 * @param node 链表头节点指针
 */
void printNodeList_optimized(NodeOptimized *node){
    if (node == NULL) {
        printf("链表为空或头节点为NULL\n");
        return;
    }
    NodeOptimized *current = node->next; 
    while(current != NULL){
        int currentData = current->data;
        printf("currentData = %d\n", currentData);
        current = current->next;
    }
}

/**
 * @brief freeList_optimized 释放链表所有节点 (包括头节点)
 * @param head 链表头节点指针
 */
void freeList_optimized(NodeOptimized *head) {
    NodeOptimized *current = head;
    NodeOptimized *nextNode;
    while (current != NULL) {
        nextNode = current->next;
        free(current);
        current = nextNode;
    }
}
```

###### 30.3.4. 链表销毁

```c
/**
 * @brief destroyList 销毁链表 (包括头节点)
 * @param head 链表头指针
 */
void destroyList(NodeOptimized *head){ // Assuming NodeOptimized type from previous example
    NodeOptimized *cur = head; // Start with the head (or head->next if head is dummy and handled separately)
    NodeOptimized *nextNode;
    while(cur != NULL){
        nextNode = cur->next; // Store next node
        free(cur);            // Free current node
        cur = nextNode;       // Move to next node
    }
    // If head was a pointer to the head node (e.g. Node **head_ptr), 
    // you might also do *head_ptr = NULL; here.
}
```

###### 30.3.5. 链表长度计算

```c
/**
 * @brief listLength 计算链表长度 (不包括头节点)
 * @param head 链表头节点指针
 * @return 链表长度 (实际数据节点数量)
 */
int listLength(NodeOptimized *head){ // Assuming NodeOptimized and dummy head node
    if (head == NULL) return 0; // Or handle as error
    int count = 0;
    NodeOptimized *current = head->next; // Start from the first actual data node
    while(current != NULL){
       count++;
       current = current->next;
    }
    return count;
}
```

###### 30.3.6. 链表查找

```c
/**
 * @brief searchList 查找指定节点
 * @param head 链表头节点指针
 * @param key 需要查找的值
 * @return 指向找到的节点的指针，如果未找到则返回NULL
 */
NodeOptimized *searchList(NodeOptimized *head, int key){ // Assuming NodeOptimized
    if (head == NULL) return NULL;
    NodeOptimized *current = head->next; // Start from the first actual data node
    while(current != NULL){
        if(current->data == key){
            return current; // 找到节点
        }
        current = current->next;
    }
    return NULL; // 未找到
}
```

###### 30.3.7. 链表删除
(Deletes the first node with the given key, assuming a list with a dummy head node)
```c
/**
 * @brief deleteNodeList 删除链表中第一个值为key的节点
 * @param head 链表头节点指针
 * @param key 需要删除的节点的数据值
 * @return 1如果删除成功, 0如果未找到节点
 */
int deleteNodeByKey(NodeOptimized *head, int key){ // Renamed for clarity
    if (head == NULL || head->next == NULL) return 0; // 空链表或无数据节点

    NodeOptimized *prev = head;
    NodeOptimized *current = head->next;

    while(current != NULL){
        if(current->data == key){
            prev->next = current->next; // Bypass the current node
            free(current);              // Free the memory of the deleted node
            return 1;                   // Deletion successful
        }
        prev = current;
        current = current->next;
    }
    return 0; // Node with key not found
}

// The original deleteNodeList(Node *head, Node *find) implies you already have a pointer to the node to delete.
// If so, you need the predecessor to delete it from a singly linked list.
// If 'find' is the node to delete and 'head' is the dummy head:
void deleteGivenNode(NodeOptimized *head, NodeOptimized *find_node) {
    if (head == NULL || find_node == NULL || head == find_node) return; // Cannot delete head or if list/node is null

    NodeOptimized *prev = head;
    while (prev->next != NULL && prev->next != find_node) {
        prev = prev->next;
    }

    if (prev->next == find_node) { // Found predecessor
        prev->next = find_node->next;
        free(find_node);
    } else {
        // Node 'find_node' not found in the list starting from head->next
        printf("要删除的节点未在链表中找到。\n");
    }
}
```

#### 30.4. 作业

- 给链表排序 (Example using Bubble Sort, assuming dummy head node and NodeOptimized type)

```c
##include <stdio.h> // For printf in helper
// Assuming NodeOptimized, swapEle (modified for data), listLength are defined as before.

void swapNodeData(NodeOptimized *node1, NodeOptimized *node2) {
    if (node1 && node2) {
        int temp = node1->data;
        node1->data = node2->data;
        node2->data = temp;
    }
}

/**
 * @brief bubbleSortList 对链表进行冒泡排序 (交换节点数据)
 * @param head 链表头节点指针
 */
void bubbleSortList_dataSwap(NodeOptimized *head){
    if (head == NULL || head->next == NULL) return; // 空或单节点链表

    int len = listLength(head); // Get actual number of data nodes
    NodeOptimized *current;
    int swapped;

    for(int i = 0; i < len - 1; i++){
        current = head->next; // Start from the first data node
        swapped = 0;
        for(int j = 0; j < len - 1 - i; j++){
            if(current != NULL && current->next != NULL) { // Ensure current and next are valid
                if((current->data) > (current->next->data)){
                    swapNodeData(current, current->next);
                    swapped = 1;
                }
                current = current->next;
            } else {
                break; // Should not happen in a correctly sized loop if listLength is accurate
            }
        }
        if (swapped == 0) break; // Optimization: if no swaps in a pass, list is sorted
    }
}

// The original sortList example attempted to swap nodes themselves, which is more complex.
// Swapping data is simpler for bubble sort on a linked list.
// If node swapping is required, it's a different algorithm.
```

- 链表反转 (Assuming dummy head node and NodeOptimized type)

```c
/**
 * @brief reverseList 反转链表 (不包括头节点)
 * @param head 链表头节点指针
 */
void reverseList(NodeOptimized *head){
    if (head == NULL || head->next == NULL || head->next->next == NULL) {
        // 空链表、单节点链表或无数据节点，无需反转
        return;
    }

    NodeOptimized *prev_node = NULL;
    NodeOptimized *current_node = head->next; // 第一个实际数据节点
    NodeOptimized *next_node = NULL;

    head->next = NULL; // 头节点将指向新的链表头 (原来的尾节点)

    while(current_node != NULL){
        next_node = current_node->next; // 保存下一个节点
        current_node->next = prev_node; // 当前节点指向前一个节点
        prev_node = current_node;       // 前一个节点更新为当前节点
        current_node = next_node;       // 当前节点移动到下一个节点
    }
    head->next = prev_node; // 头节点指向反转后的第一个数据节点
}
```

---

# **第九部分：文件操作**

## 31. 文件基本概念
- 文件流:
    - C 语言把文件看作是一个字符的序列，即文件是由一个一个字符组成的字符流，因此 c 语言将文件也称之为文件流。
- 文件分类
    - 文本文件
        
        - 以 ASCII 码格式存放，**一个字节存放一个字符**。`文本文件的每一个字节存放一个 ASCII 码，代表一个字符`。这便于对字符的逐个处理，但占用存储空间  较多，而且要花费时间转换。
        - .c文件就是以文本文件形式存放的
    - 二进制文件
        
        - 以补码格式存放。二进制文件是把数据以二进制数的格式存放在文件中的，其占用存储空间较少。`数据按其内存中的存储形式原样存放`
        - .exe文件就是以二进制文件形式存放的

---

- **文本文件和二进制文件示例**
    - 下列代码暂时不要求看懂, 主要理解什么是文本文件什么是二进制文件

```c
##include <stdio.h>

int main()
{
    /*
     * 以文本形式存储
     * 会将每个字符先转换为对应的ASCII, (More accurately, for integers, it converts the number to a sequence of digit characters)
     * 然后再将ASCII码的二进制存储到计算机中
     */
    int num = 666;
    FILE *fa = fopen("ascii.txt", "w"); // Open in text mode
    if (fa == NULL) { perror("打开 ascii.txt 失败"); return 1; }
    fprintf(fa, "%d", num); // Writes characters '6', '6', '6'
    fclose(fa);

    /*
     * 以二进制形式存储
     * 会将666的二进制直接存储到文件中 (The binary representation of the int variable num)
     */
    FILE *fb = fopen("bin.txt", "wb"); // Open in binary mode ("wb")
    if (fb == NULL) { perror("打开 bin.txt 失败"); return 1; }
    fwrite(&num, sizeof(int), 1, fb); // Writes sizeof(int) bytes
    fclose(fb);

    return 0;
}
```

- 内存示意图  
    ![](https://i-blog.csdnimg.cn/blog_migrate/2e4c9ffa3c04667ba373de0bd629b664.png)
    
- 通过文本工具打开示意图  
    ![](https://i-blog.csdnimg.cn/blog_migrate/e69f40c0652ee88d0da312c0a0acb5e6.png)
    

> - 文本工具默认会按照ASCII码逐个直接解码文件, 由于文本文件存储的就是ASCII码 (or character encodings like UTF-8), 所以可以正常解析显示, 由于二进制文件存储的不是ASCII码 (it stores raw byte data), 所以解析出来之后是乱码 (if interpreted as text).

---

#### 31.1. 文件的打开和关闭
- FILE 结构体
    - FILE 结构体是对缓冲区和文件读写状态的记录者，所有对文件的操作，都是通过FILE 结构体完成的。 (It's an opaque type; its internal details are implementation-defined and not meant to be accessed directly by user code.)

```c
  // struct _iobuf { // This is an example of what FILE *might* point to internally.
  //   char *_ptr;  //文件输入的下一个位置
  //   int _cnt;  //当前缓冲区的相对位置
  //   char *_base; //文件的起始位置)
  //   int _flag; //文件标志
  //   int _file;  //文件的有效性验证
  //   int _charbuf; //检查缓冲区状况,如果无缓冲区则不读取
  //   int _bufsiz; // 缓冲区大小
  //   char *_tmpfname; //临时文件名
  // };
  // typedef struct _iobuf FILE; // In stdio.h, FILE is typically a typedef for a struct.
```

---

- fopen函数

|函数声明|`FILE * fopen ( const char * filename, const char * mode );`|
|---|---|
|所在文件|`stdio.h`|
|函数功能|以 mode 的方式，打开一个 filename 命名的文件，返回一个指向该文件缓冲的 FILE 结构体指针。|
|参数及返回解析||
|参数|`const char* filename` :要打开，或是创建文件的路径。|
|参数|`const char* mode` :打开文件的方式。|
|返回值|`FILE*` 返回指向文件缓冲区的指针，该指针是后序操作文件的句柄。失败返回 `NULL`。|

|mode|处理方式|当文件不存在时|当文件存在时|向文件输入|从文件输出|
|---|---|---|---|---|---|
|r|读取|出错 (返回NULL)|打开文件 (指针在开头)|不能|可以|
|w|写入|建立新文件|覆盖原有文件 (截断为0长度)|可以|不能|
|a|追加|建立新文件|在原有文件后追加 (指针在末尾)|可以|不能|
|r+|读取/写入|出错 (返回NULL)|打开文件 (指针在开头)|可以|可以|
|w+|写入/读取|建立新文件|覆盖原有文件 (截断为0长度)|可以|可以|
|a+|读取/追加|建立新文件|在原有文件后追加 (初始指针在末尾进行写入，读取可以在任意位置)|可以|可以|

> 注意点:
> 
> - Windows如果读写的是二进制文件，则还要加 b,比如 rb, r+b 等。 unix/linux 不区分文本和二进制文件 (While Unix/Linux systems don't differentiate at the OS level as strictly, using 'b' in C standard library functions ensures portability and correct behavior, especially regarding newline translations and EOF handling in text mode.)

---

- fclose函数

|函数声明|`int fclose ( FILE * stream );`|
|---|---|
|所在文件|`stdio.h`|
|函数功能|`fclose()`用来关闭先前 `fopen()`打开的文件.|
|函数功能|此动作会让缓冲区内的数据写入文件中 (flushes write buffers), 并释放系统所提供的文件资源|
|参数及返回解析||
|参数|`FILE* stream` :指向文件缓冲的指针。|
|返回值|`int` 成功返回 0 ，失败返回 `EOF`(-1)。|

```c
##include <stdio.h>

int main()
{
    FILE *fp = fopen("test.txt", "w+");
    if (fp == NULL) {
        perror("打开文件失败");
        return 1;
    }
    // ... file operations ...
    if (fclose(fp) == EOF) {
        perror("关闭文件失败");
    }
    return 0;
}
```
–

#### 31.2. 一次读写一个字符
- 写入 (`fputc`)

|函数声明|`int fputc (int ch, FILE * stream );`|
| --- | --- |
|所在文件|`stdio.h`|
|函数功能|将 `ch` 字符，写入文件。|
|参数及返回解析||
|参数|`FILE* stream` :指向文件缓冲的指针。|
|参数|`int ch` : 需要写入的字符 (passed as an int, but typically a char value).|
|返回值|`int` 写入成功，返回写入成功字符 (as an int)，如果失败，返回 `EOF`。|


```c
##include <stdio.h>

int main()
{
    // 1.打开一个文件
    FILE *fp = fopen("test_chars.txt", "w+"); // Renamed file
    if (fp == NULL) { perror("打开文件失败"); return 1; }

    // 2.往文件中写入内容
    for(char ch_write = 'a'; ch_write <= 'z'; ch_write++){ // Renamed ch
        // 一次写入一个字符
        int res_write = fputc(ch_write, fp); // Renamed res
        if (res_write == EOF) {
            perror("写入字符失败");
            break;
        }
        // printf("写入的字符: %c\n", res_write); // Can print the written char
    }

    // 3.关闭打开的文件
    fclose(fp);
    return 0;
}
```

- 读取 (`fgetc`)

|函数声明|`int fgetc ( FILE * stream );`|
|---|---|
|所在文件|`stdio.h`|
|函数功能|从文件流中读取一个字符并返回。|
|参数及返回解析||
|参数|`FILE* stream` :指向文件缓冲的指针。|
|返回值|`int` 正常，返回读取的字符 (as an unsigned char converted to an int)；读到文件尾或出错时，为 `EOF`。|

```c
##include <stdio.h>

int main()
{
    // 1.打开一个文件 (assuming test_chars.txt was created by previous example)
    FILE *fp = fopen("test_chars.txt", "r+");
    if (fp == NULL) { perror("打开文件失败"); return 1; }

    // 2.从文件中读取内容
    int res_read; // fgetc returns int to accommodate EOF
    printf("从文件中读取的字符:\n");
    while((res_read = fgetc(fp)) != EOF){
        printf("%c", (char)res_read); // Cast to char for printing
    }
    printf("\n");

    // 3.关闭打开的文件
    fclose(fp);
    return 0;
}
```

- 判断文件末尾
    - feof函数

|函数声明|`int feof( FILE * stream );`|
|---|---|
|所在文件|`stdio.h`|
|函数功能|判断文件是否读到文件结尾 (Checks the end-of-file indicator for the stream).|
|参数及返回解析||
|参数|`FILE* stream` :指向文件缓冲的指针。|
|返回值|`int` 0 未读到文件结尾，非零 读到文件结尾。|

```c
##include <stdio.h>

int main()
{
    // 1.打开一个文件
    FILE *fp = fopen("test_chars.txt", "r+");
    if (fp == NULL) { perror("打开文件失败"); return 1; }

    // 2.从文件中读取内容
    int res_feof; // Renamed
    printf("使用 feof 读取:\n");
    // 注意: 由于只有先读了才会修改标志位 (EOF indicator is set *after* an attempt to read past EOF),
    // 所以通过feof判断是否到达文件末尾, 一定要先读再判断, 不能先判断再读.
    // The common idiom is to check the return value of the read function itself for EOF.
    while(1){
        res_feof = fgetc(fp);
        if (feof(fp)) { // Check feof *after* fgetc
            printf("\n已到达文件末尾 (feof 检测到)。\n");
            break;
        }
        if (res_feof == EOF && !feof(fp)) { // Check for read error if not EOF by feof
             perror("读取错误");
             break;
        }
        if (res_feof == EOF) break; // Break if fgetc returned EOF for any reason

        printf("%c", (char)res_feof);
    }

    // 3.关闭打开的文件
    fclose(fp);
    return 0;
}
```

> - 注意点:
> - feof 这个函数，是去读标志位判断文件是否结束的。
> - 而标志位只有读完了才会被修改, 所以如果先判断再读标志位会出现多打一次的的现象 (Or more accurately, `feof` only becomes true after a read operation *attempts* to read past the end of the file. It doesn't predict EOF.)
> - 所以企业开发中使用feof函数一定要先读后判断, 而不能先判断后读 (The most robust way is to check the return value of the read function, e.g., `fgetc() != EOF`.)

- 作业
    - 实现文件的简单加密和解密 (XOR cipher example)

```c
##include <stdio.h>
##include <string.h> // Not strictly needed for this version but often useful

void encode_decode_file(const char *input_name, const char *output_name, int key); // Combined function

int main()
{
    const char *original_file = "main.c"; // Example input file
    const char *encoded_file = "encode.dat";
    const char *decoded_file = "decode.c";
    int secret_key = 666;

    // Create a dummy main.c if it doesn't exist for testing
    FILE *temp_fp = fopen(original_file, "w");
    if (temp_fp) {
        fprintf(temp_fp, "##include <stdio.h>\nint main() { printf(\"Hello\\n\"); return 0; }\n");
        fclose(temp_fp);
    } else {
        perror("无法创建测试文件 main.c");
        return 1;
    }


    printf("加密 %s 到 %s...\n", original_file, encoded_file);
    encode_decode_file(original_file, encoded_file, secret_key);
    printf("加密完成。\n");

    printf("解密 %s 到 %s...\n", encoded_file, decoded_file, secret_key);
    encode_decode_file(encoded_file, decoded_file, secret_key);
    printf("解密完成。\n");
    
    return 0;
}

/**
 * @brief encode_decode_file 加密或解密文件 (XOR)
 * @param input_name 需要处理的文件名称
 * @param output_name 处理之后的文件名称
 * @param key 秘钥
 */
void encode_decode_file(const char *input_name, const char *output_name, int key){
    FILE *fin = fopen(input_name, "rb"); // Open in binary mode for robustness
    if (fin == NULL) {
        perror("打开输入文件失败");
        printf("文件名: %s\n", input_name);
        return;
    }
    FILE *fout = fopen(output_name, "wb"); // Open in binary mode
    if (fout == NULL) {
        perror("打开输出文件失败");
        printf("文件名: %s\n", output_name);
        fclose(fin);
        return;
    }

    int ch; // Use int to correctly handle EOF
    while((ch = fgetc(fin)) != EOF){
        fputc(ch ^ key, fout); // XOR with key
    }

    fclose(fout);
    fclose(fin);
}
```

---

#### 31.3. 一次读写一行字符
- 什么是行

- 行是文本编辑器中的概念，文件流中就是一个字符。这个在不同的平台是有差异的。window 平台 ‘\r\n’，linux 平台是’\n’ (A "line" is typically a sequence of characters ending with a newline character. The representation of a newline varies by OS.)

- 平台差异
    - windows 平台在写入’\n’是会体现为’\r\n’，linux 平台在写入’\n’时会体现为’\n’。windows 平台在读入’\r\n’时，体现为一个字符’\n’，linux 平台在读入’\n’时，体现为一个字符’\n’ (This translation happens in text mode. In binary mode, `\r\n` is read/written as two distinct bytes on all platforms.)
    - linux 读 windows 中的换行，则会多读一个字符 (If Linux reads a Windows text file in binary mode, it sees `\r` and `\n`. If in text mode, some C libraries might handle it, others might treat `\r` as a normal char before `\n`.)
    - windows 读 linux 中的换行，则没有问题 (Windows text mode usually handles `\n` as a newline correctly.)

```c
##include <stdio.h>

int main()
{
    FILE *fw = fopen("test_line.txt", "w"); // "w" is text mode by default
    if (fw == NULL) { perror("打开文件失败"); return 1; }
    fputc('a', fw);
    fputc('\n', fw); // In text mode on Windows, this writes CR LF. On Linux, LF.
    fputc('b', fw);
    fclose(fw);
    return 0;
}
```

![](https://i-blog.csdnimg.cn/blog_migrate/8296a16d1d81c59fd1f6ba668b1900b1.png)
(The image shows that on Windows, a newline `\n` written in text mode results in `0D 0A` (CR LF) in the file.)

---

- 写入一行 (`fputs`)

|函数声明|`int fputs(const char *str,FILE *fp);`| <!-- Corrected: str is const char* -->
|---|---|
|所在文件|`stdio.h`|
|函数功能|把 `str` 指向的字符串写入 `fp` 指向的文件中。 `fputs` 不会自动添加换行符。|
|参数及返回解析||
|参数|`const char * str` : 表示指向的字符串的指针 (must be null-terminated).|
|参数|`FILE *fp` : 指向文件流结构的指针。|
|返回值|`int` 正常，返非负值；出错返 `EOF`。|

```c
##include <stdio.h>

int main()
{
    FILE *fw = fopen("test_fputs.txt", "w+");
    if (fw == NULL) { perror("打开文件失败"); return 1; }
    // 注意: fputs不会自动添加\n
    fputs("lnj\n", fw);
    fputs("it666\n", fw);
    fclose(fw);
    return 0;
}
```

- 遇到\0自动终止写入

```c
##include <stdio.h>

int main()
{
    FILE *fp = fopen("test_fputs_null.txt", "w+");
    if (fp == NULL) { perror("打开文件失败"); return 1; }
    // 注意: fputs写入时遇到\0就会自动终止写入
    fputs("lnj\0it666\n", fp); // Writes only "lnj"

    fclose(fp);
    return 0;
}
```

---

- 读取一行 (`fgets`)

|函数声明|`char *fgets(char *str,int length,FILE *fp);`|
|---|---|
|所在文件|`stdio.h`|
|函数功能|从 `fp` 所指向的文件中，至多读 `length-1` 个字符，送入字符数组 `str` 中， 如果在读入 `length-1` 个字符结束前遇`\n` 或 `EOF`，读入即结束，字符串读入后在最后加一个‘\0’字符。 `fgets` 会读取并存储换行符 `\n` 如果它在 `length-1` 字符内被读到。|
|参数及返回解析||
|参数|`char * str` :指向需要读入数据的缓冲区。|
|参数|`int length` :每一次读数字符的字数 (size of the buffer `str`).|
|参数|`FILE* fp` :文件流指针。|
|返回值|`char *` 正常，返 `str` 指针；出错或遇到文件结尾 (且未读取任何字符) 返空指针 `NULL`。|

- 最多只能读取N-1个字符 (where N is the `length` argument, i.e., buffer size)

```c
##include <stdio.h>

int main()
{
    FILE *fp = fopen("test_fgets_len.txt", "w+");
    if (fp == NULL) { perror("打开文件失败 (w+)"); return 1; }
    fputs("it666\n", fp);
    fclose(fp); // Close and reopen for reading, or use rewind

    fp = fopen("test_fgets_len.txt", "r");
    if (fp == NULL) { perror("打开文件失败 (r)"); return 1; }

    char str[10]; // Buffer size 10
    // 从fp中读取4个字符, 存入到str中 (fgets will read at most 4-1=3 characters + '\0')
    // 最多只能读取N-1个字符, 会在最后自动添加\0
    if (fgets(str, 4, fp) != NULL) {
        printf("str = %s", str); // Should print "it6" (it6\0)
    } else {
        printf("fgets 读取失败或已到文件末尾\n");
    }
    
    fclose(fp);
    return 0;
}
```

- 遇到\n自动结束 (More accurately, `fgets` stops if `\n` is read and it fits in the buffer. The `\n` is included.)

```c
##include <stdio.h>
int main()
{
    FILE *fp = fopen("test_fgets_nl.txt", "w+");
    if (fp == NULL) { perror("打开文件失败 (w+)"); return 1; }
    fputs("lnj\n", fp);
    fputs("it666\n", fp);
    fclose(fp);

    fp = fopen("test_fgets_nl.txt", "r");
    if (fp == NULL) { perror("打开文件失败 (r)"); return 1; }

    char str[1024];
    // 从fp中读取1024个字符, 存入到str中
    // 但是读到第4个就是\n了, 函数会自动停止读取 (fgets reads up to \n)
    // 注意点: \n会被读取进来
    if (fgets(str, sizeof(str), fp) != NULL) {
        printf("str = %s", str); // lnj\n
    }
    
    fclose(fp);
    return 0;
}
```

- 读取到EOF自动结束

```c
##include <stdio.h>

int main()
{
    FILE *fp = fopen("test_fgets_eof.txt", "w+");
    if (fp == NULL) { perror("打开文件失败 (w+)"); return 1; }
    fputs("lnj\n", fp);
    fputs("it666", fp); // Last line without newline
    fclose(fp);

    fp = fopen("test_fgets_eof.txt", "r");
    if (fp == NULL) { perror("打开文件失败 (r)"); return 1; }
    
    char str[1024];
    printf("文件内容:\n");
    // 每次从fp中读取1024个字符, 存入到str中
    // 读取到文件末尾自动结束 (fgets returns NULL on EOF or error)
    while(fgets(str, sizeof(str), fp) != NULL){
        printf("%s", str); // str already contains \n if present, or ends with \0
    }
    // No explicit newline needed here if lines in file have them.
    
    fclose(fp);
    return 0;
}
```

- 注意点:
    - 企业开发中能不用feof函数就不用feof函数 (It's better to check the return value of the read functions like `fgets`, `fgetc`, `fread`.)
    - 如果最后一行，没有行‘\n’的话则少读一行 (This statement is confusing. `fgets` reads until `length-1` characters, a newline, or EOF. If the last line has no newline, `fgets` will read the characters and null-terminate. The "少读一行" (read one less line) part is unclear in this context. `feof` with `fgets` can be tricky as `fgets` might return `NULL` on EOF *before* `feof` becomes true if no characters were read on the last attempt.)

```c
##include <stdio.h>

int main()
{
    FILE *fp = fopen("test_fgets_feof_trick.txt", "w+");
    if (fp == NULL) { perror("打开文件失败 (w+)"); return 1; }
    fputs("12345678910\n", fp);
    fputs("12345678910\n", fp);
    fputs("12345678910", fp); // No newline at the end of the file
    fclose(fp);

    fp = fopen("test_fgets_feof_trick.txt", "r");
    if (fp == NULL) { perror("打开文件失败 (r)"); return 1; }

    char str[1024];
    printf("文件内容 (fgets and feof):\n");
    // The condition `fgets(...) && !feof(fp)` can be problematic.
    // If fgets reads the last line (without \n) and hits EOF immediately after,
    // feof() will be true in the *next* iteration's check, but the last line was already processed.
    // Better:
    while(fgets(str, sizeof(str), fp) != NULL){ // Check fgets return directly
        printf("%s", str);
    }
    // If you need to distinguish between EOF and error after loop:
    // if (ferror(fp)) { perror("读取错误"); }
    // else if (feof(fp)) { printf("\n已到达文件末尾。\n"); }
    
    fclose(fp);
    return 0;
}
```

- 作业:
    - 利用fgets(str, 5, fp)读取下列文本会读取多少次?

```
12345678910  (Line 1)
12345        (Line 2)
123          (Line 3)
```
**解答:**
假设 `str` 是 `char str[5];`
1.  **读取第一行 "12345678910\n":**
    *   第一次 `fgets(str, 5, fp)`: 读取 "1234" (4 chars), `str` 变为 "1234\0". 文件指针在 '5'.
    *   第二次 `fgets(str, 5, fp)`: 读取 "5678" (4 chars), `str` 变为 "5678\0". 文件指针在 '9'.
    *   第三次 `fgets(str, 5, fp)`: 读取 "910\n" (4 chars, including \n), `str` 变为 "910\n\0". 文件指针在下一行开头。
    *   (3次读取第一行)
2.  **读取第二行 "12345\n":** (Assuming \n was intended for the example)
    *   第四次 `fgets(str, 5, fp)`: 读取 "1234" (4 chars), `str` 变为 "1234\0". 文件指针在 '5'.
    *   第五次 `fgets(str, 5, fp)`: 读取 "5\n" (2 chars), `str` 变为 "5\n\0". 文件指针在下一行开头。
    *   (2次读取第二行)
3.  **读取第三行 "123":**
    *   第六次 `fgets(str, 5, fp)`: 读取 "123" (3 chars), `str` 变为 "123\0". 文件指针在 EOF.
    *   (1次读取第三行)
4.  **下一次调用 `fgets`**: 会返回 `NULL` 因为已到文件末尾。

总共会成功读取 **6 次**。

---

#### 31.4. 一次读写一块数据
- C 语言己经从接口的层面区分了，文本的读写方式和二进制的读写方式。前面我们讲的是文本的读写方式。
- 所有的文件接口函数，要么以 ‘\0’，表示输入结束，要么以 ‘\n’， EOF(0xFF)表示读取结束。 ‘\0’ ‘\n’ 等都是文本文件的重要标识，而所有的二进制接口对于这些标识，是不敏感的。  
    +二进制的接口可以读文本，而文本的接口不可以读二进制 (More accurately, text mode functions might perform translations (like `\n` to `\r\n`) which can corrupt binary data. Binary mode functions read/write bytes as-is, so they can handle text files, but the interpretation of newlines etc., would be literal.)

- 一次写入一块数据 (`fwrite`)

|函数声明|`size_t fwrite(const void *buffer, size_t size, size_t count, FILE *fp);`| <!-- Corrected return type and buffer type -->
|---|---|
|所在文件|`stdio.h`|
|函数功能|把`buffer` 指向的内存块中的 `count` 个元素，每个元素 `size` 字节，写入 `fp` 指向的文件中。|
|参数|`const void * buffer` : 指向要写入数据，存储区的首地址的指针|
|参数|`size_t size`: 每个要写的对象的字节数| <!-- Corrected: num_bytes to size -->
|参数|`size_t count` : 要写的对象的个数| <!-- Corrected: count to count -->
|参数|`FILE* fp` : 要写的文件指针|
|返回值|`size_t` 成功，返回实际写入的完整对象的数量（通常等于count）；出错或文件结束，返回值会小于count（或为0）。|

```c
##include <stdio.h>
##include <string.h> // For strlen

int main()
{
    FILE *fp = fopen("test_fwrite.bin", "wb+"); // Use .bin for binary files, wb+ mode
    if (fp == NULL) { perror("打开文件失败"); return 1; }

    // 注意: fwrite不会关心写入数据的格式 (It writes raw bytes)
    char *str = "lnj\0it666"; // This string contains an embedded null character.
                             // strlen(str) would be 3.
                             // If you want to write all 9 characters including the embedded null:
    size_t bytes_written = fwrite((void *)str, sizeof(char), 9, fp); // Write 9 bytes
    // Or if you only want to write up to the first null:
    // size_t bytes_written = fwrite((void *)str, sizeof(char), strlen(str), fp); // Writes "lnj" (3 bytes)

    if (bytes_written < 9) { // Check if all items were written
        printf("写入错误或未完全写入。\n");
    } else {
        printf("成功写入 %zu 个字节。\n", bytes_written * sizeof(char));
    }

    fclose(fp);
    return 0;
}
```

- 一次读取一块数据 (`fread`)

|函数声明|`size_t fread(void *buffer, size_t size, size_t count, FILE *fp);`| <!-- Corrected return type -->
|---|---|
|所在文件|`stdio.h`|
|函数功能|把`fp` 指向的文件中的数据读到 `buffer` 中。读取 `count` 个对象，每个对象 `size` 字节。|
|参数|`void * buffer` : 指向要读入数据存储区的首地址的指针| <!-- Corrected: char * to void * -->
|参数|`size_t size`: 每个要读的对象的字节数| <!-- Corrected: num_bytes to size -->
|参数|`size_t count` : 要读的对象的个数|
|参数|`FILE* fp` : 要读的文件指针|
|返回值|`size_t` 成功，返回实际读取的完整对象的数量（可能小于count，如果在读取完count个对象前到达文件末尾或发生错误）；出错或文件结束，返回值会小于count（或为0）。|

```c
##include <stdio.h>
##include <stdlib.h> // For exit

int main()
{
    // Assuming test_fwrite.bin was created by the previous fwrite example and contains "lnj\0it666"
    FILE *fr = fopen("test_fwrite.bin", "rb"); // Open in binary read mode
    if (fr == NULL) { perror("打开文件失败"); return 1; }

    char buf[1024] = {0}; // Buffer to read into
    
    // fread函数读取成功返回读取到的对象数量, 读取失败或到文件尾返回的数量会小于请求的数量
    /*
     * 第一个参数: 存储读取到数据的容器
     * 第二个参数: 每次读取对象的字节大小
     * 第三个参数: 需要读取多少个对象
     * 第四个参数: 已打开文件结构体指针
     */ 
    size_t items_read = fread(buf, sizeof(char), 9, fr); // Attempt to read 9 characters
    
    if (ferror(fr)) {
        perror("读取文件时发生错误");
    } else {
        printf("成功读取 %zu 个字节。\n", items_read * sizeof(char));
        printf("读取内容 (前 %zu 字节): ", items_read);
        for(size_t i = 0; i < items_read; i++){
            if (buf[i] == '\0') {
                printf("\\0"); // Print null terminator visibly
            } else if (buf[i] < 32 || buf[i] > 126) { // Non-printable ASCII
                printf("[%02X]", (unsigned char)buf[i]);
            }
            else {
                printf("%c", buf[i]);
            }
        }
        printf("\n");
    }
    
    fclose(fr);
    return 0;
}
```

> - 注意点:
> - 读取时num_bytes应该填写读取数据类型的最小单位, 而count可以随意写 (More accurately, `size` is the size of each element, and `count` is the number of elements. It's common to read `count` elements of `size` 1 byte for raw data, or 1 element of `size` `sizeof(struct)` for structures.)
> - 如果读取时num_bytes不是读取数据类型最小单位, 会引发读取失败 (If `size` is larger than the actual data structure or if the file doesn't contain enough data for a full element of that `size`, `fread` might return fewer items than `count` or 0.)
> - 例如: 存储的是char类型 6C 6E 6A 00 69 74 36 36 36  
>     如果num_bytes等于1, count等于1024, 那么依次取出 6C 6E 6A 00 69 74 36 36 36 , 直到取不到为止  
>     如果num_bytes等于4, count等于1024, 那么依次取出[6C 6E 6A 00][69 74 36 36] , 但是最后还剩下一个36, 但又不满足4个字节, 那么最后一个36则取不到 (Correct, `fread` reads in multiples of `size`. If the remaining data is less than `size`, it won't read a partial item and will return 0 for that attempt, or a short count if some full items were read before.)

```c
##include <stdio.h>
// ##include <string.h> // Not needed for this example

int main()
{
    // Create a file with known content for testing fread
    FILE *fp_write = fopen("test_fread_chunks.bin", "wb");
    if (!fp_write) { perror("无法创建测试文件"); return 1; }
    char data_to_write[] = {0x6C, 0x6E, 0x6A, 0x00, 0x69, 0x74, 0x36, 0x36, 0x36}; // 9 bytes
    fwrite(data_to_write, sizeof(char), sizeof(data_to_write), fp_write);
    fclose(fp_write);

    FILE *fr = fopen("test_fread_chunks.bin", "rb");
    if (fr == NULL) { perror("打开文件失败"); return 1; }
    
    char buf[10]; // Buffer
    size_t items_read;

    printf("以 4 字节为单位读取:\n");
    rewind(fr); // Reset file pointer to beginning
    // Attempt to read 2 items of 4 bytes each (total 8 bytes)
    items_read = fread(buf, 4, 2, fr); 
    printf("读取到 %zu 个 4字节块。\n", items_read);
    for(size_t i = 0; i < items_read * 4; ++i) { // Print the bytes read
        printf("%02X ", (unsigned char)buf[i]);
    }
    printf("\n");
    // The last byte (0x36) will not be read in this pass because it's not a full 4-byte block.

    printf("\n以 1 字节为单位读取:\n");
    rewind(fr); // Reset file pointer
    items_read = fread(buf, 1, 9, fr); // Attempt to read 9 items of 1 byte each
    printf("读取到 %zu 个 1字节块。\n", items_read);
    for(size_t i = 0; i < items_read; ++i) {
        printf("%02X ", (unsigned char)buf[i]);
    }
    printf("\n");
    
    fclose(fr);
    return 0;
}
```

> - 注意: fwrite和fread本质是用来操作二进制的
> - 所以下面用法才是它们的正确打开姿势 (Reading/writing arrays or structs directly)

```c
##include <stdio.h>

int main()
{
    FILE *fp = fopen("test_array_io.bin", "wb+"); // Binary mode for read/write
    if (fp == NULL) { perror("打开文件失败"); return 1; }

    int ages_write[4] = {1, 3, 5, 6};
    size_t written_count = fwrite(ages_write, sizeof(int), 4, fp); // Write 4 ints
    if (written_count < 4) {
        printf("写入数组时发生错误或未完全写入。\n");
    }

    rewind(fp); // Move file pointer to the beginning for reading

    int ages_read[4];
    int data_read_item;
    size_t read_count_total = 0;
    
    printf("从文件读取的整数:\n");
    // Reading one int at a time
    while(fread(&data_read_item, sizeof(int), 1, fp) == 1){ // Read 1 item of sizeof(int)
        printf("data = %d\n", data_read_item);
        read_count_total++;
    }
    printf("总共读取了 %zu 个整数。\n", read_count_total);

    // Or read the whole array at once (if you know the size)
    // rewind(fp);
    // size_t items_read_array = fread(ages_read, sizeof(int), 4, fp);
    // if (items_read_array == 4) {
    //     for (int i=0; i<4; ++i) printf("ages_read[%d] = %d\n", i, ages_read[i]);
    // }

    fclose(fp);
    return 0;
}
```

---

#### 31.5. 读写结构体
- 结构体中的数据类型不统一，此时最适合用二进制的方式进行读写
- 读写单个结构体

```c
##include <stdio.h>
##include <stdlib.h> // For exit, if fopen fails critically
##include <string.h> // For strcpy if name was a char array

typedef struct{
    char name[50]; // Changed to char array for direct storage in struct
    int age;
    double height;
} Person_single_io; // Renamed

int main()
{
    Person_single_io p1;
    strcpy(p1.name, "lnj"); // Initialize char array name
    p1.age = 35;
    p1.height = 1.88;

    FILE *fp = fopen("person_single.dat", "wb+"); // Use .dat for binary data
    if (fp == NULL) { perror("打开 person_single.dat 失败"); return 1; }
    
    size_t written = fwrite(&p1, sizeof(Person_single_io), 1, fp);
    if (written < 1) {
        printf("写入结构体失败。\n");
        fclose(fp);
        return 1;
    }
    printf("结构体 p1 写入成功。\n");

    rewind(fp);
    Person_single_io p2;
    size_t read_items = fread(&p2, sizeof(Person_single_io), 1, fp);
    if (read_items < 1) {
        if (feof(fp)) printf("读取结构体失败：已到文件末尾。\n");
        else if(ferror(fp)) perror("读取结构体失败");
        fclose(fp);
        return 1;
    }
    
    printf("读取的结构体 p2:\n");
    printf("name = %s\n", p2.name);
    printf("age = %d\n", p2.age);
    printf("height = %.2lf\n", p2.height);

    fclose(fp);
    return 0;
}
```
**Note on `char *name;` in struct for file I/O:** If a struct contains `char *name;`, `fwrite` will write the pointer value (the memory address), not the string itself. When `fread` reads it back, that address will likely be invalid in the new context. For storing strings within structs that are written to files, it's usually better to use a character array `char name[SIZE];`.

- 读写结构体数组

```c
##include <stdio.h>
##include <stdlib.h>
##include <string.h>

typedef struct{
    char name[50]; // Using char array
    int age;
    double height;
} Person_array_io; // Renamed

int main()
{
    Person_array_io ps[3]; // Array of 3 Person_array_io structs
    strcpy(ps[0].name, "zs"); ps[0].age = 18; ps[0].height = 1.65;
    strcpy(ps[1].name, "ls"); ps[1].age = 21; ps[1].height = 1.88;
    strcpy(ps[2].name, "ww"); ps[2].age = 33; ps[2].height = 1.90;


    FILE *fp = fopen("persons_array.dat", "wb+");
    if (fp == NULL) { perror("打开 persons_array.dat 失败"); return 1; }

    size_t written_arr = fwrite(ps, sizeof(Person_array_io), 3, fp); // Write 3 structs
    if (written_arr < 3) {
        printf("写入结构体数组失败或未完全写入。\n");
    } else {
        printf("结构体数组写入成功。\n");
    }

    rewind(fp);
    Person_array_io p_read; // Buffer for one struct
    printf("\n从文件读取的结构体数组内容:\n");
    while(fread(&p_read, sizeof(Person_array_io), 1, fp) == 1){ // Read one struct at a time
        printf("name = %s, ", p_read.name);
        printf("age = %d, ", p_read.age);
        printf("height = %.2lf\n", p_read.height);
    }
    
    if (ferror(fp)) {
        perror("读取文件时发生错误");
    }

    fclose(fp);
    return 0;
}
```

- 读写结构体链表 (This is more complex because pointers `next` are memory addresses and cannot be directly written to/read from a file meaningfully for linking. You typically write only the data part of each node, then reconstruct the list (and its pointers) upon loading.)

```c
##include <stdio.h>
##include <stdlib.h>
##include <string.h>

typedef struct person_node { // Renamed struct tag
    char name[50]; // Using char array
    int age;
    double height;
    struct person_node* next; // Pointer for linking in memory
} PersonNode; // Typedef name

// Function prototypes (simplified for brevity, error checking omitted in some places)
PersonNode *createEmptyList(); // Renamed
void  insertNodeToList(PersonNode *head, const char *name, int age, double height); // Renamed
void printPersonList(PersonNode *head); // Renamed
int savePersonList(PersonNode *head, const char *filename); // Renamed
PersonNode *loadPersonList(const char *filename); // Renamed
void freePersonList(PersonNode *head); // Added

int main()
{
    PersonNode *list_head = createEmptyList();
    if (!list_head) return 1;

    insertNodeToList(list_head, "zs", 18, 1.9);
    insertNodeToList(list_head, "ls", 22, 1.65);
    insertNodeToList(list_head, "ws", 31, 1.78);
    
    printf("原始链表:\n");
    printPersonList(list_head);
    
    if (savePersonList(list_head, "person_list.dat") == 0) {
        printf("链表已保存到 person_list.dat\n");
    }
    freePersonList(list_head); // Free original list
    list_head = NULL;

    list_head = loadPersonList("person_list.dat");
    if (list_head) {
        printf("\n从文件加载的链表:\n");
        printPersonList(list_head);
        freePersonList(list_head); // Free loaded list
    }
    return 0;
}

PersonNode *createEmptyList(){
    PersonNode *head = (PersonNode *)malloc(sizeof(PersonNode));
    if(head == NULL){
        perror("头节点内存分配失败");
        return NULL;
    }
    // For dummy head node, data fields can be ignored or set to indicate it's a dummy
    strcpy(head->name, "DUMMY_HEAD"); 
    head->age = -1;
    head->height = -1.0;
    head->next = NULL;
    return head;
}

void insertNodeToList(PersonNode *head, const char *name, int age, double height){
    if (head == NULL) return;
    PersonNode *newNode = (PersonNode *)malloc(sizeof(PersonNode));
    if(newNode == NULL) { perror("新节点内存分配失败"); return; }
    
    strcpy(newNode->name, name);
    newNode->age = age;
    newNode->height = height;
    
    newNode->next = head->next; // Head insertion (after dummy head)
    head->next = newNode;
}

void printPersonList(PersonNode *head){
    if (head == NULL) { printf("链表头为NULL\n"); return; }
    PersonNode *current = head->next; // Skip dummy head
    if (current == NULL) { printf("链表为空 (只有头节点)。\n"); return; }
    while(current != NULL){
        printf("Name: %s, Age: %d, Height: %.2lf\n", current->name, current->age, current->height);
        current = current->next;
    }
}

int savePersonList(PersonNode *head, const char *filename){
    if (head == NULL) return -1;
    FILE *fp = fopen(filename, "wb");
    if(fp == NULL){
        perror("打开文件失败 (保存)");
        return -1;
    }
    PersonNode *current = head->next; // Skip dummy head
    while(current != NULL){
        // Write only the data part, not the 'next' pointer
        if (fwrite(&(current->name), sizeof(current->name) + sizeof(current->age) + sizeof(current->height), 1, fp) != 1) {
        // A more robust way is to write each member separately or a struct containing only data.
        // For this example, assuming PersonNode struct is written directly (excluding the next pointer logic for file).
        // A better approach for saving:
        // fwrite(current->name, sizeof(current->name), 1, fp);
        // fwrite(&(current->age), sizeof(current->age), 1, fp);
        // fwrite(&(current->height), sizeof(current->height), 1, fp);
        // This example will write the 'next' pointer's value too, which is not useful when loading.
        // Let's write a struct that *doesn't* have the next pointer for file storage.
            struct PersonDataFile { char name[50]; int age; double height; };
            struct PersonDataFile data_to_write;
            strcpy(data_to_write.name, current->name);
            data_to_write.age = current->age;
            data_to_write.height = current->height;
            if (fwrite(&data_to_write, sizeof(struct PersonDataFile), 1, fp) != 1) {
                 perror("写入节点数据失败");
                 fclose(fp);
                 return -1;
            }
        }
        current = current->next;
    }
    fclose(fp);
    return 0;
}

PersonNode *loadPersonList(const char *filename){
    FILE *fp = fopen(filename, "rb");
    if(fp == NULL){
        perror("打开文件失败 (加载)");
        return NULL;
    }
    PersonNode *head = createEmptyList();
    if (!head) { fclose(fp); return NULL; }

    struct PersonDataFile { char name[50]; int age; double height; };
    struct PersonDataFile data_read;
    
    // To maintain order as saved (if saved from head to tail), insert at tail when loading.
    // Or, if saved in some order and want to reconstruct, head insertion will reverse it.
    // For simplicity, let's use head insertion which will reverse the order from the file.
    while(fread(&data_read, sizeof(struct PersonDataFile), 1, fp) == 1){
        insertNodeToList(head, data_read.name, data_read.age, data_read.height);
    }
    // If head insertion was used, the list is now reversed. To restore original order:
    // NodeOptimized *reversed_head = createEmptyList();
    // NodeOptimized *curr = head->next;
    // while(curr) {
    //    insertNode_head(reversed_head, curr->data); // Assuming data is just int for this snippet
    //    curr = curr->next;
    // }
    // freePersonList(head);
    // head = reversed_head;

    fclose(fp);
    return head;
}

void freePersonList(PersonNode *head) {
    PersonNode *current = head;
    PersonNode *nextNode;
    while (current != NULL) {
        nextNode = current->next;
        free(current);
        current = nextNode;
    }
}
```

#### 31.6. 其它文件操作函数
- ftell 函数

|函数声明|`long ftell ( FILE * stream );`|
|---|---|
|所在文件|`stdio.h`|
|函数功能|得到流式文件的当前读写位置,其返回值是当前读写位置偏离文件头部的字节数.|
|参数及返回解析||
|参数|`FILE * stream` 文件句柄|
|返回值|`long` 成功，返回当前读写位置偏离文件头部的字节数。失败， 返回-1L 并设置 `errno`.|

```c
##include <stdio.h>

int main()
{
    char *str = "123456789";
    FILE *fp = fopen("test_ftell.txt", "w+");
    if (fp == NULL) { perror("打开文件失败"); return 1; }

    long cp = ftell(fp);
    printf("cp (初始) = %ld\n", cp); // 0
    
    // 写入一个字节
    if (fputc(str[0], fp) == EOF) { perror("写入失败"); fclose(fp); return 1;}
    cp = ftell(fp);
    printf("cp (写入一个字节后) = %ld\n", cp); // 1
    
    fclose(fp);
    return 0;
}
```

- rewind 函数

|函数声明|`void rewind ( FILE * stream );`|
|---|---|
|所在文件|`stdio.h`|
|函数功能 将文件指针重新指向一个流的开头。清除流的错误指示符和EOF指示符。|
|参数及返回解析||
|参数|`FILE * stream` 文件句柄|
|返回值|`void` 无返回值|

```c
##include <stdio.h>

int main()
{
    char *str = "123456789";
    FILE *fp = fopen("test_rewind.txt", "w+");
    if (fp == NULL) { perror("打开文件失败"); return 1; }

    long cp = ftell(fp);
    printf("cp (初始) = %ld\n", cp); // 0
    
    // 写入一个字节
    if (fputc(str[0], fp) == EOF) { perror("写入失败"); fclose(fp); return 1;}
    cp = ftell(fp);
    printf("cp (写入一个字节后) = %ld\n", cp); // 1
    
    // 新指向一个流的开头
    rewind(fp);
    cp = ftell(fp);
    printf("cp (rewind后) = %ld\n", cp); // 0
    
    fclose(fp);
    return 0;
}
```

- fseek 函数

|函数声明|`int fseek ( FILE * stream, long offset, int whence);`|
|---|---|
|所在文件|`stdio.h`|
|函数功能|偏移文件指针。对于二进制流，将其设置为距 `whence` 指定位置 `offset` 字节的新位置。对于文本流，`offset` 必须为零，或者是由 `ftell` 返回的值且 `whence` 为 `SEEK_SET`。|
|参数及返回解析||
|参 数|`FILE * stream` 文件句柄|
|参数|`long offset` 偏移量 (字节数)|
|参数|`int whence` 偏移起始位置 (`SEEK_SET`, `SEEK_CUR`, `SEEK_END`)|
|返回值|`int` 成功返回 0 ，失败返回非零值。|

- 常用宏

```c
// ##define SEEK_CUR 1 // 当前位置 (Current position of the file pointer)
// ##define SEEK_END 2 // 文件结尾 (End of file)
// ##define SEEK_SET 0 // 文件开头 (Beginning of file)
// These are defined in stdio.h
```

```c
##include <stdio.h>

int main()
{
    FILE *fp = fopen("test_fseek_len.txt", "w+");
    if (fp == NULL) { perror("打开文件失败"); return 1; }
    
    fputs("123456789", fp);
    fflush(fp); // Ensure data is written before ftell/fseek on w+ stream for length
    
    // 将文件指针移动到文件结尾, 并且偏移0个单位
    if (fseek(fp, 0, SEEK_END) != 0) { perror("fseek 到文件尾失败"); fclose(fp); return 1; }
    long len = ftell(fp); // 计算文件长度
    if (len == -1L) { perror("ftell 失败"); fclose(fp); return 1; }
    printf("len = %ld\n", len); // Should be 9
    
    fclose(fp);
    return 0;
}
```

```c
##include <stdio.h>

int main()
{
    FILE *fp;
   fp = fopen("file_fseek_write.txt","w+"); // Create/truncate, open for update
   if (fp == NULL) { perror("打开文件失败"); return 1; }

   fputs("123456789", fp); // File content: 123456789
   fflush(fp);

   // 将文件指针从文件开头移动7个字节 (到 '8' 的位置)
   if (fseek( fp, 7, SEEK_SET ) != 0) { perror("fseek 失败"); fclose(fp); return 1; }
   fputs("lnj", fp); // Overwrites "89" and adds "j" -> "1234567lnj"
   
   fclose(fp);
    return 0;
}
```

- `ferror` 函数

|函数声明|`int ferror(FILE *stream);`|
|---|---|
|所在文件|`stdio.h`|
|函数功能|检查给定流的错误指示符。|
|参数及返回解析||
|参数|`FILE *stream` 文件句柄。|
|返回值|`int` 如果设置了错误指示符则返回非零值，否则返回零。|

---
# **第十部分：预处理与杂项**

## 32. 预处理指令
#### 32.1. 预处理指令的概念
- C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释(比如之前使用的##include文件包含指令)，产生一个新的源程序(这个过程称为编译预处理),之后再进行通常的编译
- 为了区分预处理指令和一般的C语句，所有预处理指令都以符号“##”开头，并且结尾不用分号
- 预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件
- C语言提供了多种预处理功能,如宏定义、文件包含、条件编译等。合理地使用预处理功能编写的程序便于阅读、修改、移植和调试,也有利于模块化程序设计。

---

#### 32.2. 宏定义
- 被定义为“宏”的标识符称为“宏名”。在编译预处理时,对程序中所有出现的“宏名”,都用宏定义中的字符串去代换,这称为“宏代换”或“宏展开”。
- 宏定义是由源程序中的宏定义命令完成的。宏代换是由预处理程序自动完成的。在C语言中,“宏”分为有参数和无参数两种。  
###### 32.2.1. 不带参数的宏定义
- 格式:`##define 标识符 字符串`
    - 其中的“##”表示这是一条预处理命令。凡是以“##”开头的均为预处理命令。“define”为宏定义命令。“标识符”为所定义的宏名。“字符串”可以是常数、表达式、格式串等。

```c
##include <stdio.h>

  // 源程序中所有的宏名PI在编译预处理的时候都会被3.14所代替
  ##define PI 3.14

 // 根据圆的半径计radius算周长
 float girth(float radius) {
    return 2 * PI *radius;
}

int main ()
 {
    float g = girth(2);

    printf("周长为：%f\n", g); // Added newline
    return 0;
}
```

- **注意点:**

1. 宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误

- 2)对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作

```c
##define R_MACRO 10 // Renamed to avoid conflict with common variable names
 int main ()
 {
     char *s = "Radio"; // 在第1行定义了一个叫R_MACRO的宏，但是第4行中"Radio"里面的'R'并不会被替换成10
     printf("%s\n", s); // Added to use s
     return 0;
 }
```

- 3)在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。只有在编译的时候才对已经展开宏名的源程序进行语法检查

```c
##define I_MACRO {10, 20, 30} // Renamed, and made it a valid initializer list
 int main ()
 {
     int i_arr[3] = I_MACRO; // Renamed i to i_arr
     printf("%d\n", i_arr[0]); // Added to use i_arr
     return 0;
 }
```

- 4. 宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用`##undef`命令

```c
##include <stdio.h> // Added for printf
##define PI_UNDEF 3.14 // Renamed
int main ()
 {
    printf("%f\n", PI_UNDEF);
    return 0;
}
##undef PI_UNDEF // Undefine PI_UNDEF
// void test_undef() // Renamed
// {
//     printf("%f", PI_UNDEF); // 不能使用: Error, PI_UNDEF is not defined here
// }
```

- 5. 定义一个宏时可以引用已经定义的宏名

```c
##define R_VAL  3.0 // Renamed
##define PI_VAL 3.14 // Renamed
##define L_VAL  (2*PI_VAL*R_VAL) // Parentheses added for safety
##define S_VAL  (PI_VAL*R_VAL*R_VAL) // Parentheses added for safety
```

- 6. 可用宏定义表示数据类型,使书写方便 (More accurately, it's a textual replacement that can look like a type alias, but `typedef` is generally preferred for true type aliasing.)

```c
##include <stdio.h> // Added for printf
##define String char *
int main(int argc, const char * argv[])
{
     String str = "This is a string!";
     printf("%s\n", str); // Added to use str
     return 0;
}
```

---

###### 32.2.2. 带参数的宏定义
- C语言允许宏带有参数。在宏定义中的参数称为形式参数,在宏调用中的参数称为实际参数。对带参数的宏,在调用中,不仅要宏展开,而且要用实参去代换形参
- 格式: `##define 宏名(形参表) 字符串`
- **重要: 宏名和左括号之间不能有空格。**

```c
##include <stdio.h> // Added for printf
// 第1行中定义了一个带有2个参数的宏average，
 ##define AVERAGE(a, b) (((a)+(b))/2.0) // Added parentheses for safety and .0 for float division

int main ()
  {
  // 第4行其实会被替换成：int a = ((10)+(4))/2.0;，
      double a = AVERAGE(10, 4); // Changed to double for potentially fractional average
  // 输出结果为：7 (or 7.0 if double)
      printf("平均值：%f\n", a); // Corrected format specifier
     return 0;
 }
```

- **注意点:**
- 1)宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.

```c
// ##define AVERAGE_BAD (a, b) (a+b)/2 // AVERAGE_BAD is defined as "(a,b) (a+b)/2"

//  int main ()
//  {
//      int a = AVERAGE_BAD(10, 4); // This would expand incorrectly
//      return 0;
//  }
// 注意第1行的宏定义，宏名AVERAGE_BAD跟(a, b)之间是有空格的，于是，第5行就变成了这样：
// int a = (a, b) (a+b)/2(10, 4);
// 这个肯定是编译不通过的
```

- 2)带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。

```c
##include <stdio.h>
  // 下面定义一个宏D(a)，作用是返回a的2倍数值：
  ##define D_MACRO(a) (2*(a)) // Parenthesize 'a' and the whole expression
  // 如果定义宏的时候不用小括号括住参数 (Original was ##define D(a) 2*a)

  int main ()
  {
  // 将被替换成int b = (2*(3+4));，输出结果14
     int b = D_MACRO(3+4);
     printf("%d\n", b);
     return 0;
 }
```

- 3)计算结果最好也用括号括起来

```c
##include <stdio.h>
// 下面定义一个宏P(a)，作用是返回a的平方
##define POW_MACRO(a) ((a) * (a)) // Parenthesize 'a' and the whole expression

int main(int argc, const char * argv[])      {
// 代码被替换为:int b = ((10) * (10)) / ((2) * (2));
// 简化之后：int b = (100) / (4);，最后变量b为:25
      int b = POW_MACRO(10) / POW_MACRO(2);

      printf("%d\n", b);
      return 0;
}
```

---

#### 32.3. 条件编译
- 在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译。
- 为什么要使用条件编译
    - 1)按不同的条件去编译不同的程序部分,因而产生不同的目标代码文件。有利于程序的移植和调试。
    - 2)条件编译当然也可以用条件语句来实现。 但是用条件语句将会对整个源程序进行编译,生成 的目标代码程序很长,而采用条件编译,则根据条件只编译其中的程序段1或程序段2,生成的目 标程序较短。  
###### 32.3.1. `##if` - `##else` - `##endif` 条件编译指令
- 第一种格式:
    - 它的功能是,如常量表达式的值为真(非0),则将code1 编译到程序中,否则对code2编译到程序中。
    - 注意:
        - 是将代码编译进可执行程序, 而不是执行代码
        - 条件编译后面的条件表达式中不能识别变量,它里面只能识别常量和宏定义 (And results of `defined()` operator)

```c
##if 常量表达式
    // ..code1...
##else
    // ..code2...
##endif
```

```c
##include <stdio.h> // Added for printf
##define SCORE 67
int main() { // Added main wrapper
##if SCORE > 90
    printf("优秀\n");
##elif SCORE > 60 // Using elif for better structure
    printf("良好\n");
##else
    printf("不及格\n");
##endif
    return 0; // Added return
}
```

- 第二种格式: (`##elif`)

```c
##if 条件1
  // ...code1...
 ##elif 条件2
  // ...code2...
 ##else
  // ...code3...
 ##endif
```

```c
##include <stdio.h> // Added for printf
##define SCORE_ELIF 67 // Renamed
int main() { // Added main wrapper
##if SCORE_ELIF > 90
    printf("优秀\n");
##elif SCORE_ELIF > 60
    printf("良好\n"); // This will be compiled and printed
##else
    printf("不及格\n");
##endif
    return 0; // Added return
}
```
###### 32.3.2. `##ifdef` 和 `##ifndef`
- `##ifdef 宏名`
  - 如果宏名已被定义，则编译后续代码。
- `##ifndef 宏名`
  - 如果宏名未被定义，则编译后续代码。
- 常用语防止头文件重复包含：
  ```c
  // myheader.h
  ##ifndef MYHEADER_H
  ##define MYHEADER_H
  // ... declarations ...
  ##endif
  ```

---

## 33. 其他关键字
#### 33.1. `typedef` 关键字
- C语言不仅提供了丰富的数据类型,而且还允许由用户自己定义类型说明符,也就是说允许由用户为数据类型取“别名”。
- 格式: `typedef 原类型名 新类型名;`
    - 其中原类型名中含有定义部分,新类型名一般用大写表示,以便于区别。 (Convention, not a strict rule)
    - 有时也可用宏定义来代替typedef的功能,但是宏定义是由预处理完成的,而typedef则是在编译 时完成的,后者更为灵活方便。  

- ## typedef使用

- 基本数据类型

```c
typedef int INTEGER; // INTEGER is now an alias for int
// INTEGER a; // 等价于 int a;
```

- 也可以在别名的基础上再起一个别名

```c
typedef int Integer_alias; // Renamed
typedef Integer_alias MyInteger_alias; // Renamed
// MyInteger_alias b; // Equivalent to int b;
```

- 用typedef定义数组、指针、结构等类型将带来很大的方便,不仅使程序书写简单而且使意义更为 明确,因而增强了可读性。
    
- 数组类型
    

```c
typedef char NAME_TYPE[20]; // 表示NAME_TYPE是字符数组类型,数组长度为20。
// NAME_TYPE a_name; // 等价于 char a_name[20];
```

- 结构体类型
    - 第一种形式:

```c
 struct Person_td1{ // Renamed
    int age;
    char *name;
};

typedef struct Person_td1 PersonType1; // Renamed
// PersonType1 p1; // p1 is of type struct Person_td1
```

- 第二种形式: (Combined struct definition and typedef)

```c
typedef struct Person_td2{ // Renamed
    int age;
    char *name;
} PersonType2; // Renamed
// PersonType2 p2;
```

- 第三种形式: (Typedef for an anonymous struct)

```c
typedef struct { // Anonymous struct
    int age;
    char *name;
} PersonType3; // Renamed
// PersonType3 p3;
```

- 枚举
    - 第一种形式:

```c
enum Sex_td1{ // Renamed
    SexMan_td1, SexWoman_td1, SexOther_td1 // Renamed
};
typedef enum Sex_td1 SexType1; // Renamed
// SexType1 s1;
```

- 第二种形式:

```c
typedef enum Sex_td2{ // Renamed
    SexMan_td2, SexWoman_td2, SexOther_td2
} SexType2; // Renamed
// SexType2 s2;
```

- 第三种形式:

```c
typedef enum{ // Anonymous enum
    SexMan_td3, SexWoman_td3, SexOther_td3
} SexType3; // Renamed
// SexType3 s3;
```

- 指针
    - typedef与指向结构体的指针

```c
 // 定义一个结构体并起别名
  typedef struct Point_struct { // Added a tag for clarity, though typedef makes it optional for use
      float x;
      float y;
  } Point_td; // Renamed

 // 起别名 (PP is an alias for "pointer to Point_td")
 typedef Point_td *PointPtr; // Renamed PP to PointPtr for clarity
 // PointPtr pp1; // pp1 is a pointer to Point_td
```

- typedef与指向函数的指针

```c
##include <stdio.h> // Added for printf

// 定义一个sum函数，计算a跟b的和
  int sum_func_ptr_ex(int a, int b) { // Renamed
      int c = a + b;
      printf("%d + %d = %d\n", a, b, c);
      return c;
 }
 // MySumFuncPtr is an alias for "pointer to function taking (int, int) and returning int"
 typedef int (*MySumFuncPtr)(int, int); 

int main() { // Added main wrapper
    // 定义一个指向sum_func_ptr_ex函数的指针变量p
    MySumFuncPtr p_f = sum_func_ptr_ex; // Renamed
    p_f(5, 7); // Call the function via pointer
    return 0; // Added return
}
```

---

#### 33.2. 宏定义与函数以及`typedef`区别
- 与函数的区别
    - 从整个使用过程可以发现，带参数的宏定义，在源程序中出现的形式与函数很像。但是两者是有本质区别的：
        - 1> 宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题 (It's a textual substitution before compilation. Type checking happens after substitution.)
        - 2> 函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率 (This can be true for very simple macros due to avoiding function call overhead, but complex macros can lead to code bloat and be harder to debug. Inline functions (C99+) can offer similar performance with type safety.)
- typedef和##define的区别
    - 用宏定义表示数据类型和用typedef定义数据说明符的区别。
        - 宏定义只是简单的字符串替换,￼是在预处理完成的
        - typedef是在编译时处理的,它不是作简单的代换,而是对类型说明符￼重新命名。被命名的标识符具有类型定义说明的功能 (It creates a true alias for a type, understood by the compiler.)

```c
// typedef char *String_td; // Renamed
// int main(int argc, const char * argv[])
// {
//      String_td str = "This is a string!";
//      return 0;
// }


// ##define String_def char * // Renamed
// int main(int argc, const char * argv[])
// {
//     String_def str = "This is a string!";
//      return 0;
// }
```

```c
##include <stdio.h> // Added for printf

typedef char *StringTypedef; // StringTypedef is an alias for char*
##define StringDefine char *   // StringDefine will be textually replaced by char*

int main(int argc, const char * argv[]) {
    StringTypedef str1_td, str2_td; // Both str1_td and str2_td are char*
    StringDefine str3_def, str4_def; // Expands to: char *str3_def, str4_def;
                                     // So, str3_def is char*, but str4_def is char.

    str1_td = "Hello";
    str2_td = "World";
    // str1_td and str2_td are pointers.

    str3_def = "Hi";
    // str4_def = "There"; // Error: str4_def is a char, not a char*
    // str4_def = 'T'; // This would be valid for str4_def

    printf("str1_td: %s\n", str1_td);
    printf("str2_td: %s\n", str2_td);
    printf("str3_def: %s\n", str3_def);
    // printf("str4_def: %c\n", str4_def); // If str4_def = 'T';

    return 0;
}
```

---

#### 33.3. `const` 关键字
- const是一个类型修饰符
    - 使用const修饰变量则可以让变量的值不能改变 (It declares that the variable is read-only. Attempting to modify it directly will result in a compile-time error.)  


- ## const有什么主要的作用?

- (1)可以定义const常量,具有不可变性

```c
// const int Max_const = 100; // Renamed
// int Array[Max_const]; // If Max_const is a true compile-time constant, this is valid for array size.
                      // In C, a const-qualified variable is not necessarily a compile-time constant
                      // for array dimensions unless it's also static or initialized by a constant expression.
                      // For array dimensions, ##define is more common or `enum { Max_enum = 100 };`
```

- (2)便于进行类型检查,使编译器对处理内容有更多了解,消除了一些隐患。 (When used with function parameters, it indicates the function should not modify the parameter.)

```c
 void func_const_param(const int i_param) { /* i_param cannot be changed here */ } // Renamed
```

- 编译器就会知道i是一个常量,不允许修改;

- (3)可以避免意义模糊的数字出现,同样可以很方便地进行参数的调整和修改。 同宏定义一样,可以做到不变则已,一变都变!如(1)中,如果想修改Max的内容,只需要:`const int Max=you want;`即可!
    
- (4)可以保护被修饰的东西,防止意外的修改,增强程序的健壮性。 还是上面的例子,如果在 函数体内修改了i,编译器就会报错;
    

```c
// void f_const_err(const int i_err) { i_err=10;/*error!*/ } // Renamed
```

- (5) 可以节省空间,避免不必要的内存分配。 (This is more nuanced. `const` variables, especially global or static ones, might be placed in a read-only data segment. If the compiler can determine their value at compile time and they are used in contexts requiring a compile-time constant, they might be substituted directly, similar to a macro, avoiding runtime memory access. However, if their address is taken, they must have storage.)

```c
// ##define PI_DEFINE 3.14159 //常量宏
// const double Pi_const_var=3.14159; //此时并未将Pi_const_var放入ROM中 ...... (It might be in a read-only data section)
// double i_val=Pi_const_var; //此时为Pi_const_var分配内存,以后不再分配! (Pi_const_var already has storage if it's a global/static. This copies its value.)
// double I_val_def=PI_DEFINE; //编译期间进行宏替换,分配内存 (PI_DEFINE is replaced by 3.14159; I_val_def gets storage)
// double j_val=Pi_const_var; //没有内存分配 (j_val gets storage, Pi_const_var's value is copied)
// double J_val_def=PI_DEFINE; //再进行宏替换,又一次分配内存! (J_val_def gets storage)
// const定义常量从汇编的角度来看,只是给出了对应的内存地址,而不是象##define一样给出的是立即数,所以,const定义的常量在程序运行过程中只有一份拷贝,而##define定义的常量在内存 中有若干个拷贝。 (This comparison is complex. `##define` is pure text substitution. If a `##define` macro is used multiple times to initialize different variables, each variable will have its own copy of the value. A `const` global/static variable has one instance in memory. If a `const` is optimized out and its value directly embedded, it might not have a distinct memory location that's accessed at runtime in all cases.)
```

- (6) 提高了效率。编译器通常不为普通const常量分配存储空间,而是将它们保存在符号表 中,这使得它成为一个编译期间的常量,没有了存储与读内存的操作,使得它的效率也很高。 (This is true if the compiler can optimize it by replacing its usage with the literal value. If its address is taken, it must have storage.)

---

###### 33.3.2. 如何使用 `const`?
- (1)修饰一般常量一般常量是指简单类型的常量。这种常量在定义时,修饰符const可以用在类型说明符前,也可以用在类型说明符后

```c
// int const x_const1=2; // Renamed
// const int x_const2=2; // Renamed, equivalent to the above
```

- (当然,我们可以偷梁换柱进行更新: 通过强制类型转换,将地址赋给变量,再作修改即可以改变const常量值。) (This is undefined behavior and should be avoided. While it might "work" on some compilers/systems, it violates the const-correctness and can lead to unpredictable results or crashes, especially if the const variable was placed in read-only memory.)

```c
##include <stdio.h> // Added for printf
int main() { // Added main wrapper
    const int a_const_hack = 5; // Renamed
    printf("Original a_const_hack = %d\n", a_const_hack);
    
    // a_const_hack = 666; // 直接修改会报错 (Correct, compile-time error)
    
    // 偷梁换柱, 利用指针指向变量
    int *p_hack; // Renamed
    p_hack = (int *)&a_const_hack; // Cast away const-ness (dangerous)
    
    // 利用指针间接修改变量中的值
    *p_hack = 10; // Undefined Behavior
    
    printf("a_const_hack after hack = %d\n", a_const_hack); // May print 5 or 10, or crash
    printf("*p_hack = %d\n", *p_hack);
    return 0; // Added return
}
```

- (2)修饰常数组(值不能够再改变了)定义或说明一个常数组可采用如下格式:

```c
// int const a_const_arr[5]={1, 2, 3, 4, 5}; // Renamed
// const int b_const_arr[5]={1, 2, 3, 4, 5}; // Renamed, equivalent
```

```c
// const int arr_const_modify[5]={1, 2, 3, 4, 5}; // Renamed
// arr_const_modify[1] = 55; // 错误: assignment of read-only location arr_const_modify[1]
```

- (3)修饰函数的常参数const修饰符也可以修饰函数的传递参数,格式如下:`void Fun(const int Var);` 告诉编译器Var在函数体中的无法改变,从而防止了使用者的一些无 意的或错误的修改。
    
- (4)修饰函数的返回值: const修饰符也可以修饰函数的返回值,是返回值不可被改变,格式如 下: (If the return type is a pointer or reference to const, it means the pointed-to/referred-to data cannot be modified through that pointer/reference.)
    

```c
// const int Fun1_ret_const(); // Returns a const int (value itself can't be changed by caller easily if it's an rvalue)
// const MyClass* Fun2_ret_ptr_const(); // Returns a pointer to a const MyClass object
```

- (5)修饰常指针
    
    - `const int *A;` //const修饰指针 (Incorrect: const修饰的是`int`, 即A指向的整数是常量), A可变, A指向的值不能被修改
    - `int const *A;` //const修饰指向的对象 (Same as above: A指向的整数是常量), A可变, A指向的对象不可变
    - `int * const A;` //const修饰指针A, A不可变 (A是常量指针), A指向的对象可变
    - `const int * const A;`//指针A和A指向的对象都不可变 (A是常量指针，指向常量整数)
- 技巧
    

```
 先看“*”的位置
 如果const 在 *的左侧 表示值不能修改 (the value pointed to is const),但是指向可以改。
 如果const 在 *的右侧 表示指向不能改 (the pointer itself is const),但是值可以改 (the value pointed to can be modified, unless also const).
 如果在“*”的两侧都有const 标识指向和值都不能改。
```

---

## 34. 计算机底层概念回顾
#### 34.1. 进制基本概念
- 什么是进制?
    
    - 进制是一种计数的方式,数值的表示形式
- 常见的进制
    
    - 十进制、二进制、八进制、十六进制
- 进制书写的格式和规律
    
    - 十进制 0、1、2、3、4、5、6、7、8、9 逢十进一
    - 二进制 0、1 逢二进一
        - 书写形式:需要以0b或者0B开头,例如: 0b101 (C99/C++14 and later)
    - 八进制 0、1、2、3、4、5、6、7 逢八进一
        - 书写形式:在前面加个0,例如: 061
    - 十六进制 0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F 逢十六进一
    
    - 书写形式:在前面加个0x或者0X,例如: 0x45
- 练习
    
    - 1.用不同进制表示如下有多少个方格 (Assuming 10方格)
    - ![](https://i-blog.csdnimg.cn/blog_migrate/00b4df49ccb3a159545620a9149febd7.png)
        - 十进制: 10
        - 二进制: 0b1010
        - 八进制: 012
        - 十六进制: 0xA
    - 2.判断下列数字是否合理
    
    ```
    00011  (八进制, 合理, 等于十进制9)
    0x001  (十六进制, 合理, 等于十进制1)
    0x7h4  (不合理, h不是十六进制数字)
    10.98  (十进制浮点数, 合理)
    0986   (不合理, 9和8不是八进制数字)
    .089   (十进制浮点数, 合理, 等于0.089)
    -109   (十进制整数, 合理)
    +178   (十进制整数, 合理)
    0b325  (不合理, 3,2,5不是二进制数字)
    0b0010 (二进制, 合理, 等于十进制2)
    0xffdc (十六进制, 合理)
    96f    (单精度浮点数, 合理, 等于96.0f)
    96.0f  (单精度浮点数, 合理)
    // 96.oF  (不合理, oF不是有效的浮点后缀)
    -.003  (十进制浮点数, 合理, 等于-0.003)
    ```
    

---

#### 34.2. 进制转换
- 10 进制转 2 进制
    - 除2取余, 余数倒序; 得到的序列就是二进制表示形式
    - 例如: 将十进制(97) 10转换为二进制数  
        ![](https://i-blog.csdnimg.cn/blog_migrate/5f04ab9341c8f41026ce127756d41909.png)
        97 / 2 = 48 ... 1
        48 / 2 = 24 ... 0
        24 / 2 = 12 ... 0
        12 / 2 = 6  ... 0
        6  / 2 = 3  ... 0
        3  / 2 = 1  ... 1
        1  / 2 = 0  ... 1
        倒序: 1100001. 所以 (97)₁₀ = (1100001)₂

---

- 2 进制转 10 进制
    
    - 每一位二进制进制位的值 * 2的当前索引次幂; 再将所有位求出的值相加
    - 例如: 将二进制01100100转换为十进制
    
    ```
    01100100 (从右到左，索引从0开始)
    第0位 (右数第1位): 0 * 2^0 = 0 * 1 = 0
    第1位 (右数第2位): 0 * 2^1 = 0 * 2 = 0
    第2位 (右数第3位): 1 * 2^2 = 1 * 4 = 4
    第3位 (右数第4位): 0 * 2^3 = 0 * 8 = 0
    第4位 (右数第5位): 0 * 2^4 = 0 * 16 = 0
    第5位 (右数第6位): 1 * 2^5 = 1 * 32 = 32
    第6位 (右数第7位): 1 * 2^6 = 1 * 64 = 64
    第7位 (右数第8位): 0 * 2^7 = 0 * 128 = 0
    最终结果为: 0 + 0 + 4 + 0 + 0 + 32 + 64 + 0 = 100
    所以 (01100100)₂ = (100)₁₀
    ```
    

---

- 2 进制转 8 进制
    
    - 三个二进制位代表一个八进制位, 因为3个二进制位的最大值是7 (111₂ = 7₈)，而八进制是逢8进1
    - 例如: 将二进制01100100转换为八进制数
    
    ```
    从右至左每3位划分为8进制的1位, 不够前面补0
    01100100  ->  001 100 100
    第0组 (右边): 100₂ = 4₈
    第1组 (中间): 100₂ = 4₈
    第2组 (左边): 001₂ = 1₈
    最终结果: (144)₈
    ```
    

---

- 2 进制转 16 进制
    
    - 四个二进制位代表一个十六进制位，因为4个二进制位的最大值是15 (1111₂ = F₁₆)，而十六进制是逢16进1
    - 例如: 将二进制01100100转换为十六进制数
    
    ```
    从右至左每4位划分为16进制的1位, 不够前面补0
    01100100 -> 0110 0100
    第0组 (右边): 0100₂ = 4₁₆
    第1组 (左边): 0110₂ = 6₁₆
    最终结果: (64)₁₆
    ```
    

---

- 其它进制转换为十进制
    
    - 系数 * 基数 ^ 索引 之和
    
    ```
        十进制           -->          十进制
       12345   =  10000 + 2000 + 300 + 40 + 5
               =  (1 * 10 ^ 4)  + (2 * 10 ^ 3) + (3 * 10 ^ 2) + (4 * 10 ^ 1) + (5 * 10 ^ 0)
               =  (1 * 10000) + (2 * 1000) + (3 * 100) + (4 * 10) + (5 * 1) // Corrected 2+1000 to 2*1000
               =  10000 + 2000 + 300 + 40 + 5
               =  12345
       
       规律:
       其它进制转换为十进制的结果 = 系数 * 基数 ^ 索引 之和
       
       系数: 每一位的值就是一个系数 
       基数: 从x进制转换到十进制, 那么x就是基数
       索引: 从最低位(最右边)以0开始, 递增的数
    ```
    
    ```
       二进制        -->      十进制
       (索引) 543210
              101101₂ = (1 * 2^5) + (0 * 2^4) + (1 * 2^3) + (1 * 2^2) + (0 * 2^1) + (1 * 2^0)
                     = 32 + 0 + 8 + 4 + 0 + 1
                     = 45₁₀
       
       八进制        -->     十进制
       016₈  =   (1 * 8^1) + (6 * 8^0) // Leading 0 indicates octal, but 0 itself is not part of value calculation here
             =    8 + 6
             =    14₁₀
       
       十六进制      -->      十进制
       0x11F₁₆ =  (1 * 16^2) + (1 * 16^1) + (15 * 16^0) // F is 15
              =   256  + 16 + 15
              =   287₁₀
    ```
    

---

- 十进制快速转换为其它进制
    
    - 十进制除以`基数`取余, 倒叙读取
    
    ```
       十进制        -->     二进制 (基数 2)
       100₁₀          -->    1100100₂
       100 / 2   = 50     余 0
       50  / 2   = 25     余 0
       25  / 2   = 12     余 1
       12  / 2   = 6      余 0
       6   / 2   = 3      余 0
       3   / 2   = 1      余 1
       1   / 2   = 0      余 1
       (倒序读取余数: 1100100)
       
       十进制        -->     八进制 (基数 8)
       100₁₀          -->     144₈
       100 / 8    = 12    余 4
       12  / 8    = 1     余 4
       1   / 8    = 0     余 1
       (倒序读取余数: 144)
       
       十进制        -->     十六进制 (基数 16)
       100₁₀          --> 64₁₆
       100 / 16   =  6    余 4
       6   / 16   =  0    余 6
       (倒序读取余数: 64)
    ```
    

---

#### 34.3. 十进制小数转换为二进制小数
- 整数部分,直接转换为二进制即可
- 小数部分,使用"乘2取整，顺序排列"
    - 用2乘十进制小数,可以得到积,将积的整数部分取出,再用2乘余下的小数部分,直到积中的小数部分为零，或者达到所要求的精度为止
    - 然后把取出的整数部分按顺序排列起来, 即是小数部分二进制
- 最后将整数部分的二进制和小数部分的二进制合并起来, 即是一个二进制小数
- 例如: 将12.125转换为二进制

```
// 整数部分 (除2取余，倒序)
  12
  12 / 2 = 6 ... 0
   6 / 2 = 3 ... 0
   3 / 2 = 1 ... 1
   1 / 2 = 0 ... 1
// 整数部分 12₁₀ --> 1100₂
  
// 小数部分 (乘2取整，顺序)
  0.125
*     2
  ------
   0.25  // 取整数部分 0
   0.25
*     2
  ------
    0.5  // 取整数部分 0
    0.5
*     2
  ------
    1.0  // 取整数部分 1
    (小数部分为0.0，停止)
// 小数部分 0.125₁₀ --> .001₂

// 12.125₁₀ --> 1100.001₂
```

---

#### 34.4. 二进制小数转换为十进制小数
- 整数部分按照二进制转十进制即可
- 小数部分从最高位(小数点后第一位)开始乘以2的负n次方, n从1开始递增
- 例如: 将 1100.001转换为十进制

```
// 整数部分 (1100₂)
0 * 2^0 = 0
0 * 2^1 = 0
1 * 2^2 = 4
1 * 2^3 = 8
 // 1100₂ == 8 + 4 + 0 + 0 == 12₁₀

// 小数部分 (.001₂) (n=1 for first digit after point, n=2 for second, etc.)
第1位: 0 * 2⁻¹ = 0 * (1/2) = 0
第2位: 0 * 2⁻² = 0 * (1/4) = 0
第3位: 1 * 2⁻³ = 1 * (1/8) = 0.125
// .001₂ == 0 + 0 + 0.125 == 0.125₁₀

// 1100.001₂  --> 12 + 0.125 = 12.125₁₀
```

- 练习:
    - 将0.8125转换为二进制
    - 将0.1101转换为十进制

**解答:**
1.  **0.8125₁₀ 转 二进制:**
    ```
      0.8125
    *      2
    --------
       1.625  // 取整数 1
       0.625
    *      2
    --------
        1.25 // 取整数 1
        0.25
    *      2
    --------
         0.5 // 取整数 0
         0.5
    *      2
    --------
        1.0 // 取整数 1
        (小数部分为0.0，停止)
    // 顺序排列整数部分: .1101
    // 0.8125₁₀  --> 0.1101₂
    ```

2.  **0.1101₂ 转 十进制:**
    ```
    0.1101₂
    第1位 (小数点后): 1 * 2⁻¹ = 1 * 0.5   = 0.5
    第2位:           1 * 2⁻² = 1 * 0.25  = 0.25
    第3位:           0 * 2⁻³ = 0 * 0.125 = 0.0
    第4位:           1 * 2⁻⁴ = 1 * 0.0625= 0.0625
    相加: 0.5 + 0.25 + 0.0 + 0.0625 = 0.8125
    // 0.1101₂ --> 0.8125₁₀
    ```

---

#### 34.5. 原码反码补码

- 计算机只能识别0和1, 所以计算机中存储的数据都是以0和1的形式存储的
- 数据在计算机内部是以补码的形式储存的, 所有数据的运算都是以补码进行的
- 正数的原码、反码和补码
    - 正数的原码、反码和补码都是它的二进制
    - 例如: 12的原码、反码和补码分别为
        - `0000 0000 0000 0000 0000 0000 0000 1100`
        - `0000 0000 0000 0000 0000 0000 0000 1100`
        - `0000 0000 0000 0000 0000 0000 0000 1100`
- 负数的原码、反码和补码
    
    - 二进制的最高位我们称之为符号位, 最高位是0代表是一个正数, 最高位是1代表是一个负数
    - 一个负数的原码, 是将该负数的二进制最高位变为1
    - 一个负数的反码, 是将该数的原码`除了符号位`以外的其它位取反
    - 一个负数的补码, 就是它的反码 + 1
    - 例如: -12的原码、反码和补码分别为
    
    ```
      0000 0000 0000 0000 0000 0000 0000 1100 // 12二进制
      1000 0000 0000 0000 0000 0000 0000 1100 // -12原码
      1111 1111 1111 1111 1111 1111 1111 0011  // -12反码
      1111 1111 1111 1111 1111 1111 1111 0100 // -12补码
    ```
    
- 负数的原码、反码和补码逆向转换
    
    - 反码 = 补码-1
    - 原码= 反码最高位不变, 其它位取反
    
    ```
      1111 1111 1111 1111 1111 1111 1111 0100 // -12补码
      1111 1111 1111 1111 1111 1111 1111 0011  // -12反码
      1000 0000 0000 0000 0000 0000 0000 1100 // -12原码
    ```
    

---

- 为什么要引入反码和补码
    - 在学习本节内容之前,大家必须明白一个东西, 就是计算机只能做加法运算, 不能做减法和乘除法, 所以的减法和乘除法内部都是用加法来实现的
        - 例如: 1 - 1, 内部其实就是 1 + (-1);
        - 例如: 3 * 3, 内部其实就是 3 + 3 + 3;
        - 例如: 9 / 3, 内部其实就是 9 + (-3) + (-3) + (-3);
    - 首先我们先来观察一下,如果只有原码会存储什么问题
        
        - 很明显, 通过我们的观察, 如果只有原码, 1-1的结果不对
        
        ```
          // 1 + 1
           0000 0000 0000 0000 0000 0000 0000 0001 // 1原码
          +0000 0000 0000 0000 0000 0000 0000 0001 // 1原码
           ---------------------------------------
           0000 0000 0000 0000 0000 0000 0000 0010  == 2
        
           // 1 - 1; 1 + (-1);
           0000 0000 0000 0000 0000 0000 0000 0001 // 1原码
          +1000 0000 0000 0000 0000 0000 0000 0001 // -1原码
           ---------------------------------------
           1000 0000 0000 0000 0000 0000 0000 0010 == -2
        ```
        
- 正是因为对于减法来说,如果使用原码结果是不正确的, 所以才引入了反码
    
    - 通过反码计算减法的结果, 得到的也是一个反码;
    - 将计算的结果符号位不变其余位取反,就得到了计算结果的原码
    - 通过对原码的转换, 很明显我们计算的结果是-0, 符合我们的预期
    
    ```
      // 1 - 1; 1 + (-1);
      0000 0000 0000 0000 0000 0000 0000 0001 // 1反码
      1111 1111 1111 1111 1111 1111 1111 1110   // -1反码
      ---------------------------------------
      1111 1111 1111 1111 1111 1111 1111 1111 // 计算结果反码
      1000 0000 0000 0000 0000 0000 0000 0000 // 计算结果原码 == -0
    ```
    
- 虽然反码能够满足我们的需求, 但是对于0来说, 前面的负号没有任何意义, 所以才引入了补码
    
    - 由于int只能存储4个字节, 也就是32位数据, 而计算的结果又33位, 所以最高位溢出了,符号位变成了0, 所以最终得到的结果是0
    
    ```
      // 1 - 1; 1 + (-1);
      0000 0000 0000 0000 0000 0000 0000 0001 // 1补码
      1111 1111 1111 1111 1111 1111 1111 1111   // -1补码
      ---------------------------------------
     10000 0000 0000 0000 0000 0000 0000 0000 // 计算结果补码
      0000 0000 0000 0000 0000 0000 0000 0000 //  == 0
    ```
    

---

#### 34.6. 位运算符

- 程序中的所有数据在计算机内存中都是以二进制的形式储存的。
- 位运算就是直接对整数在内存中的二进制位进行操作
- C语言提供了6个位操作运算符, 这些运算符只能用于整型操作数

|符号|名称|运算结果|
|---|---|---|
|&|按位与|同1为1|
|\||按位或|有1为1|
|^|按位异或|不同为1|
|~|按位取反|0变1,1变0|
|<<|按位左移|乘以2的n次方|
|>>|按位右移|除以2的n次方|

---

- 按位与:
    - 只有对应的两个二进位均为1时，结果位才为1，否则为0
    - 规律: 二进制中，与1相&就保持原位，与0相&就为0

```
9&5 = 1

 1001
&0101
------
 0001
```

---

- 按位或:
    - 只要对应的二个二进位有一个为1时，结果位就为1，否则为0

```
9|5 = 13

 1001
|0101
------
 1101
```

---

- 按位异或
    - 当对应的二进位相异（不相同）时，结果为1，否则为0
    - 规律:
        - 相同整数相的结果是0。比如55=0
        - 多个整数相^的结果跟顺序无关。例如: 567=576
        - 同一个数异或另外一个数两次, 结果还是那个数。例如: 577 = 5

```
9^5 = 12

 1001
^0101
------
 1100
```

---

- 按位取反
    - 各二进位进行取反（0变1，1变0）

```
~9 =-10
0000 0000 0000 0000 0000 1001 // 取反前
1111 1111 1111 1111 1111 0110 // 取反后

// 根据负数补码得出结果
1111 1111 1111 1111 1111 0110 // 补码
1111 1111 1111 1111 1111 0101 // 反码
1000 0000 0000 0000 0000 1010 // 源码 == -10
```

---

- 位运算应用场景:
    
    - 判断奇偶(按位或)
    
    ```
       偶数: 的二进制是以0结尾
       8   -> 1000
       10  -> 1010
       
       奇数: 的二进制是以1结尾
       9   -> 1001
       11  -> 1011
    
       任何数和1进行&操作,得到这个数的最低位
       1000
      &0001
       -----
       0000  // 结果为0, 代表是偶数
    
       1011
      &0001
       -----
       0001 // 结果为1, 代表是奇数
    ```
    
    - 权限系统
    
    ```
      enum Unix {
        S_IRUSR = 256,// 100000000 用户可读
        S_IWUSR = 128,//  10000000 用户可写
        S_IXUSR = 64,//    1000000 用户可执行
        S_IRGRP = 32,//     100000 组可读
        S_IWGRP = 16,//      10000 组可写
        S_IXGRP = 8,//        1000 组可执行
        S_IROTH = 4,//         100 其它可读
        S_IWOTH = 2,//          10 其它可写
        S_IXOTH = 1 //           1 其它可执行
       };
    // 假设设置用户权限为可读可写
    printf("%d\n", S_IRUSR | S_IWUSR); // 384 // 110000000
    ```
    
    - 交换两个数的值(按位异或)
    
    ```
     a = a^b;
     b = b^a;
     a = a^b;
    ```
    

---

- 按位左移
    - 把整数a的各二进位全部左移n位，高位丢弃，低位补0
        - 由于左移是丢弃最高位，0补最低位，所以符号位也会被丢弃，左移出来的结果值可能会改变正负性
    - 规律: 左移n位其实就是乘以2的n次方

```
2<<1; //相当于 2 *= 2 // 4
  0010
<<0100

2<<2; //相当于 2 *= 2^2; // 8
  0010
<<1000
```

- 按位右移
    - 把整数a的各二进位全部右移n位，保持符号位不变
        - 为正数时， 符号位为0，最高位补0
        - 为负数时，符号位为1，最高位是补0或是补1(取决于编译系统的规定)
    - 规律: 快速计算一个数除以2的n次方

```
2>>1; //相当于 2 /= 2 // 1
  0010
>>0001
4>>2; //相当于 4 /= 2^2 // 1
  0100
>>0001
```

- 练习:
    - 写一个函数把一个10进制数按照二进制格式输出

```
##include <stdio.h>
void printBinary(int num);
int main(int argc, const char * argv[]) {
    printBinary(13);
}
void printBinary(int num){
    int len = sizeof(int)*8;
    int temp;
    for (int i=0; i<len; i++) {
        temp = num; //每次都在原数的基础上进行移位运算
        temp = temp>>(31-i); //每次移动的位数
        int t = temp&1; //取出最后一位
        if(i!=0&&i%4==0)printf(" "); printf("%d",t);
    }
}
```
