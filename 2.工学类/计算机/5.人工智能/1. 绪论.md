
使用课本：《人工智能及其应用》第5版 蔡自兴著，清华大学出版社

**目录**

[第1章 绪论](https://blog.csdn.net/qq_46485137/article/details/122089888#t0 "第1章 绪论")

[1.1人工智能的定义与发展](https://blog.csdn.net/qq_46485137/article/details/122089888#t1 "1.1人工智能的定义与发展")

[1.1.1人工智能的定义](https://blog.csdn.net/qq_46485137/article/details/122089888#t2 "1.1.1人工智能的定义")

[1.1.2人工智能的起源与发展](https://blog.csdn.net/qq_46485137/article/details/122089888#t3 "1.1.2人工智能的起源与发展")

[1.2人工智能的各种认知观](https://blog.csdn.net/qq_46485137/article/details/122089888#t4 "1.2人工智能的各种认知观")

[1.2.1 人工智能各学派的认识观](https://blog.csdn.net/qq_46485137/article/details/122089888#t5 "1.2.1 人工智能各学派的认识观")

[1.2.2 人工智能的争议](https://blog.csdn.net/qq_46485137/article/details/122089888#t6 "1.2.2 人工智能的争议")

[1.3 人类智能与人工智能](https://blog.csdn.net/qq_46485137/article/details/122089888#t7 "1.3 人类智能与人工智能")

[1.3.1 智能信息处理系统的假设](https://blog.csdn.net/qq_46485137/article/details/122089888#t8 "1.3.1 智能信息处理系统的假设")

[1.3.2 人类智能的计算机模拟](https://blog.csdn.net/qq_46485137/article/details/122089888#t9 "1.3.2 人类智能的计算机模拟")

[1.3.3 人工智能对人类的影响](https://blog.csdn.net/qq_46485137/article/details/122089888#t10 "1.3.3 人工智能对人类的影响")

[1.4 人工智能系统的分类](https://blog.csdn.net/qq_46485137/article/details/122089888#t11 "1.4 人工智能系统的分类")

[1.4.1专家系统](https://blog.csdn.net/qq_46485137/article/details/122089888#t12 "1.4.1专家系统")

[1.4.2 模糊系统](https://blog.csdn.net/qq_46485137/article/details/122089888#t13 "1.4.2 模糊系统")

[1.4.3 神经网络系统](https://blog.csdn.net/qq_46485137/article/details/122089888#t14 "1.4.3 神经网络系统")

[1.4.4 学习系统](https://blog.csdn.net/qq_46485137/article/details/122089888#t15 "1.4.4 学习系统")

[1.4.5 仿生系统](https://blog.csdn.net/qq_46485137/article/details/122089888#t16 "1.4.5 仿生系统")

[1.4.6 群智能系统](https://blog.csdn.net/qq_46485137/article/details/122089888#t17 "1.4.6 群智能系统")

[1.4.7 多真体系统](https://blog.csdn.net/qq_46485137/article/details/122089888#t18 "1.4.7 多真体系统")

[1.4.8 混合智能系统](https://blog.csdn.net/qq_46485137/article/details/122089888#t19 "1.4.8 混合智能系统")

[1.5 人工智能的研究目标和内容](https://blog.csdn.net/qq_46485137/article/details/122089888#t20 "1.5 人工智能的研究目标和内容")

 [1.5.1 人工智能的研究目标](https://blog.csdn.net/qq_46485137/article/details/122089888#t21 "1.5.1 人工智能的研究目标")

 [1.5.2 人工智能研究的基本内容](https://blog.csdn.net/qq_46485137/article/details/122089888#t22 "1.5.2 人工智能研究的基本内容")

[1.6 人工智能的研究与计算方法](https://blog.csdn.net/qq_46485137/article/details/122089888#t23 "1.6 人工智能的研究与计算方法")

[1.6.1人工智能的研究方法](https://blog.csdn.net/qq_46485137/article/details/122089888#t24 "1.6.1人工智能的研究方法")

[1.7 人工智能的研究与应用领域](https://blog.csdn.net/qq_46485137/article/details/122089888#t25 "1.7 人工智能的研究与应用领域")

[题目：](https://blog.csdn.net/qq_46485137/article/details/122089888#t26 "题目：")

---

# 第1章 绪论

### 1.1人工智能的定义与发展

#### 1.1.1人工智能的定义

        关于人工智能的定义，众说纷纭，还没有统一的定义。

        一般的解释：

>         **人工智能：**用人工的方法在机器（计算机）上实现的智能，或称机器智能、计算机智能。
> 
>         **知识：**人们通过体验、学习或联想而知晓的对客观世界规律性的认识，包括事实、条件、过程、规则、关系和规律等。
> 
>         **智能：**一种应用知识对一定环境或问题进行处理的能力或者进行抽象思考的能力。
> 
>         **智能机器：**能够在各类环境中自主地或交互地执行各种拟人任务的机器。

#### 1.1.2人工智能的起源与发展
##### （1）孕育时期（1956年前）

人工智能的理论基础在这一时期由众多开拓者的创造性贡献奠定。古希腊哲学家亚里士多德创立的演绎法及其提出的三段论，为演绎推理提供了基本出发点。德国数学家和哲学家莱布尼茨将形式逻辑符号化，奠定了数理逻辑的基础。英国数学家图灵在1936年创立了自动机理论，即图灵机，并在1950年提出“机器也能思维”的观点，被誉为“人工智能之父”。美国数学家莫克利是电子数字计算机的先驱，1946年成功研制了世界上第一台通用电子数字计算机ENIAC。美国神经生理学家麦克洛奇和皮兹在1943年建成第一个神经网络模型（MP模型），为连接主义学派的发展奠定了基础。美国著名数学家维纳在1948年创立了控制论，对人工智能产生了深远影响，形成了行为主义学派。

##### （2）形成时期（1956 - 1970）

###### 1）诞生

1956年夏，在美国达特茅斯大学举办了一场具有历史意义的研讨会，10人参加并讨论了用机器模拟人类智能的问题。在这次会议上，首次使用了“人工智能”这一术语，标志着人工智能学科的诞生，具有重要的历史意义。

###### 2）迅速发展

1956年，塞缪尔在IBM计算机上成功研制了具有自学习、自组织和自适应能力的西洋跳棋程序。1957年，纽厄尔、肖和西蒙等研制出了数学定理证明程序——逻辑理论机（LT）。1958年，麦卡锡建立了行动规划咨询系统。1960年，纽厄尔等研制了通用问题求解（GPS）程序，麦卡锡则研制了人工智能语言LISP。1961年，明斯基发表了“走向人工智能的步骤”的论文，推动了人工智能的发展。1965年，鲁宾逊提出了归结（消解）原理，费根鲍姆开发了第一个专家系统DENDRAL，用于质谱仪分析有机化合物的分子结构。

##### （3）暗淡（低潮）时期（1970 - 1986）

这一时期，人工智能因过高预言的失败而声誉受损。例如，西蒙在1965年预言“20年内，机器将能做人所能做的一切”，明斯基在1977年预言“在3 - 8年时间里，我们将研制出具有普通人智力的计算机”，这些预言均未能实现。同时，许多人工智能理论和方法未能得到通用化和推广应用，专家系统也尚未获得广泛开发，导致人工智能的重要价值未能凸显。究其原因，当时的人工智能主要存在以下三个局限性：知识局限性、解法局限性和结构局限性。

##### （4）知识应用时期（1970 - 1988）

###### 1）专家系统的突破

1972 - 1976年，费根鲍姆研制了MYCIN专家系统，用于协助内科医生诊断细菌感染疾病，并提供最佳处方。1976年，斯坦福大学的杜达等人研制了地质勘探专家系统PROSPECTOR。1977年，费根鲍姆提出了知识工程的概念。专家系统的出现实现了人工智能从理论研究走向专门知识应用，是AI发展史上的一次重要突破与转折。

###### 2）其他应用研究的发展

计算机视觉、机器人、自然语言理解、机器翻译等AI应用研究在这一时期也获得了发展。在开发专家系统的过程中，许多研究者达成共识：人工智能系统是一个知识处理系统，人工智能的三个基本问题为知识表示、知识利用和知识获取。

##### （5）集成发展时期（1986年至今）

###### 1）专家系统的改进

专家系统存在应用领域狭窄、缺乏常识性知识、知识获取困难、推理方法单一、没有分布式功能、不能访问现存数据库等不足，促使研究者对其进行改进与发展。

###### 2）其他研究的深入

机器学习、人工神经网络、计算智能、智能机器人和行为主义研究在这一时期趋向热烈和深入。计算智能（CI）的出现弥补了人工智能在数学理论和计算上的不足，更新和丰富了人工智能理论框架，推动了人工智能进入新的发展时期。


### 1.2**人工智能的各种认知观**

   人工智能的**三个学派**：**符号主义、连接主义、行为主义**

#### 1.2.1 人工智能各学派的认识观

|   |   |   |   |   |
|---|---|---|---|---|
||**别名**|**原理**|**起源**|**学派代表**|
|**符号主义**|逻辑主义、心理学派或计算机学派|物理符号系统（即符号操作系统）假设和有限合理性原理|数理逻辑/逻辑推理|纽厄尔、西蒙和尼尔逊等|
|**连接主义**|仿生学派或生理学派|神经网络及神经网络间的连接机制与学习算法。|仿生学，特别是人脑模型的研究|卡洛克、皮茨、 霍普菲尔德、鲁梅尔哈特等。|
|**行为主义**|进化主义或控制论学派|控制论及感知-动作型控制系统|控制论|布鲁克斯的六足行走机器人，一个基于感知-动作模式的模拟昆虫行为的控制系统。|

#### 1.2.2 人工智能的争议

|   |   |   |
|---|---|---|
||**对人工智能理论的争论**|**对人工智能方法的争论**|
|**符号主义**|认为人的**认知基元**是**符号**，认知过程即符号操作过程<br><br>认为人是一个物理符号系统，计算机也是一个物理符号系统，因此能够用计算机来模拟人的智能行为。<br><br>人工智能的核心问题是知识表示、知识推理和知识运用。|功能模拟方法：模拟人类认知系统所具备的功能，通过数学逻辑方法来实现人工智能。|
|**连接主义**|认为**思维基元**是**神经元**，而不是符号处理过程。<br><br>认为人脑不同于电脑，并提出连接主义的大脑工作模式，用于取代符号操作的电脑工作模式。|结构模拟方法：模拟人的生理神经网络结构，不同的结构表现出不同的功能和行为。认为功能、结构和智能行为是不可分的。|
|**行为主义**|认为智能取决于**感知和行动**(所以被称为行为主义)，提出智能行为的“感知—动作”模式。<br><br>认为智能不需要知识、不需要表示、不需要推理；人工智能可以象人类智能一样逐步进化（称为进化主义）；智能行为只能在现实世界中与周围环境交互作用而表现出来。|行为模拟方法：采用行为模拟方法，也认为功能、结构和智能行为是不可分的。不同行为表现出不同功能和不同控制结构。|

 
对人工智能技术路线的争论

| 路线名称     | 描述                                        |
| -------- | ----------------------------------------- |
| **专用路线** | 强调研制与开发专用智能计算机、人工智能软件、开发工具、人工智能语言和其他专用设备。 |
| **通用路线** | 认为通用计算机硬件和软件能够对人工智能开发提供有效支持，解决一般人工智能问题。   |
| **硬件路线** | 认为人工智能发展主要依靠硬件技术。                         |
| **软件路线** | 强调人工智能发展主要依靠软件技术。                         |

### 1.3 人类智能与人工智能

#### **1.3.1 智能信息处理系统的假设**

   **1.人和计算机的认知活动**：

>         人类：生理过程→初级信息处理→思维策略
> 
>         计算机：计算机硬件→计算机语言→计算机程序

   2.**认知过程**：

> ![](https://i-blog.csdnimg.cn/blog_migrate/bed42329554f34c196817a6aa0ef2b08.png) 
> T表示时间，x表示认知操作，x的变化Δx 为当时机体状态S和外界刺激R的函数

   **3. 符号操作系统（信息处理系统）的六种基本功能：**

>         输入符号、输出符号、存储符号、复制符号、建立符号结构、条件性迁移

   **4. 认知的四个层次**

>         认知生理学、认知心理学、认知信息学、认知工程学

#### **1.3.2 人类智能的计算机模拟**

   计算机早期工作主要集中在数值计算方面，但人类最主要的智力活动并不是数值计算，而是逻辑推理方面。

   计算机可以模拟人的智能活动过程，如下棋、定理证明、翻译语言文字和解决难题等。

   自学习、并行计算、启发式搜索、机器学习、智能决策等人工智能技术的发展已用于博弈程序设计，使得“计算机棋手”水平大为提高。        

>         深蓝→小深→浪潮天梭→AlphaGo
> 
>         电子计算机→量子计算机→光子计算机

#### **1.3.3** **人工智能对人类的影响**

   经济、社会、文化

### 1.4 人工智能系统的分类

   **专家系统、模糊系统、神经网络系统、学习系统、仿生系统、群智智能系统、多真体系统、混合智能系统**

#### 1.4.1专家系统

   人工智能和智能系统应用研究最活跃和最广泛的领域之一

   专家系统的技术和方法，及工程控制论的反馈机制有机结合

   一般研究具有不确定性的问题

   应用领域：故障诊断、工业设计、过程控制等

   主要组成：知识库、推理机、控制规则集、算法

#### 1.4.2 模糊系统

   应用模糊集合理论的智能系统，模糊集合理论提出者：Zedeh

   实现基于知识（规则）甚至语义描述的表示、推理和操作规律

   对非线性系统设计容易，尤其含有不确定性的系统

#### 1.4.3 神经网络系统

        人工神经网络ANN

        生物神经元特性的互连模型

        应用领域：模式识别、图像处理、自动控制、机器人、信号处理等

#### 1.4.4 学习系统

        通过学习获取和增加知识

#### 1.4.5 仿生系统

        模仿自然，包括人类和生物的自然智能

        选择、交叉、变异来适应大自然，物竞天择，适者生存

        遗传算法

#### 1.4.6 群智能系统

        群：某种交互作用的组织、Agent的结构集合

        个体行为和全局群行为

        蚁群算法

#### 1.4.7 多真体系统

        并行计算、分布式处理

        真体：通过传感器感知环境并借助执行器作用于该环境的任何事物

#### 1.4.8 混合智能系统

        模糊系统擅长不确定，神经网络擅长学习，进化计算擅长优化

### **1.5** **人工智能的研究目标和内容**

####  1.5.1 人工智能的研究目标

     **1.人工智能的一般研究目标**

        （1）理解人类智能

                通过编写程序来模仿和检验人类智能的有关理论，更好地理解人类智能。

       （2） 实现人类智能

                创造有用的灵巧程序，执行一般需要人类专家才能实现的任务，实现人类智能

     **2.人工智能的近期目标：**

        建造智能计算机代替人类的部分智力劳动。

     **3.人工智能的近期目标：**

        揭示人类智能的根本机理，用智能机器去模拟、延伸和扩展人类的智能。

>       近期目标为远期目标奠定了理论和技术基础，远期目标为近期目标指明了方向

####  1.5.2 人工智能研究的基本内容

|   |   |
|---|---|
|认知建模|信息处理、符号运算、问题求解、思维、关联活动|
|知识表示|状态空间、问题归约、谓词逻辑、语义网络……|
|知识推理|确定性推理：启发式搜索、消解原理、规则演绎……<br><br>非经典推理：不确定性推理、概率推理、贝叶斯推理……|
|知识应用|机器学习、专家系统、自动规划、自然语言理解……|
|机器感知|计算机视觉、机器听觉……|
|机器思维|对传感信息和内部工作信息进行有目的的处理|
|机器学习|学习新知识和新技术并在实践中不断改进和|
|机器行为|表达能力、行为能力|
|智能系统构建|构成技术、分析技术、语言设计|

### **1.6** **人工智能的研究与计算方法**

#### 1.6.1人工智能的研究方法

        功能模拟法

        结构模拟法       

        行为模拟法

        集成模拟法

#### 1.6.2 人工智能的计算方法

        概率计算

        符号规则逻辑计算

        模糊计算

        神经计算

        进化计算与免疫计算

        群优化计算

### **1.7** **人工智能的研究与应用领域**

        问题求解与博弈

        逻辑推理与定理证明

        计算智能

        分布式人工智能与真体（Agent）

        自动程序设计

        专家系统

        机器学习

        自然语言处理

        机器人学

        模式识别

        机器视觉

        神经网络

        智能控制

        ……

### 题目

1、人工智能发展的三个阶段： [填空1]阶段、 [填空2]阶段、 [填空3]阶段。

> [填空1] 人工智能的推理阶段(1950-1970) 这一阶段,大多数人认为,实现人工智能只需要赋予机器逻辑推理能力就可以,因此,机器只是具备了逻辑推理能力,并未达到智能化水平。
> 
> [填空2] 人工智能的知识工程阶段(1970-1990) 这一阶段,人们普遍认为,只有让机器学习知识之后才可以实现人工智能。在这种情况下,大量的专家系统被开发出来。但人们发现,给机器灌输已经总结好的知识并不是一件容易的事。
> 
> [填空3] 人工智能的数据挖掘阶段(2000-) 目前,已经提出的机器学习算法都得到了非常好的应用。深度学习技术获得了迅猛的进展。人们希望机器可以通过海量数据分析自动总结学习到知识,从而实现自身的智能化。

2、人工智能的三大认知观： [填空1] 主义、 [填空2] 主义、 [填空3] 主义。

> 答案：符号主义、连接主义、行为主义



**目录**

[本章学习内容](https://blog.csdn.net/qq_46485137/article/details/122101559#t0 "本章学习内容")

[预备知识](https://blog.csdn.net/qq_46485137/article/details/122101559#t1 "预备知识")

   [1、什么是知识？](https://blog.csdn.net/qq_46485137/article/details/122101559#t2 "1、什么是知识？")

   [2、知识层次](https://blog.csdn.net/qq_46485137/article/details/122101559#t3 "2、知识层次")

   [3、知识的属性](https://blog.csdn.net/qq_46485137/article/details/122101559#t4 "3、知识的属性")

   [4、知识表示的相关概念](https://blog.csdn.net/qq_46485137/article/details/122101559#t5 "4、知识表示的相关概念")

   [5、知识表示的基本方法](https://blog.csdn.net/qq_46485137/article/details/122101559#t6 "5、知识表示的基本方法")

[2.1 状态空间表示](https://blog.csdn.net/qq_46485137/article/details/122101559#t7 "2.1 状态空间表示")

[2.1.1 问题状态描述](https://blog.csdn.net/qq_46485137/article/details/122101559#t8 "2.1.1 问题状态描述")

   [1、主要概念](https://blog.csdn.net/qq_46485137/article/details/122101559#t9 "1、主要概念")

   [2、实例—8数码难题](https://blog.csdn.net/qq_46485137/article/details/122101559#t10 "2、实例—8数码难题")

[2.1.2 状态图示法](https://blog.csdn.net/qq_46485137/article/details/122101559#t11 "2.1.2 状态图示法")

   [1、相关概念](https://blog.csdn.net/qq_46485137/article/details/122101559#t12 "1、相关概念")

   [2、实例—猴子与香蕉问题](https://blog.csdn.net/qq_46485137/article/details/122101559#t13 "2、实例—猴子与香蕉问题")

[2.2 问题归约表示](https://blog.csdn.net/qq_46485137/article/details/122101559#t14 "2.2 问题归约表示")

[2.2.1 问题归约描述](https://blog.csdn.net/qq_46485137/article/details/122101559#t15 "2.2.1 问题归约描述")

   [1、梵塔难题](https://blog.csdn.net/qq_46485137/article/details/122101559#t16 "1、梵塔难题")

[2.2.2 与或图表示](https://blog.csdn.net/qq_46485137/article/details/122101559#t17 "2.2.2 与或图表示")

   [1、相关概念](https://blog.csdn.net/qq_46485137/article/details/122101559#t18 "1、相关概念")

   [2、与或图构成规则](https://blog.csdn.net/qq_46485137/article/details/122101559#t19 "2、与或图构成规则")

[2.3 谓词逻辑表示](https://blog.csdn.net/qq_46485137/article/details/122101559#t20 "2.3 谓词逻辑表示")

[2.3.1 谓词演算](https://blog.csdn.net/qq_46485137/article/details/122101559#t21 "2.3.1 谓词演算")

   [1、语法和语义](https://blog.csdn.net/qq_46485137/article/details/122101559#t22 "1、语法和语义")

   [2、连词和量词](https://blog.csdn.net/qq_46485137/article/details/122101559#t23 "2、连词和量词")

[2.3.2 谓词公式](https://blog.csdn.net/qq_46485137/article/details/122101559#t24 "2.3.2 谓词公式")

   [1、相关概念](https://blog.csdn.net/qq_46485137/article/details/122101559#t25 "1、相关概念")

   [2、谓词公式的性质](https://blog.csdn.net/qq_46485137/article/details/122101559#t26 "2、谓词公式的性质")

[2.3.3 置换与合一](https://blog.csdn.net/qq_46485137/article/details/122101559#t27 "2.3.3 置换与合一")

[2.4 语义网络表示](https://blog.csdn.net/qq_46485137/article/details/122101559#t28 "2.4 语义网络表示")

 [2.4.1 二元语义网络的表示](https://blog.csdn.net/qq_46485137/article/details/122101559#t29 "2.4.1 二元语义网络的表示")

[2.4.2 多元语义网络的表示](https://blog.csdn.net/qq_46485137/article/details/122101559#t30 "2.4.2 多元语义网络的表示")

 [2.4.3 语义网络的推理过程](https://blog.csdn.net/qq_46485137/article/details/122101559#t31 "2.4.3 语义网络的推理过程")

[2.4.4 语义网络表示的特点与不足](https://blog.csdn.net/qq_46485137/article/details/122101559#t32 "2.4.4 语义网络表示的特点与不足")

[2.4.5 知识表示方法间的关系](https://blog.csdn.net/qq_46485137/article/details/122101559#t33 "2.4.5 知识表示方法间的关系")

[2.5 框架表示](https://blog.csdn.net/qq_46485137/article/details/122101559#t34 "2.5 框架表示")

[2.5.1 框架的构成](https://blog.csdn.net/qq_46485137/article/details/122101559#t35 "2.5.1 框架的构成")       

[2.5.2 框架的推理](https://blog.csdn.net/qq_46485137/article/details/122101559#t36 "2.5.2 框架的推理")

[2.5.3 框架表示的特点与不足](https://blog.csdn.net/qq_46485137/article/details/122101559#t37 "2.5.3 框架表示的特点与不足")

[2.6 本体技术](https://blog.csdn.net/qq_46485137/article/details/122101559#t38 "2.6 本体技术")

[2.6.1 本体的概念](https://blog.csdn.net/qq_46485137/article/details/122101559#t39 "2.6.1 本体的概念")

[2.6.2 本体的组成与分类](https://blog.csdn.net/qq_46485137/article/details/122101559#t40 "2.6.2 本体的组成与分类")

[2.7 过程表示](https://blog.csdn.net/qq_46485137/article/details/122101559#t41 "2.7 过程表示")

---
# 2. 知识表示

本章要点

 了解知识表示的基本含义

⭐掌握常用的知识表示方法

 了解各知识表示方法的优缺点

 会用知识表示方法解决实际问题

## 预备知识

####     **1、什么是知识？**

   **定义**：知识是一个抽象的术语，用于尝试描述人对某种特定对象的理解。

####     **2、知识层次**

   ![](https://i-blog.csdnimg.cn/blog_migrate/fb21a2ba838e65b014eb91ce184f8eeb.png)

![](https://i-blog.csdnimg.cn/blog_migrate/b93bbaa2dde8cdbf955725f75e325fed.png)

####    **3、知识的属性**

真伪性、相对性、不完全性、不确定性、可表示性、可存储性、可传递性和可处理性、相容性

####    **4、知识表示的相关概念**

**（1）知识表示**是**问题求解**的**基础**

>         问题求解是人工智能的核心问题之一
> 
>         问题求解的目的：自动找出某问题的正确解决策略；更进一步，能够机器举一反三，具有解决同类问题的能力

**（2）智能系统**中：

>          **知识**是对世界的描述，决定系统的能力；
> 
>          **表示**是知识的编码方式，决定系统的性能。

**（3）不同类型的知识**需要**不同的表示方式**
     **不同的表示方法**需要**不同的求解技术**

**（4）知识表示过程**：非形式化的自然语言描述→形式化的易于被计算机理解

![](https://i-blog.csdnimg.cn/blog_migrate/498b20d16bfbcf1daaa83c9c8fba03ca.png)

####      **5、知识表示的基本方法**

**状态空间、问题规约、谓词逻辑、产生式规则、语义网络、（框架，剧本，过程）**

## **2.1 状态空间表示**


**状态空间法定义**：一种基于**解空间**的**问题表示**和**问题求解**方法

### 2.1.1 问题状态描述

####     **1、主要概念**



**状态**：描述某类不同事物间的差别而引入的一组**最少变量**q0,q1,…,qn的有序集合

**算符**：使问题从一种状态变化为另一种状态的手段称为操作符或算符。

**问题的状态空间**：一个表示该问题全部可能状态及其关系的**图**，它包含三种说明的集合，即所有可能的问题初始状态的集合S、操作符集合F以及目标状态集合G，记为**三元状态(S，F，G)**。

####     **2、实例—8数码难题**

        从初始状态S  到目标状态G 需要经历哪些操作F？
![](https://i-blog.csdnimg.cn/blog_migrate/10b698fda27087b4aaab4c1627f9f0e9.png)

        解决方案如下，但是如何找到的这些操作呢？
![](https://i-blog.csdnimg.cn/blog_migrate/3876b38b43c87868f4c1060274fe4aa5.png)

   最直接的求解方式是尝试各种不同的走步，直到偶然得到该目标棋局为止。把初始状态可达到的各状态所组成的空间设想程一幅由各种状态对应的节点组成的图，即为**状态图/状态空间图**

   **状态空间图**如下：

![](https://i-blog.csdnimg.cn/blog_migrate/a4997eec348d9f459cc1cf98a252b713.png)

### 2.1.2 状态图示法

####     **1、相关概念**

 **有向图**：一对节点用弧线连接起来，从一个节点指向另一个节点这种图叫做有向图

 **路径**：某个节点序列(ni1，ni2，…，nik)，当 j = 2，3，…，k时，如果对于每一个ni,j-1都有一个后继节点ni,j存在，那么就把这个节点序列叫做从节点ni1至节点nik的长度为k的路径

 **代价**：用c(ni，nj)来表示从节点ni指向节点nj的那段弧线的代价。两节点间路径的代价等于连接该路径上各节点的所有弧线代价之和。

 **显示说明**：各节点及其代价的弧线由一张表明确给出。（显示说明对大型的图是不切实际的，对于具有无限节点集合的图则是不可能的）

**隐式说明**：节点的无限集合{si}作为起始节点已知,后续节点算符Γ已知,由Γ和{si}规定隐式图。各节点及其代价的弧线不能由一张表明确给出。

####     **2、实例—猴子与香蕉问题**

![](https://i-blog.csdnimg.cn/blog_migrate/f0b14f5aee63f825398581aac667187c.png)

   （1）用一个**四元表列（W，x，Y，z）表示这个问题状态

>                 W：猴子的水平位置
> 
>                 x：猴子在箱子顶上时取x=1；否则取x=0
> 
>                 Y：箱子的水平位置
> 
>                 z：当猴子摘到香蕉时取z=1；否则取z=0

  （2）这个问题的**操作**（算符）如下：

>                 goto(U) 表示猴子走到水平位置U
> 
>                 ![](https://i-blog.csdnimg.cn/blog_migrate/052297a8f0167476247284f969aa5cab.png)
> 
>                 Pushbox(V)猴子把箱子推到水平位置V
> 
>                 ![](https://i-blog.csdnimg.cn/blog_migrate/940266737962587cf88176843a6056ae.png)
> 
>                 climbbox猴子爬上箱顶
> 
>                 ![](https://i-blog.csdnimg.cn/blog_migrate/38889e0cabb2a068c1c9b96ff913b4ce.png)
> 
>                 grasp 表示猴子摘到香蕉
> 
>                 ![](https://i-blog.csdnimg.cn/blog_migrate/4f5b5d0442cac83d7b483913aa140a7c.png)
> 
>          注：Pushbox(V)，就要求产生式规则的左边，猴子与箱子必须在同一位置上，并且，猴子不是箱子顶上。这种强加于操作的适用性条件，叫做产生式规则的先决条件。
> 
>         再如climbbox的先决条件是：猴子的位置和箱子的位置在一处，且猴子不在箱顶。

   （3）这个问题的**初始状态**: (a, 0, b, 0），**目标状态**:（c, 1, c, 1）
	从初始状态到目标状态的**操作序列**： {goto(b), pushbox(c), climbbox, grasp}

  （4）猴子和香蕉问题的**状态空间图：**

![](https://i-blog.csdnimg.cn/blog_migrate/a961aaa795b00319312f9aa8f73efadd.png)

## **2.2** **问题归约表示**

**问题规约**是另一种基于状态空间的问题描述与解释方法。

**1、****思路**：

>         给定一个问题描述，将原始问题通过一系列转化操作转化为一些子问题的集合，最终把初始问题归约为一个平凡的**本原问题**（可直接求解的问题）集合，通过求解这些问题来求解原始问题。

**2、问题规约表示**的**组成部分**：

>         （1）一个初始问题描述
> 
>         （2）一套把问题变换为子问题的操作符
> 
>         （3）一套本原问题描述

**3、问题规约的实质**：

>         从目标(要解决的问题)出发**逆向推理**，建立子问题以及子问题的子问题，直至最后把初始问题归约为一个平凡的**本原问题**(**可直接求解的问题**)集合。

### 2.2.1 问题归约描述

####     1、梵塔难题

![](https://i-blog.csdnimg.cn/blog_migrate/b74309e66f9423b72669c074d8ecfc9f.png)

**（1）问题表示**-梵塔难题（n阶）

>                 _与状态空间法不同，不能仅表示状态，需要表示目前的问题_

假设用向量（Dn, Dn-1, …, D1）表示从大到小的圆盘所在的柱子号，则：

**初始状态**：（1，1，…，1）；

**目标状态**（3，3，…，3）；

**初始问题**则为要将初始状态改变为目标状态：

(1, 1, …, 1){\color{Red} }\Rightarrow{\color{Red} }\Rightarrow(3, 3, …, 3)        

**（2）解题过程**

①将原始梵塔难题(三阶)(111){\color{Red} }\Rightarrow{\color{Red} }\Rightarrow(333) 归约（简化）为以下**子难题**：

移动圆盘A和B至柱子2的**双圆盘**难题，（111）{\color{Red} }\Rightarrow{\color{Red} }\Rightarrow（122）

移动圆盘C至柱子3的**单圆盘**难题，（122）{\color{Red} }\Rightarrow{\color{Red} }\Rightarrow（322）

移动圆盘A和B至柱子3的**双圆盘**难题，（322）{\color{Red} }\Rightarrow{\color{Red} }\Rightarrow（333）

如图所示：

![](https://i-blog.csdnimg.cn/blog_migrate/26f5d4700b2e25e544f4e448858f9636.png)

![](https://i-blog.csdnimg.cn/blog_migrate/d0136fc6dafeb89ebffa942503fdc568.png)

![](https://i-blog.csdnimg.cn/blog_migrate/63bb0b16fa52516ac2592027502c759d.png)

② 然后再分析归约两个双圆盘难题的移动方式。 

（111）{\color{Red} }\Rightarrow{\color{Red} }\Rightarrow（122）可分解为  (111){\color{Red} }\Rightarrow{\color{Red} }\Rightarrow(113)   (113){\color{Red} }\Rightarrow{\color{Red} }\Rightarrow(123)  （123）{\color{Red} }\Rightarrow{\color{Red} }\Rightarrow（122）

同理再分析圆盘A、B移动到柱子3的双圆盘问题的移动方式，这里就省略啦。

**（3）梵塔问题归约图**

![](https://i-blog.csdnimg.cn/blog_migrate/dec1b7d47755fc9f87461d4410078e0c.png)

### 2.2.2 与或图表示

####     1、相关概念

**与图、或图、与或图**：用一个似图结构来表示把问题归约为后继问题的替换集合，这一似图结构叫做问题归约图，或叫与或图。

![](https://i-blog.csdnimg.cn/blog_migrate/2e3daba5abeccb466c5e8d2268975862.png)

**父节点、子节点、与阶段、或节点、终叶节点、弧线**

![](https://i-blog.csdnimg.cn/blog_migrate/4a6fbba7e7ef474b26b6a388087c3ea4.png)

**可解节点**的一般定义可归纳为： 

>                 终叶节点是可解节点(因为它们与本原问题相关连)
> 
>                 如果某个非终叶节点含有或后继节点，那么只要有一个后继节点是可解的时，此非终叶节点就是可解的
> 
>                 如果某个非终叶节点含有与后继节点，那么只有其全部后继节点为可解时，此非终叶节点才是可解的

**不可解节点**的一般定义可归纳为：

>                 没有后裔的非终叶节点为不可解节点
> 
>                 如果某个非终叶节点含有或后继节点，那么只有当其全部后裔为不可解时，此非终叶节点才是不可解的
> 
>                 如果某个非终叶节点含有与后继节点，那么只要当其后裔有一个为不可解时，此非终叶节点就是不可解的

####     **2、与或图构成规则**

        每个节点对应一个问题或一个问题集合

        终叶节点对应一个本原问题

        通过算子将问题转化为子问题集合

        通过连接线将同一个子问题的“与”节点连接起来

## 2.3 谓词逻辑表示

   **谓词**：原子命题中刻画个体的性质或个体间关系的成分

**谓词逻辑**：一种形式语言，能够表达人类思维活动规律的一种最精确的语言，接近自然语言，又方便存入计算机处理，适合于表示事物的状态、属性、概念等，也可用来表示事物间确定的因果关系。   

### 2.3.1 谓词演算

####     1、语法和语义

**谓词逻辑的基本组成部分**：谓词符号、变量符号、函数符号、常量符号，并用圆括号、方括号、花括号、逗号隔开，函数符号表示论域内的关系。

>         eg: “机器人在1号房间里” 可应用简单的原子公式：INROOM(ROBOT,r1)；
> 
>                 INROOM是谓词符号，  ROBOT、r1是常量符号
> 
>         eg: “Mary的父亲和母亲结婚了” ： MARRIED(father(Mary), mother(Mary));
> 
>                 father、mother是函数符号，Mary 是常量符号， MARRIED 是谓词符号

####     **2、连词和量词**

|   |   |   |   |
|---|---|---|---|
||含义|连接公式名字|举例|
|![\wedge](https://latex.csdn.net/eq?%5Cwedge)|“与”，表示复合句子|合取（式）|我喜欢音乐和绘画：<br><br>LIKE(I，MUSIC)![\wedge](https://latex.csdn.net/eq?%5Cwedge)LIKE(I，ART)|
|![\vee](https://latex.csdn.net/eq?%5Cvee)|“或”，表示可兼有|析取（式）|李明打篮球或踢足球：<br><br>PLAYS（LIMING,BASKETBALL）![\vee](https://latex.csdn.net/eq?%5Cvee)PLAYS(LIMING,FOOTBALL)|
|→|“如果-那么”|蕴含|如果李明跑得最快，那么他取得冠军：<br><br>RUNS（LIMING, FASTEST）→ WINS(LIMING,CHAMPION)|
|~|“非”|否定|机器人不在2号房间:<br><br>~INROOM(ROBOT,r2)|
|![\forall](https://latex.csdn.net/eq?%5Cforall)x|全称量词||所有的机器人都是灰色的：<br><br>(![\forall](https://latex.csdn.net/eq?%5Cforall)x)(ROBOT(x)→COLOR(x,GRAY))|
|![\exists](https://latex.csdn.net/eq?%5Cexists)x|存在量词||1号房间内有物体：<br><br>(![\exists](https://latex.csdn.net/eq?%5Cexists)x)INROOM(x, r1)|

### 2.3.2 谓词公式

####     1、相关概念
**原子谓词公式**：用_P_(_x_1，_x_2，…，_x__n_)表示一个_n_元谓词公式，其中_P_为_n_元谓词，_x_1，_x_2，…，_x__n_为客体变量或变元。通常把_P_(_x_1，_x_2，…，_x__n_)叫做谓词演算的原子公式，或原子谓词公式。

**分子谓词公式**：可用连词把原子谓词公式组成复合谓词公式，并把它叫做分子谓词公式。

**合式公式**：应用连词∧(与)、∨(或)以及=> (蕴涵，或隐含)等，可组合多个原子公式以构成比较复杂的合式公式。        

**合式公式的递归定义**：

> (1) 原子谓词公式是合式公式。
> 
> (2) 若_A_为合式公式，则～_A_也是一个合式公式。
>
> (3) 若_A_和_B_都是合式公式，则(_A_∧_B_)，(_A_∨_B_)，(_A_→_B_)和(_A_←→_B_)也都是合式公式。
>
>  (4) 若A是合式公式，x为A中的自由变元，则("_x_)A，($_x_)A都是合式公式。
>
>  (5) 只有按上述规则(1)至(4)求得的那些公式，才是合式公式。

####     2、谓词公式的性质

**真值表**：

​![](https://i-blog.csdnimg.cn/blog_migrate/b197bac6101f3d2a81bb50f7d6b57e73.png)

> （1）否定之否定  ~(~P) ≡ P
> 
>                   P∨Q ≡~P→Q
> 
> （2）摩根律    ~(P∧Q) ≡~P∨~Q
> 
>                   ~(P∨Q) ≡~P∧~Q
> 
> （3）分配律  P∧(Q∨R) ≡ (P∧Q)∨(P∧R)
> 
>                 P∨(Q∧R) ≡ (P∨Q)∧(P∨R)
> 
> （4）交换律    P∧Q ≡ Q∧P
> 
>                   P∨Q ≡ Q∨P
> 
> （5）结合律    (P∧Q)∧R ≡ P∧(Q∧R)
> 
>                   (P∨Q)∨R ≡ P∨(Q∨R)
> 
> （6）逆反律      P→Q ≡ ~Q→~P     
> 
> （7）还有其他的一些等价关系：
> 
>          ​​​​​​​        ​​​​​​​         ​![](https://i-blog.csdnimg.cn/blog_migrate/b77b118ab64bf6c7f3da50917faa4f97.png)

**3****、谓词公式的举例**

man(smith)： smith是人

between（albert, susan, david）: albert 在susan和david之间

( x)(man(x)→mortal(x))：人都会死

( x)(man(x)∧clever(x))： 有的人聪明 

### **2.3.3** **置换与合一**

**置换**：假元推理：由合式公式W1和W1→W2产生合式公式W2的运算。

全称化推理：由合式公式("x)W(x)产生合式公式W(A)，其中A为任意符号常量。

>         示例：
> 
>         ​​​​​​​    ![](https://i-blog.csdnimg.cn/blog_migrate/a9e90c4d44307e7215013611eaac55ed.png)

**合一**：寻找项对变量的置换，以使两表达式一致，叫做合一。

**合一者**：如果一个置换s作用于表达式集｛Ei｝的每个元素，则用{Ei}s来表示置换后的集。称表达式集｛Ei｝是可合一的。如果存在一个置换s使得：

                                                 E1s=E2s=E3s=…

则称此s为｛Ei｝的合一者，因为s的作用是使集合｛Ei｝成为单一形式

>         例如：置换s ： x=A, y=B  ，来置换表达式
> 
> ![](https://i-blog.csdnimg.cn/blog_migrate/bb11f5ee843f689f1847bdc9e69a4d18.png)

## **2.4** **语义网络表示**

	引言：前面的谓词逻辑作为本章内容的基础，本章与前一章节有相似之处但是也有不同之处

**相同**：

**不同**：谓词逻辑的最小单元是二元谓词逻辑，但语义网络却不是，语义网络的最小单元不定的



---


**语义网络的结构4个相关组成部分**：

（1）词法部分：词汇表中允许有哪些符号，它涉及各个节点和弧

（2）结构部分：叙述符号排列的约束条件，指定各弧线连接的节点对

（3）过程部分：访问过程，这些过程能用来建立和修正描述，以及回答相关问题

（4）语义：确定有关节点的排列及其占有物和对应弧线

###  **2.4.1** **二元语义网络的表示**

表示占有关系和其他情况，例如：小燕是一只燕子，燕子是鸟，巢-1是小燕的巢，巢-1是巢中的一个：

![](https://i-blog.csdnimg.cn/blog_migrate/99dc904df562e715a511f586fd2b8df5.png)

> 表示事物的性质、属性：
> 
>         ISA（Is-A）、AKO（A-Kind-Of）、HAVE、AMO（A-Member-Of）
> 
> 构成关系：
> 
>         Composed-of
> 
> 时间关系：
> 
>         Before、After、At
> 
> 位置关系：
> 
>         Located-on、Located-at、Located-under
> 
> 相似或接近关系：
> 
>         Similar-to、Near-to

### **2.4.2** **多元语义网络的表示**

- **谓词逻辑与语义网络等效**

![](https://i-blog.csdnimg.cn/blog_migrate/4d9801441da4305d67298c347ac68f95.png)

         多元语义网络表示的实质：把多元关系转化为一组二元关系的组合，或二元关系的合取。

![](https://i-blog.csdnimg.cn/blog_migrate/ad688a31448a600ae476029ccdc9c6fb.png)






## 2.4.3 语义网络的推理过程

**1、相关概念**

**节点、弧、链→槽**

> ​        **​​​​例如**：有一张木头做的方桌：
> 
>         （1）以个体为中心：
> 
>         ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/8e929a6e9420aa5c4d2679c5e6877345.png)
> 
>          （2）以谓词或关系为中心：
> 
>         ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/732f6dd5272db5a6b83dd97280b469b1.png)

**2、两种推理机制：匹配、继承**

**匹配**：构造目标网络块，在事实网络中寻找匹配

**继承**：把事务的描述从概念节点或类节点传递到实例节点

**三类继承性**：

直接传递(pass)──子节点直接继承父节点的属性

附加传递(add)──子节点把父节点的属性和自己的属性相综合
排斥传递(exclude)──子节点与父节点的属性不相容，抑止传递

**三种继承方式：**

值继承——ISA, AKO

Default（默认继承）——具有相当程度的真实性但不能十分肯定的值，例如：鸟会飞。

 if-needed（“如果需要继承”，“附加过程”继承）：某些情况下，对事物的描述不能直接从概念节点或类节点继承得到，但可利用已知信息来计算

![](https://i-blog.csdnimg.cn/blog_migrate/1cdfdfc2709b835a66b7bfa55a0db9e9.png)

 ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/1111cdb52775263c83a44198d5a9afb4.png)

### **2.4.4 语义网络表示的特点与不足**

**特点：**

>         **具有结构性**：适于表示分类型知识和事物特性的知识
> 
>         **灵活性**：可以任意定义新的节点与弧
> 
>         **继承性**
> 
>         **表达能力强**

**不足：**

>         语义网络上的继承推理具有非单调性
> 
>         处理上的复杂性
> 
>         非严格性
> 
>         多重继承冲突问题是重要的研究课题

### 2.4.5 知识表示方法间的关系

![](https://i-blog.csdnimg.cn/blog_migrate/74d5e4243b0738fa36cccd8a76a87a00.png)
![](https://i-blog.csdnimg.cn/blog_migrate/21757edbe84c20ab2e0efa0f6b3040de.png)

## 2.5 产生式表示


## 2.6 [框架](https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&spm=1001.2101.3001.7020)表示

### 2.6.1 框架的构成       

- **定义**：**框架描述一类物体**，由框架名与一些描述物体各个方面的槽(slot)组成

- **特点**：每个槽可分为多个侧面(facet)；每个侧面可有一个或多个值

> <框架名>
> 
>           <槽名1>:  <侧面11>(值111, 值112, ...)
> 
>                            <侧面12>(值121, 值122, ...)
> 
>           <槽名2>:   <侧面21>(值211, 值212, ...)
> 
>                            <侧面22>(值221, 值222, ...)
> 
>                         ...
> 
>           约束：  约束条件1，约束条件2…

**例**：描述“大学教师的框架”：

> **<大学教师>**
> 
>   **类属：****<**教师**>
> 
>   **学位：（学士，硕士，博士）**
> 
>   **专业：****<**学科专业**>
> 
>   **职称：（助教，讲师，副教授，教授）**
> 
>   **外语：** **语种：（英，法，日，俄，德，****…****）**
> 
>             ​​​​​​​  **缺省：英**
> 
>   **水平：** **评价：（优，良，中，差）**
> 
>                                    **缺省：良**

四种侧面填写方式：属性、默认隐含、继承、执行附加过程

### 2.6.2 框架的推理

**两种推理活动**：**匹配**、**填槽**

匹配：将待解决的问题用框架表示

匹配通过对应槽的槽名和值逐个比较实现

填槽：中间结果或用户输入、默认、继承、附加过程计算

### 2.6.3 框架表示的特点与不足

特点：结构性、继承性、自然性、模块性

不足：没有形成完整的理论体系
	   缺乏清晰的语义
	   多重继承的冲突


### 2.6.4 应用框架描述

- 例子一：描述静磁场




- 例子二：描述静电场






```ad-note
title:思考

- 框架描述法则在纯自然科学领域的应用范围很广，因为自然科学往往研究的是事物的性质，他们之间构成一个类似集合一样的关系
- 
```




## 2.7 本体技术

### 2.7.1 本体的概念

**（1）本体**是概念化的一个显式的规范说明或表示

共享、概念化、明确性、形式化

本体是从客观世界中抽象出来的一个概念模型，这个模型包含了某个学科领域内的基本术语和术语之间的关系

本体不等同于个体，它是团体的共识，是相应领域内公认的概念集合

### 2.7.2 本体的组成与分类

**本体的组成**：概念、关系、函数、公理、实例

**本体中类（概念）之间的四种基本关系**：

局部与整体的关系

父类与子类的关系

在类中填充实例，类与实例之间的关系

类的属性，有对象属性和数据属性

**本体的分类：**

>           **①根据本体****应用主题****，将本体划分为五种类型：****领域本体****、****通用或常识本体****、****知识本体****、****语言学本体****和****任务本体**
> 
>           **②****依据本体的****层次和领域依赖度****，****Guarino****等人将其分为四类：**
> 
>               顶层本体：研究通用的概念以及概念之间的关系，如空间、时间、事件、行为等，与具体的应用无关，完全独立于限定的领域，因此可以在较大范围内进行共享。
> 
>               领域本体：研究的是特定领域内概念及概念之间的关系。
> 
>               任务本体：定义一些通用任务或者相关的推理活动，用来表达具体任务内的概念及概念之间关系。
> 
>                应用本体：用来描述一些特定的应用，既可以引用领域本体中特定的概念，又可以引用任务本体中出现的概念。

## 2.8 过程表示

过程表示法：把问题求解的总目标划分为一个个过程(Procedure)目标，再结合知识利用环节确定为若干操作步骤，表示为一个个过程。**每一个过程就是一段程序**，用于完成对一个具体事件或情况的处理。

问题的求解与推理，就转换成为一个又一个过程的程序组织与调用了

  八数码难题的求解过程状态：![](https://i-blog.csdnimg.cn/blog_migrate/a33b2d5a4ae0e7feb53fd53a310c7e32.png)

**特点与不足：****目标明确，易于实现，效率较高，但维护性有待提高**


## 2.9 图谱表示

### 2.9.1 概述

知识图谱，作为人工智能和语义网技术的重要组成部分，其核心在于将现实世界的对象和概念以及它们之间的多种关系以图形的方式组织起来。它不仅仅是一种数据结构，更是一种知识的表达和存储方式，能够为机器学习提供丰富、结构化的背景知识，从而提升算法的理解和推理能力。

在人工智能领域，知识图谱的重要性不言而喻。它提供了一种机器可读的知识表达方式，使计算机能够更好地理解和处理复杂的人类语言和现实世界的关系。通过构建知识图谱，人工智能系统可以更有效地进行知识的整合、推理和查询，从而在众多应用领域发挥重要作用。

具体到应用场景，知识图谱被广泛应用于搜索引擎优化、智能问答系统、推荐系统、自然语言处理等领域。例如，在搜索引擎中，通过知识图谱可以更精确地理解用户的查询意图和上下文，提供更相关和丰富的搜索结果。在智能问答系统中，知识图谱使得机器能够理解和回答更复杂的问题，实现更准确的信息检索和知识发现。

此外，知识图谱还在医疗健康、金融分析、风险管理等领域展现出巨大潜力。在医疗领域，利用知识图谱可以整合和分析大量的医疗数据，为疾病诊断和药物研发提供支持。在金融领域，则可以通过知识图谱对市场趋势、风险因素进行更深入的分析和预测。

总的来说，知识图谱作为连接数据、知识和智能的桥梁，其在人工智能的各个领域都扮演着至关重要的角色。随着技术的不断进步和应用领域的拓展，知识图谱将在智能化社会中发挥越来越重要的作用。

### 2.9.2 基础理论

![file](https://segmentfault.com/img/bVdbiNj "file")

【定义与分类】

知识图谱是一种通过图形结构表达知识的方法，它通过节点（实体）和边（关系）来表示和存储现实世界中的各种对象及其相互联系。这些实体和关系构成了一个复杂的网络，使得知识的存储不再是孤立的，而是相互关联和支持的。

知识图谱根据其内容和应用领域可以分为多种类型。例如，通用知识图谱旨在覆盖广泛的领域知识，如Google的Knowledge Graph；而领域知识图谱则专注于特定领域，如医疗、金融等。此外，根据构建方法的不同，知识图谱还可以分为基于规则的、基于统计的和混合型知识图谱。

【核心组成】

知识图谱的核心组成元素包括实体、关系和属性。实体是知识图谱中的基本单位，代表现实世界中的对象，如人、地点、组织等。关系则描述了实体之间的各种联系，例如“属于”、“位于”等。属性是对实体的具体描述，如年龄、位置等。这些元素共同构成了知识图谱的骨架，使得知识的组织和检索变得更加高效和精确。

【历史与发展】

知识图谱的概念最早可以追溯到语义网和链接数据的概念。早期的语义网关注于如何使网络上的数据更加机器可读，而链接数据则强调了数据之间的关联。知识图谱的出现是对这些理念的进一步发展和实践应用，它通过更加高效的数据结构和技术，使得知识的表示、存储和检索更加高效和智能。

随着人工智能和大数据技术的发展，知识图谱在自然语言处理、机器学习等领域得到了广泛应用。例如，知识图谱在提升搜索引擎的智能化、优化推荐系统的准确性等方面发挥了重要作用。此外，随着技术的不断进步，知识图谱的构建和应用也在不断地演变和优化，包括利用深度学习技术进行知识提取和图谱构建，以及在更多领域的应用拓展。

### 2.9.3 知识获取与预处理

![file](https://segmentfault.com/img/bVdbiNk "file")

【数据源选择】

知识图谱构建的首要步骤是确定和获取数据源。数据源的选择直接影响知识图谱的质量和应用范围。通常，数据源可以分为两大类：公开数据集和私有数据。公开数据集，如Wikipedia、Freebase、DBpedia等，提供了丰富的通用知识，适用于构建通用知识图谱。而私有数据，如企业内部数据库、专业期刊等，则更适用于构建特定领域的知识图谱。

选择数据源时，应考虑数据的可靠性、相关性、完整性和更新频率。可靠性保证了数据的准确性，相关性和完整性直接影响知识图谱的应用价值，而更新频率则关系到知识图谱的时效性。在实践中，通常需要结合多个数据源，以获取更全面和深入的知识覆盖。

【数据清洗】

获取数据后，下一步是数据清洗。这一过程涉及从原始数据中移除错误、重复或不完整的信息。数据清洗的方法包括去噪声、数据规范化、缺失值处理等。去噪声是移除数据集中的错误和无关数据，例如，去除格式错误的记录或非相关领域的信息。数据规范化涉及将数据转换为一致的格式，如统一日期格式、货币单位等。对于缺失值，可以采用插值、预测或删除不完整记录的方法处理。

数据清洗不仅提高了数据的质量，还能增强后续处理的效率和准确性。因此，这一步骤在知识图谱构建中至关重要。

【实体识别】

实体识别是指从文本中识别出知识图谱中的实体，这是构建知识图谱的核心步骤之一。实体识别通常依赖于自然语言处理（NLP）技术，特别是命名实体识别（NER）。NER技术能够从非结构化的文本中识别出具有特定意义的片段，如人名、地名、机构名等。

实体识别的方法多种多样，包括基于规则的方法、统计模型以及近年来兴起的基于深度学习的方法。基于规则的方法依赖于预定义的规则来识别实体，适用于结构化程度较高的领域。统计模型，如隐马尔可夫模型（HMM）、条件随机场（CRF）等，通过学习样本数据中的统计特征来识别实体。而基于深度学习的方法，如使用长短时记忆网络（LSTM）或BERT等预训练模型，能够更有效地处理语言的复杂性和多样性，提高识别的准确率和鲁棒性。

实体识别不仅需要高准确性，还要考虑到速度和可扩展性，特别是在处理大规模数据集时。因此，选择合适的实体识别技术和优化算法是至关重要的。

### 2.9.4 知识表示方法

![file](https://segmentfault.com/img/bVdbiNl "file")  
知识表示是知识图谱构建中的核心环节，它涉及将现实世界的复杂信息和关系转化为计算机可理解和处理的格式。有效的知识表示不仅有助于提高知识图谱的查询效率，还能加强知识的推理能力，是实现知识图谱功能的关键。

【知识表示模型】

知识表示的首要任务是选择合适的模型。当前主流的知识表示模型包括资源描述框架（RDF）、Web本体语言（OWL）和属性图模型。

- 【RDF】

RDF是一种将信息表示为“主体-谓词-宾语”三元组的模型，它使得知识的表示形式既灵活又标准化。在RDF中，每个实体和关系都被赋予一个唯一的URI（统一资源标识符），以确保其全球唯一性和可互操作性。RDF的优势在于其简单性和扩展性，但它在表达复杂关系和属性方面存在局限。

- 【OWL】

OWL是基于RDF的一种更为复杂和强大的知识表示语言。它支持更丰富的数据类型和关系，包括类、属性、个体等，并能表达复杂的逻辑关系，如等价类、属性限制等。OWL的优势在于其表达能力和逻辑推理能力，适用于构建复杂的领域知识图谱。

- 【 属性图模型】

属性图模型通过图结构来表示知识，其中节点代表实体，边代表关系，节点和边都可以附带属性。这种模型直观且易于实现，适用于大规模的图数据处理。它在图数据库中得到了广泛应用，如Neo4j、ArangoDB等。

【本体构建】

本体是知识图谱中用来描述特定领域知识和概念的一组术语和定义。本体的构建是知识图谱构建的重要部分，它定义了知识图谱中的实体类别、属性和关系类型。

本体构建的关键在于准确地把握和表达领域知识。这通常需要领域专家的参与，以确保本体的准确性和全面性。在实际操作中，可以使用本体编辑工具如Protégé来创建和管理本体，同时结合NLP技术自动化提取和维护本体结构。

【关系提取与表示】

关系提取是指从原始数据中识别出实体之间的关系，并将其加入到知识图谱中。这一步骤通常依赖于文本分析和数据挖掘技术。关系提取的方法包括基于规则的方法、机器学习方法和深度学习方法。

关系的表示要考虑到其多样性和复杂性。在简单的情况下，关系可以被直接表示为实体之间的连接。但在复杂情况下，关系可能涉及多个实体和属性，甚至是关系的层次和类型。在这种情况下，需要更复杂的数据结构和算法来准确表示关系。

### 2.9.5 图谱构建技术

![file](https://segmentfault.com/img/bVdbiNm "file")  
构建知识图谱是一个复杂的过程，涉及数据处理、知识提取、存储管理等多个阶段。本节将详细探讨知识图谱构建的关键技术，并提供具体的代码示例。

【图数据库选择】

选择合适的图数据库是构建知识图谱的首要步骤。图数据库专为处理图形数据而设计，提供高效的节点、边查询和存储能力。常见的图数据库有Neo4j、ArangoDB等。

- 【Neo4j】

Neo4j是一个高性能的NoSQL图形数据库，支持Cypher查询语言，适合于处理复杂的关系数据。它的优势在于强大的关系处理能力和良好的社区支持。

- 【ArangoDB】

ArangoDB是一个多模型数据库，支持文档、键值及图形数据。它在灵活性和扩展性方面表现出色，适用于多种类型的数据存储需求。

【 构建流程】

构建知识图谱的过程大致可分为数据预处理、实体关系识别、图数据库存储和优化几个阶段。

【数据预处理】

数据预处理包括数据清洗、实体识别等步骤，目的是将原始数据转换为适合构建知识图谱的格式。

`import pandas as pd`

# 3. 



本章内容

        掌握图搜索的基本概念

        掌握盲目搜索和启发式搜索的区别

        掌握消解原理的含义及实际问题解决过程

        了解规则演绎系统的基本知识

        了解产生式系统的基本知识

        了解非单调推理的基本知识

## 3.1 图搜索策略

        **图搜索控制策略**：一种在图中寻找路径的方法。

>         图中每个节点对应一个状态，每条连线对应一个操作符。这些节点和连线又分别由产生式系统的数据库和规则来标记。求得把一个数据库变换为另一数据库的规则序列问题就等价于求得**图中的一条路径**问题

        **图搜索过程**：

>          OPEN表（记录还没有扩展的表）
> 
>          CLOSED表（记录已经扩展的点）
> 
>          每个状态的节点结构中必须有指向父节点的指针
> 
>             ![](https://i-blog.csdnimg.cn/blog_migrate/466cf331383fa5f61883be2f9f6acf06.png)

        **评价搜索算法性能的4种途径**：

                完备性、最优性、时间复杂度、空间复杂性

        **图的一般搜索策略：**

                **无信息搜索**（**盲目搜索**）：宽度优先搜索、深度优先搜索

                **有信息搜索**（**启发式搜索**）：A算法、A*算法

## 3.2 盲目搜索

        **分类**：**宽度优先搜索**、**深度优先搜索**、**等代价搜索**

        **特点**：（1）搜索过程中不适用与问题又算的经验信息

                   （2）不需要重排OPEN表

                   （3）搜索效率低

                   （4）不适合大空间的实际问题求解

### 3.2.1 搜索策略的对比

         假设每个状态有 _b_ 个后继，目标节点所在深度为_d：_

|   |   |   |   |   |
|---|---|---|---|---|
||完备性|时间复杂度|空间复杂度|最优性|
|**宽度优先搜索（BFS）**<br><br>逐层扩展|总可以找到解|根节点有_b_个后继，这_b_个节点每个又有_b_个后继，即_b²_<br><br>最坏的情况：扩展除_d_层最后一个节点外的所有节点<br><br>总共扩展操作的次数：![](https://i-blog.csdnimg.cn/blog_migrate/3e14d01349acd8b1ebfb17d4da11f2ca.png)|每个节点都需要存储，共需要：<br><br>![](https://i-blog.csdnimg.cn/blog_migrate/20495bba1b2297cbb07b403557430779.png)|如果每步扩展的代价相同，能找到最优解|
|**深度优先搜索（DFS）**<br><br>往深处扩展|并不总可以找到解，除非搜索空间有界且没有环|搜索树的最大深度为m，最坏的情况：m比_d_大的多<br><br>总共扩展操作的次数：O(![b^{m}](https://latex.csdn.net/eq?b%5E%7Bm%7D))|只需保存从根到叶的单条路径，每个层次上都有(b-1)个未扩展的节点，总的内存需要量为m(b-1)+1。因此深度优先搜索的空间复杂度是b的线性函数O(bm)||
|**迭代加深搜索（IDS）**<br><br>每次改变限制深度，多次调用[深度优先搜索](https://so.csdn.net/so/search?q=%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2&spm=1001.2101.3001.7020)|总可以找到解，如果不存在无限路径|![](https://i-blog.csdnimg.cn/blog_migrate/bd0ed994b36218a1397d43bf23c8c237.png)|与DFS相同，O(bd)|路径代价是节点深度的非递增函数时是最优的|
|**等代价搜索（UCS）**<br><br>沿着等代价路径逐层扩展|总可以找到|![](https://i-blog.csdnimg.cn/blog_migrate/ca0307eee09636b0fcdd250a7662b599.png)|![](https://i-blog.csdnimg.cn/blog_migrate/d88951bb36105ce9f6a608ab35c57dd9.png)|能找到最优解|

### 3.2.2 深度优先搜索-有限[深度](https://so.csdn.net/so/search?q=%E6%B7%B1%E5%BA%A6&spm=1001.2101.3001.7020)+迭代深度

        **优先深度：** 深度搜索的最大深度为_l_，等价于深度为_l_ 的节点没有后继节点，解决了深度优先搜索的无限路径问题。如果 _l< d_ 那么结果不完整，如果 _l > d_ 那么过程不是最优的

        **迭代加深**：每次改变限制深度，多次调用深度有限搜索算法，求最优深度极限 _l_ 的一般策略，结合了DFS与BFS的优点

## 3.3 启发式搜索

        **特点**：重排OPEN表，选择最优希望的节点加以拓展，

        **种类**：有序搜索、A*算法等

### 3.3.1 启发式搜索策略和估价函数

        **启发式信息**：用来加速搜索过程的有关问题领域的特征信息。

        **启发式搜索**：利用启发信息的搜索方法。

        **估价函数**：为获得某些节点“希望”的启发信息，提供一个评定侯选扩展节点的方法，以便确定哪个节点最有可能在通向目标的最佳路径上

>           **f(n)——表示节点n的估价函数值**
> 
>         一个节点的希望程度越大，其f值就越小

### 3.3.2 有序搜索

        三类搜索问题：最优路径，较优路径，一条路径（唯一路径）

####    1、A算法

>         _1964年，尼尔逊提出A1算法，1967年拉斐尔改进了A1算法，称为A2算法_        

        实质：选择OPEN表上具有最小f值的节点作为下一个要扩展的节点

        特征：估价函数 _f_ (_n_) = _g_ (_n_) + _h_ (_n_)

        性能：不完备，不最优

####     2、A*算法

>         _1968年，彼得·哈特对A算法进行了很小的改进，并证明了当估价函数满足一定的限制条件时，算法一定可以找到最优解。_

        **A*算法的限制条件**：_f_ (_x_) = _g_ (_x_) + _h_ (_x_)  **_(g(x)_＞0，_h(x)_不大于x到目标的实际代价_h*(x)_)**

## 3.4 消解原理

          ![](https://i-blog.csdnimg.cn/blog_migrate/fda721b3dd5532c091180a3935667eb6.png) 消解式是亲本子句的逻辑结论

        消解只能在仅含否定和析取联接词的公式（子句）间进行

        必须先把公式化成规范的形式（范式，子句集）

        方法：不断求子句的消解式，直到得到空子句为止

        相关概念

                文字：一个原子公式及其否定

                子句：由文字的析取组成的合式公式

                消解：对谓词演算公式进行分解和花间，消去一些符号，以求得导出子句

### 3.4.1 子句集的求取

        例如：将下列谓词演算公式化为一个子句集

                ![](https://i-blog.csdnimg.cn/blog_migrate/784258a0e36c10fc4ab0f301c509c670.png)

         **1、消去蕴含符号**

>         只应用∨和～符号，以～A∨B替换A→B。
> 
>         ![](https://i-blog.csdnimg.cn/blog_migrate/7a70e7ce0425c1b606281b270e4a01a6.png)

           ![](https://i-blog.csdnimg.cn/blog_migrate/441603dade4b87e7b21b47d52c85007f.png)

        **2、减少否定符号的辖域**

>          将 ~ 内移,每个否定符号～最多只用到一个谓词符号上，并反复应用狄·摩根定律。
> 
>         ![](https://i-blog.csdnimg.cn/blog_migrate/d889387cb4ed7c3f7d67425d1f1a01d1.png)

        ![](https://i-blog.csdnimg.cn/blog_migrate/691cde0c2b105e86cc8fd1ff33f5fec1.png)   

        **3、变量标准化**

>         不同的量词使用不同的变量名，对哑元(虚构变量)改名，以保证每个量词有其自己唯一的哑元

        ![](https://i-blog.csdnimg.cn/blog_migrate/eeb7637781718f25d6cd947c583ec2b5.png)

         **4、去掉存在量词**

>         两种情况：
> 
>         ①“![\exists](https://latex.csdn.net/eq?%5Cexists)” 在某些 “![\forall](https://latex.csdn.net/eq?%5Cforall)”的作用域内，例如：
> 
>                ![](https://i-blog.csdnimg.cn/blog_migrate/833d8fa4390b62ba97e93e9c0a00960d.png)
> 
>          ②“![\exists](https://latex.csdn.net/eq?%5Cexists)” 不在 “![\forall](https://latex.csdn.net/eq?%5Cforall)”的作用域内，直接去掉存在量词，将对应的变量写成一个常量表达式
> 
>                 ![](https://i-blog.csdnimg.cn/blog_migrate/9ed2f1fe7d64dd2624a60d39de15ba2e.png)

       ![](https://i-blog.csdnimg.cn/blog_migrate/303d6a46ec171229e98934bbd22b5942.png)

        **5、化为前束形**

>         将所有的“![\forall](https://latex.csdn.net/eq?%5Cforall)” 移到公式的最前面,并使每个量词的辖域包括这个量词后面公式的整个部分
> 
>         ![](https://i-blog.csdnimg.cn/blog_migrate/3df04b159b7450fe37536c47d34c2494.png)

        ![](https://i-blog.csdnimg.cn/blog_migrate/cb19d5adcd98dfae0d51ed5888209bc9.png)

         **6、把母式写成合取范式的形式**

>         任何母式都可写成由一些谓词公式和(或)谓词公式的否定的析取的有限集组成的合取。

        ![](https://i-blog.csdnimg.cn/blog_migrate/8f6a4e51481215d6baba33f806ff84b6.png)

         **7、去掉全称量词**

>         所有余下的量词均被全称量词量化了。消去前缀，即消去明显出现的全称量词。

        ![](https://i-blog.csdnimg.cn/blog_migrate/67b026af939473f5b01883417b64dd86.png)

         **8、消去合取词 ∧**

>         用{A,B}代替(A∧B)，消去符号∧。最后得到一个有限集，其中每个公式是文字的析取

        ![](https://i-blog.csdnimg.cn/blog_migrate/ef85df5722576fb5a29df171003b1e0d.png)

         **9、更换变量名称**

>         使相同的变元不会出现在不同的子句中

        ![](https://i-blog.csdnimg.cn/blog_migrate/fef6293b7d9091b8def01561af5c2490.png)

###  3.4.2 消解推理规则

        **命题逻辑的消解**：设有 {λ} ∨ C1 和 {Ø λ} ∨ C2, 其中 C1 , C2 是子句，λ 是原子, 则可推出C12 =C1 ∨ C2 , C12称为C1 , C2的_resolvent_(消解式，归结式), 这个过程称为消解_resolution。_

        **谓词逻辑的消解**：假设 C1 和C2 是子句, 如果C1中有文字L1，C2中有文字L2 ，且L1 与 Ø L2 有最一般合一者σ，则这两个子句有消解式 C12： C12=(C1σ - {L1σ})∪(C2σ - {L2σ})

        **消解式的定义**：令L1，L2为两任意原子公式；L1和L2具有相同的谓词符号，但一般具有不同的变量。已知两子句L1∨α和～L2∨β,如果L1和L2具有最一般合一σ，那么通过消解可以从这两个父辈子句推导出一个新子句(α∨β)σ。这个新子句叫做消解式。

        **消解式的例子**：

        （1）假言推理

        （2）合并

        （3）重言式

        （4）空子句（矛盾）

        （5）链式（三段论）

### 3.4.3 含有变量的消解式

        要把消解推理规则推广到含有变量的子句，必须找到一个作用于亲本子句的置换，使亲本子句含有互补文字。

        当子句之间可以找到一个项对变量的置换使其变成相同的形式时，就称这些子句是可合一的。

        **例如**：

        ![](https://i-blog.csdnimg.cn/blog_migrate/598f51c76f88f1f3609cdb3c54c033a9.png)

         注意： 所有的 父辈都要进行置换

        **置换的目的**：使用置换使得原子公式能够变得一致

        **置换的复合**：

                _S_ = {_u_1/_s_1,..,_u__m_/_sm}  T_ = {_t_1/_v_1,...,_t__n_/_v__n}_

                他们的复合仍是一个置换，**_ST_** **=** **{****_u_****1****_T_** **/****_s_****1****,..,****_u_****_m_****_T_** **/****_s_****_m_** **,** **_t_****1****/****_v_****1****,...,****_t_****_n_****/****_v_****_n}_**

                置换的复合运算时做结合的，不满足交换律

>         例如：
> 
>                 ![](https://i-blog.csdnimg.cn/blog_migrate/4382f019c970cbec0a0b5d61ab4d04ca.png)

        **合一**：寻找项对变量的置换，以使两表达式一致的过程。合一者不唯一

>         例如：
> 
>         ![](https://i-blog.csdnimg.cn/blog_migrate/9d61a2eea675b24725370f7845d7af34.png)

        **最一般合一者**：给定公式集_S_, 设_S_的最一般合一者为_θ_, 则对_S_的所有其他合一者![\varphi](https://latex.csdn.net/eq?%5Cvarphi) , 都存在一个置换![\sigma](https://latex.csdn.net/eq?%5Csigma) 使得![](https://i-blog.csdnimg.cn/blog_migrate/d537cb617e8c23ba5f452cae5b316c52.png)

### 3.4.4 消解反演求解过程

    **1、采用消解反演从已知条件集合S证明结论G的步骤**

        ①将 S 化为子句集

        ②将G的否定~G化为子句集

        ③将通过步骤1和2得到的子句合并成一个集合T.

        ④不断进行消解，并将得到的消解式加入T中，直到产生一个空子句NIL为止

    **2、反演求解过程：**

        ①把由**目标公式的否定产生的每个子句添加到目标公式否定之否定的子句**中去。

        ②按照反演树，执行和以前相同的消解，直至在根部得到某个子句止。

        ③用根部的子句作为一个回答语句。

## 3.5 规则演绎系统

        正向规则演绎系统是从事实到目标进行操作的，即从状况条件到动作进行推理的，也就是从if到then的方向进行推理的。

        逆向规则演绎系统是从then向if进行推理的，即从目标或动作向事实或状况条件进行推理的。

        双向规则演绎：此组合系统的总数据库由表示目标和表示事实的两个与或图结构组成。这些与或图结构分别用正向系统的F规则和逆向系统的B规则来修正。

## 3.6 产生式系统

        定义：用来描述若干个不同的以一个基本概念为基础的系统。这个基本概念就是产生式规则或产生式条件和操作对的概念。

        实质：在产生式系统中，论域的知识分为两部分：用事实表示静态知识，如事物、事件和它们之间的关系；用产生式规则表示推理过程和行为。由于这类系统的知识库主要用于存储规则，因此又把此类系统称为基于规则的系统

### 3.6.1 产生式系统的组成

        总数据库、产生式规则、控制策略

### 3.6.2 产生式系统的推理

        ![](https://i-blog.csdnimg.cn/blog_migrate/0ba548d8b100f38539d3662729bfa3a8.png)

         **选择规则到执行操作的步骤**：

                1、匹配：把当前数据库与规则的条件部分相匹配

                2、冲突解决：当有一条以上规则的条件部分和当前数据库相匹配时，就需要决定首先使用哪一条规则，这称为冲突解决。

                3、操作：就是执行规则的操作部分

        **正向推理、逆向推理、双向推理**



## 3.7 非单调推理

        **单调推理**：建立在谓词逻辑基础上的传统系统是单调的，即已知为真的命题数目随时间而严格增加。**因为**：新的命题可加入系统，新的定理可被证明，**but**：这种加入和被证明决不会导致前面已知为真或已被证明的命题变成无效。**缺点**：不能很好处理三类情况：不完全信息、不断变化情况，求解复杂问题过程中产生假设。

        **缺省推理**：当缺乏信息时，只要不出现相反的证据，就可以作一些有益的猜想

        **真值维持系统**：用以协助其它推理程序维持系统的正确性，所以它的作用不是生成新的推理，而是在其它程序所产生的命题之间保持相容性。一旦发现某个不相容，它就调出自己的推理机制，面向从属关系的回溯，并通过修改最小的信念集来**消除不相容**


# 4. 

**目录**

[本章内容](https://blog.csdn.net/qq_46485137/article/details/122196275#t0)

[4.1 经典推理和非经典推理](https://blog.csdn.net/qq_46485137/article/details/122196275#t1)

[4.2 不确定性推理](https://blog.csdn.net/qq_46485137/article/details/122196275#t2)

[4.2.1 不确定性的表示和度量](https://blog.csdn.net/qq_46485137/article/details/122196275#t3)

[4.2.2 不确定性的算法](https://blog.csdn.net/qq_46485137/article/details/122196275#t4)

[4.3 概率推理](https://blog.csdn.net/qq_46485137/article/details/122196275#t5)

[4.3.1 概率的基本性质和计算公式](https://blog.csdn.net/qq_46485137/article/details/122196275#t6)

[4.4 主观贝叶斯方法](https://blog.csdn.net/qq_46485137/article/details/122196275#t7)

[4.4.1 知识不确定性的表示](https://blog.csdn.net/qq_46485137/article/details/122196275#t8)

[4.4.2 证据不确定性的表示](https://blog.csdn.net/qq_46485137/article/details/122196275#t9)

 [4.4.3 主观贝叶斯方法的推理过程](https://blog.csdn.net/qq_46485137/article/details/122196275#t10)

[4.5  可信度方法](https://blog.csdn.net/qq_46485137/article/details/122196275#t11)

[4.5.1 基于可信度的不确定性表示](https://blog.csdn.net/qq_46485137/article/details/122196275#t12)

[4.5.2 可信度方法的推理算法](https://blog.csdn.net/qq_46485137/article/details/122196275#t13)

[重要公式总结：](https://blog.csdn.net/qq_46485137/article/details/122196275#t14)

---

本章内容

熟悉经典推理和非经典推理的区别

掌握不确定推理的基本概念

掌握概率推理方法

掌握主观[贝叶斯](https://so.csdn.net/so/search?q=%E8%B4%9D%E5%8F%B6%E6%96%AF&spm=1001.2101.3001.7020)推理方法

掌握可信度推理方法

了解证据理论的基本知识

## 4.1 经典推理和非经典推理

       **非经典推理和经典推理的区别表现在：**

>         **推理方法**。经典采用演绎逻辑推理，非经典采用归纳逻辑推理。 
> 
>         **辖域取值**。经典逻辑都是二值逻辑，非经典是多值逻辑。
> 
>         **运算法则**。经典逻辑中的许多法则在非经典逻辑中不成立。
> 
>         **逻辑算符**。非经典逻辑具有更多的逻辑算符。
> 
>         **是否单调**。经典逻辑单调，而非经典逻辑是非单调逻辑。

## 4.2 不确定性推理

        不确定性推理是一种建立在非经典逻辑基础上的基于不确定性知识的推理，从不确定性的初始证据出发，通过运用不确定性知识，推出具有一定程度的不确定性的和合理的或近乎合理的结论。

        不确定性推理中必须解决推理方向、推理方法、控制策略等基本问题，同时还需要解决不确定性的表示与度量、不确定性匹配、不确定性的传递算法以及不确定性的合成等问题。

### 4.2.1 不确定性的表示和度量

    1、**不确定性及其类型：**

        ①随机不确定性，eg: 这场比赛A队可能获胜

        ②模糊不确定性，eg：小明是个高个子

        ③不完全性，eg：刑侦过程的某些阶段往往要针对不完全的证据进行推理

        ④不确定性，eg：人们对太空的认识

    **2、三种不确定性：**

        ①关于知识的不确定性

        ②关于证据的不确定性

        ③关于结论的不确定性

   3、知识的表示与推理密切相关，不同的推理方法要求有相应的知识表示模式与之对应

   4、**知识的度量**

        静态强度：专家系统中通常用一个数值表示相应**知识的不确定性程度**

        动态强度：证据的不确定性也通常用一个数值代表相应**证据的不确定性程度**

### 4.2.2 不确定性的算法

     **1、不确定性的更新算法**：

        （1）已知规则前提即证据E的不确定性C(E)和规则的强度f(H,E),其中H表示假设，求H的不确定性C(H)

        （2）并行规则算法

        （3）证据合取的不确定性算法

        （4）证据析取的不确定性算法

>         证据析取、证据合取的不确定性算法统称为组合证据的不确定性算法

    **2、不确定性的计算与传播：**

        （1）组合证据的不确定性计算（最大最小方法、概率方法、有界方法）

        （2）证据和知识的不确定性的传递

        （3）不同证据支持同一结论时其不确定性的合成

> 不确定性推理的一般模式也可以简单地表示为：
> 
>                 不确定性推理=符号推演+不确定性计算

    **3、不确定性方法的分类：**

        ![](https://i-blog.csdnimg.cn/blog_migrate/09d344b147e0d46883dfb2eb6de63b76.png)

## 4.3 概率推理

### 4.3.1 概率的基本性质和计算公式

    **1、统计概率的性质：**

![](https://i-blog.csdnimg.cn/blog_migrate/59e0aae161eff0a9f69962d95c2383fa.png)

        （6）对任一事件A，有：

                _P(![\overline{A}](https://latex.csdn.net/eq?%5Coverline%7BA%7D)) =1-P(A)_

                _![\overline{A}](https://latex.csdn.net/eq?%5Coverline%7BA%7D)_表示事件A的逆，即事件A和事件A的逆 有且仅有一个发生 

    **2、概率的部分计算公式**

        （1）条件概率与乘法公式：

                P(A|B)=P(A∩B)/P(B)

        （2）独立性公式：

                若事件满足 P(A|B)=P(A)，则称事件A关于事件B是独立的，A与B相互独立的充要条件：

                P(A∩B)= P(A)P(B)

        （3）全概率公式：

                ![](https://i-blog.csdnimg.cn/blog_migrate/1fd20eb50ed361175821e39857b33de0.png)

         （4）贝叶斯公式：

                ![](https://i-blog.csdnimg.cn/blog_migrate/db44e6c9ddc34d36bfc3ad7c11b1a05d.png)

## 4.4 主观贝叶斯方法

        核心思想：

                根据 **先验概率** （H出现的概率 P(Hi) ）以及证据E的 **条件概率** (Hi出现的情况下E出现的概率 P(E | Hi)) 得到**后验概率**（出现E的情况下出现Hi的概率）

        例如：

>        小明去上学，坐公交车迟到的概率是30%，步行迟到的概率是20%，假设选择每种公交车的可能性相同，问小明迟到了，坐公交车的可能性是多少？

### 4.4.1 知识不确定性的表示

        1、主观贝叶斯方法用**产生式规则表示知识**：

                _**if E then (LS, LN) H**_ 

>         (LS,LN) 表示该知识的静态强度
> 
>                 LS为上式成立的**充分性因子**，衡量证据 E 对结论 H 的支持程度
> 
>                         ![](https://i-blog.csdnimg.cn/blog_migrate/dc526b6ef4a324657254d009d1ca1a7d.png)
> 
>                 LN为上式成立的**必要性因子**，衡量     ~E 对 H 的支持程度
> 
>                         ![](https://i-blog.csdnimg.cn/blog_migrate/5300be6eb80a34d91238a66223301621.png)
> 
>                 LS 和 LN 的取值范围是 [0,+∞)，由领域专家给出
> 
>         E 是该条知识的前提条件，它既可以是一个简单条件， 也可以是用and  、or 把多个条件连接起来的复合条件。
> 
>         H 是结论，P(H) 是 H 的**先验概率**，它指出在没有任何专门证据的情况下，结论为真的概率，其值由领域专家根据以往的实践及经验给出

        2、**推理过程**即为根据前提 E 的概率 P(E)，利用规则的 LS 和 LN，把结论 H 的先验概率 P(H) 更新为后验概率 P(H|E) 的过程

        3、在贝叶斯方法中，**引入****概率函数O(x)**，表示事件x发生的概率与不发生的概率之比，把x发生概率的取值从[0,1]放大到[0,+∞）

                               ![](https://i-blog.csdnimg.cn/blog_migrate/299c245430e430243a3572b83d0d8465.png) 

         4、**更新贝叶斯公式**：

                1）对于LS：

                ![](https://i-blog.csdnimg.cn/blog_migrate/75b911f46e9eeb22424cd28f08a1bc60.png)

                        由③式得到 **O(H/E)=LS×O(H)** （该公式被称为Bayes公式的几率似然性形式，LS为充分似然性）

                        由③ 式 及 “非”运算 ：P( ~H/E) = 1 – P(H/E)  、 P( ~H) = 1 – P(H),  得：

                                ![](https://i-blog.csdnimg.cn/blog_migrate/f46baa216c512cb88571cb7ddcc11d46.png)

                 2）对于LN：同理 **O(H/ ~E)=LN×O(H)**

                                ![](https://i-blog.csdnimg.cn/blog_migrate/2a0e4993c5d78bbf369fe51590a9cdb8.png)

       **附  LS和LN的性质**

                -当证据E越是支持H为真时，LS的值越大

                -当证据E对H重要时，则LN值应该越小

### 4.4.2 证据不确定性的表示

        对于初始证据 E ，由用户根据观察 S 给出 P(E/S)，它相当于动态强度

        用**C(E/S)**刻画证据的不确定性。 让用户在 –5 至 5 之间的 11 个整数中选一个数作为初始证据的**可信度C(E/S)**

        初始可信度 C(E/S) 与 概率 P(E/S) 的对应关系如下：

> C(E/S)= -5 ，表示在观察 S 下证据 E 肯定不存在，即 P(E/S)=0；
> 
> C(E/S)= 0 ， 表示 S 与 E 无关，即 P(E/S) =P(E) ；
> 
> C(E/S)= +5 ，表示在观察 S 下证据 E 肯定存在，即 P(E/S)=1；
> 
> C(E/S) = 其它数值时，与 P(E/S) 的对应关系可通过对上述三点进行 **分段线性插值** 得到，如下图。
> 
>   ![](https://i-blog.csdnimg.cn/blog_migrate/9dfae715d0271ce6372669c66a0f8312.png)
> 
>  由上图可得到 C(E/S) 与 P(E/S) 的关系式，即由C(E/S) 计算 P(E/S)：    ​​​​​​​         ![](https://i-blog.csdnimg.cn/blog_migrate/7a59bf27e0752b910af49e28e6017da2.png)

        在证据不确定的情况下，不能再用上面利用LS和LN的公式计算后验概率，而需使用 R.O.Doda 等人1976年证明的如下公式:

        P(H | S) = P(H | E)×P(E | S) + P(┐H | E) × P(┐E | S)        ① 

>          分四种情况讨论：
> 
>         1）P(E/S) = 1
> 
>        当 P(E/S) = 1 时， P(┐E/S) = 0，此时公式 ① 变为：
> 
>                  P(H/S) = P(H/E) = ![](https://i-blog.csdnimg.cn/blog_migrate/50b08ce765a5d1062002dc40c7ad7c26.png)        
> 
>         这是证据肯定存在的情况。
> 
> 2）P(E/S) = 0
> 
>       当 P(E/S) = 0 时， P(┐E/S) = 1，此时公式 ① 变为：
> 
>              P(H/S) = P(H/┐E) = ![](https://i-blog.csdnimg.cn/blog_migrate/0e16c56e3bd8d9e530f0f73353a698db.png)
> 
>               这是证据肯定不存在的情况
> 
> 3）P(E/S) = P(E)
> 
>            当 P(E/S) = P(E) 时，此时公式 ① 变为：
> 
>               ![](https://i-blog.csdnimg.cn/blog_migrate/8096e5956d676cef4cde9ba94019eeb6.png)
> 
>                    表示H与S无关
> 
>         4）当 P(E/S) = 其它值时，通过分段线性插值可得到计算P(H/S)的公式，EH公式
> 
>         ![](https://i-blog.csdnimg.cn/blog_migrate/c72b3207ee6ed0b6b2edd60e5d8325fd.png)

对初始证据，用可信度C(E/S) 计算P(H/S)，该公式为CP公式

        ![](https://i-blog.csdnimg.cn/blog_migrate/37a5cd1acdb2f0951b32d27d2c864366.png)

###  4.4.3 主观贝叶斯方法的推理过程

>         若采用初始证据进行推理，则通过用户得到C(E|S)，从而根据CP公式可求得 P(H|S)
> 
>         若采用推理过程中得到的中间结论作为证据进行推理，则通过 EH 公式可求得 P(H|S)。

**例**：设有如下规则

        r1:   IF  _E_1  THEN  (65, 0.01)  _H_1

        r2:   IF  _E_2  THEN  (300, 0.001)  _H_1

                r3:   IF  _H_1  THEN  (200, 0.002)  _H_2

已知： _P_(_E_1)=0.1 ，_P_(_E_2)=0.03， _P_(_H_1)=0. 1 ，_P_(_H_2)=0.05，用户提供证据：_C_(_E_1/_S_1)=2，_C_(_E_2/_S_2)=1，计算_P_(_H_2/_S_1，_S_2)

> 分析：自下而上计算：
> 
> 根据LS值，将H的先验概率转换为后验概率，计算P(H1/E1)、P(H1/E2)
> 
> 使用CP公式计算P(H1/S1)、P(H1/S2) ，
> 
> 计算O(H1/S1)、O(H1/S2)
> 
> 对H1合成。计算 O(H1/S1,S2)、P(H1/S1,S2) 。
> 
> 根据LS值，将H的先验概率转换为后验概率，计算P(H2/H1)
> 
> 使用EH公式计算_P_(_H_2/_S_1,_S_2)

**（1）计算 P(H1/E1) 、P(H1/S1) 和 O(H1/S1)**

        ![](https://i-blog.csdnimg.cn/blog_migrate/fd898908da9e8912f3b786cf210eccfd.png)

        对于初始证据，使用**CP公式**：

        ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/1a90b95bcab5a99980e8b8ed80aa01ae.png)

        ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/8346db42e0ddfac8775a754097aa9511.png)

         **（2）同理，计算P(H1/E2)、 P(H1/S2)和 O(H1/S2)**

 ​​​​​​​        ​​​​​​​        ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/aaec312f54be3ccc0a179021cd83a67c.png)

        **（3）计算O(H1/S1,S2)和 P(H1/S1,S2)**   

                ![](https://i-blog.csdnimg.cn/blog_migrate/910651aa3b39204cc3c5379582b1b048.png)

        **（4）计算 P(H2/H1)和 P(H2/S1,S2)**

                 使用**EH公式**，∵ P(H1/S1,S2)> P(H1)   ∴ 使用EH公式的后半部。

                        ![](https://i-blog.csdnimg.cn/blog_migrate/c5dc21f20e9868c2e00606fde016d2e6.png)

                 ![](https://i-blog.csdnimg.cn/blog_migrate/495979c732c0b4dff7196cb9973d4860.png)

## 4.5  可信度方法

### 4.5.1 基于可信度的不确定性表示

        推理规则的一般形式：

                **If   E   then    H    (CF(H , E))**  

>          其中 CF(H , E) 是该规则的可信度，称为可信度因子或规则强度。
> 
>         CF(H , E) >0表示该证据增加了结论为真的程度，且CF(H , E)的值越大则结论 H 越真；若CF(H , E) =1，则表示该证据使结论为真。
> 
>         CF(H , E) <0 表示该证据增加了结论为假的程度，且CF(H , E)的值越小则结论 H 越假；若CF(H , E) =-1则表示该证据使结论为假。
> 
>         CF(H , E) =0 表示证据 E 和结论 H 没有关系。

        **CF(H,E)的计算公式**：

        ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/0a401f6ac73607fc01d848ec16641fcd.png)

### 4.5.2 可信度方法的推理算法

       **1、组合证据（前提证据事实总CF值计算，最大最小法）**

         （1）合取证据：多个证据的合取(与)，取最小

         （2）析取证据：多个证据的析取(或)，取最大

        ![](https://i-blog.csdnimg.cn/blog_migrate/97231758f28bb5594c77c5b7fffd01fd.png)        

   **2、推理结论的CF值计算**

        结论 H 的可信度由下式计算：

                CF(H) = CF(H,E) × max { 0, CF(E) } 

  **3、重复结论CF值计算（多个独立证据推出同一假设的合成算法）**

>         if   E1   then    H     (CF(H, E1))
> 
>         if   E2   then    H     (CF(H, E2))
> 
>       （1）计算CF1(H) CF2(H)；
> 
>       （2）计算CF (H)：

        ![](https://i-blog.csdnimg.cn/blog_migrate/e4883017d413b0b7291c85600c0c35e3.png)

 **例： 设有如下规则：**

          r1:   IF  _E_1  THEN  _H_ ( 0.8)

          r2:   IF  _E_2  THEN  _H_ (0.9)

          r3:   IF  _E_3  AND  _E_4    THEN   _E_1    (0.7)

          r4:   IF  _E_5  OR  _E_6     THEN  _E_1   (－0.3)

        并已知初始证据的可信度为：_CF_（_E_2）=0.8，_CF_（_E_3）=0.9，_CF_（_E_4）=0.7，_CF_（_E_5）=0.1，_CF_（_E_6）=0.5，用不确定性理论计算_CF_（_H_）。       

解：

> 由r3可得：     _CF_1（_E_1）=0.7×min{0.9,0.7}=0.49
> 
> 由r4可得：    _CF_2（_E_1）=－0.3×max{0.1,0.5}=－0.15
> 
> 从而              _CF_1,2（_E_1）=（0.49－0.15）/(1－min(|0.49|,|－0.15|))=0.34/0.85=0.4
> 
> 由r1可得：    _CF_1（_H_）=0.4×0.8=0.32
> 
> 由r2可得：    _CF_2（_H_）=0.8×0.9=0.72
> 
> 从而               _CF_1,2（_H_）=0.32+0.72-0.32×0.72=0.8096
> 
> 这就是最终求得的_H_的可信度。

## 重要公式总结：

        **1 全概率公式：**

        ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/c2262b09bb96a7ed71a2bac5ec6ad1f6.png)

        **2 贝叶斯公式：**

        ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/c4ad69051a8e48b593ece5d5299ffa44.png)

3 几率函数计算方法：

        ![](https://i-blog.csdnimg.cn/blog_migrate/4bb20773518795202beae722495f2b70.png)

         4 利用LS、LN将H先验概率更新为后验概率

                ![](https://i-blog.csdnimg.cn/blog_migrate/8b8fcff93cf86eeb6e38715b8270f645.png)

        ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/a3b166767698c1883417ccdfed9a6921.png)

         5 证据不确定的情况下，计算后验概率：

        ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/4316211d42cf1f3f2edf23aed42a95ea.png)

         6、 EH公式：

        ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/e896614f383209d83a0643b468a31020.png)

         7 CP公式：

        ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/05a4ce1087b0eff52455df255f2eff92.png)

         8 组合证据：最大最小法计算前提事实总CF值（and取最小，or取最大）

        ![](https://i-blog.csdnimg.cn/blog_migrate/018b8746b5469f1129375251f368f69a.png)

         9 推理结论的CF值计算

                CF(H) = CF(H,E) ´ max { 0, CF(E) } 

        10 重复结论CF值计算        

        ​​​​​​​        ![](https://i-blog.csdnimg.cn/blog_migrate/34099a3dfda8cf02986fb989a062d49b.png)