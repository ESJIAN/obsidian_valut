
# 一、目的
	背景：DevcppIDE都老掉牙了学校还用，不支持代码补全这就很蛋疼，而且还不能用插件，这就十分难受了。因此寻找一个现代化的开发方式很有必要，初步想法是基于VSCODE因为比较轻量化



# 二、分析

- 定位目的：找到适合VSCODE的一套C、C++开发方案
- 寻找方案
- 整理方案
- 比对方案
- 选择方案

# 三、执行
	引言：就MinGW方案对VSCODE进行安装、配置、测试
## 1. 安装


### （1）MinGW

0. **下载链接**
	- [Mingw下载链接](https://www.onlinedown.net/iopdfbhjl/10045442?module=download&t=website&v=20241205172031)



1. **安装MinGW**
	1. 下载MinGW
	2. 解压（此处我解压到E:\mingw64目录下）
	3. 添加bin目录到系统环境变量(可选，不清楚的跳过这一步，不干扰后续)
	4. 验证MinGW
		- 进入`E:\mingw64\bin`目录，按住右键Shift在此处打开PowellShell窗口
			![1733656456292.png](https://www.helloimg.com/i/2024/12/08/67557e00d46af.png)
		- 在该目录下新建一个main.c文件内容如下
		```c
int main()
{
	int a;
}
		```
		![1733656812005.png](https://www.helloimg.com/i/2024/12/08/67557f6ad70f8.png)
		- 在终端输入`.\gcc.exe main.c`
		 ![1733656870366.png](https://www.helloimg.com/i/2024/12/08/67557f9e8558a.png)
		- 观察有无输出文件(默认输出文件为a.exe)
		![1733656893228.png](https://www.helloimg.com/i/2024/12/08/67557fb636eda.png)

- >至此，你已经完成了MinGW的安装



>**注意**：第四步之所以没有直接在终端输入 gcc -v检查是因为有些Mingw的包是残缺包gcc -v能输出信息，但是一旦执行.\gcc.exe main就报错`gcc.exe: error: CreateProcess: No such file or directory`。而左侧代码只和两个原因有关，一、Mingw有问题，二、路径设置有问题。



### （2）插件

首先，确保你已经在 VSCode 中安装了 C/C++ 和 GDB Debug插件，如果没有安装，可以在 Extensions 视图（左侧四个方块）中搜索 "C/C++" 和“GDB Debug” 并分别进行安装（Install），该插件提供了强大的代码编辑和调试功能。

![](https://i-blog.csdnimg.cn/blog_migrate/81b93c3278bd9299d9a55f366367b77d.png)

![](https://i-blog.csdnimg.cn/blog_migrate/b400e1204fe35e758dc338452622736c.png)





## 2. 配置
### （1）task.json


我们首先来配置`task.json`，新建`task.json`并且粘贴以下内容，只需要改动`cwd`以及`command`项即可，其他的都不需要动。

>**注意**：`launch.json`中有一个`preLaunchTask`，其描述的就是此json下的`label:"C/C++: gcc.exe build active file"`任务，所以得先配置。



- 创建`task.json`








- 复制粘贴内容(批注项是需要改动的)

```
{

    "version": "2.0.0",
    "tasks": [
        {
            "label": "build",
            "type": "shell",
            "command": "${command:eide.project.build}",
            "group": "build",
            "problemMatcher": []
        },
        {
            "label": "flash",
            "type": "shell",
            "command": "${command:eide.project.uploadToDevice}",
            "group": "build",
            "problemMatcher": []
        },
        {
            "label": "build and flash",
            "type": "shell",
            "command": "${command:eide.project.buildAndFlash}",
            "group": "build",
            "problemMatcher": []
        },
        {
            "label": "rebuild",
            "type": "shell",
            "command": "${command:eide.project.rebuild}",
            "group": "build",
            "problemMatcher": []
        },
        {
            "label": "clean",
            "type": "shell",
            "command": "${command:eide.project.clean}",
            "group": "build",
            "problemMatcher": []
        },
        // 此为C/C++: gcc build or gdb debug active file的run的回调命令流
        {
            "type": "cppbuild",
            "label": "C/C++: gcc.exe build active file",
            "command": "E:\\mingw64\\bin\\gcc.exe",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${file}", // 此处替换为"*.c"意味着对该目录下多个c文件编译
                "-o",
                "${fileDirname}\\${fileBasenameNoExtension}.exe"
            ],
            "options": {
                "cwd": "E:\\mingw64\\bin"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "Task generated by Debugger."
        }
    ]
}
```

- 检验配置






>Ps：其实到这里已经结束了。但是我发现不配置`lanuch.json`每次运行都会弹出一个顶部提示窗口提示你选择配置，比较烦人(**识别到编译器时会弹出选项供你选择默认配置文件**)。
>所以我们还是研究一下如何定义自己的默认配置

### （2）launch.json

**注意**：这一步是最容易出错的，主要任务在于实现编译命令流逻辑配置（`task.json`文件），新版VSCODE不再需要配置launch.json，除非你有自己的特殊需要，在配置完task.json后直接按F5选择GCC调试就行了。所以下述第一个launch.json的配置作废。




- 创建launch.json




- 复制粘贴内容(批注项是需要改动的)


```json
// 该配launch.json置实现了先编译后调试的任务流(当代码没有防止断点时不会进入debug流程)

  {

                "name": "C/C++: gcc.exe build active file",                  // 编译调试配置名称
                "type": "cppdbg",                                            // 调试器类型
                "request": "launch",                                         // 配置类型
                "program": "${fileDirname}\\${fileBasenameNoExtension}.exe", // 执行的CLI命令本体
                "args": [],
                "stopAtEntry": false,                                        // 是否在代码中打断点

                "cwd": "E:\\mingw64\\bin",                                   //  执行命令的所在目录
                "environment": [],                                           // 环境变量
                "externalConsole": false,                                    // 是否使用外部控制台
                "MIMode": "gdb",                                             // 调试器类型
                "miDebuggerPath": "E:\\mingw64\\bin\\gdb.exe",               // gdb的安装目录
                "setupCommands": [
                  {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                  },
                  {
                    "description": "Set Disassembly Flavor to Intel",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                   }
                ],
                "preLaunchTask": "C/C++: gcc.exe build active file"
              },
```


- 检验内容

~~然后我们来配置`task.json`,前面`launch.json`是调试用的配置逻辑， `preLaunchTask": "C/C++: gcc.exe build active file`项表面在调试逻辑开始先前执行preLaunchTask任务，而该任务具体的命令流需要在`task.json`中去配置~~






**问题集锦**：



## 3. 测试


1. **前言**：很多人搞不清楚以下两个按钮的区别，下面我来稍微解释解释

![1733645760884.png](https://www.helloimg.com/i/2024/12/08/67555439cea29.png)
					图：编译调试的两个主要组件

在Visual Studio Code (VSCode) 中，"Run Debug File" 和 "Start Debugging" 是两种不同的调试启动方式，它们的主要区别在于它们如何与调试配置交互以及它们在调试过程中的作用。以下是它们的主要区别：

1. **"Start Debugging"**:
    
    - 这是标准的调试启动方式，当你点击工具栏上的“绿色虫子”图标或者使用快捷键（通常是F5）时，会触发"Start Debugging"。
    - "Start Debugging" 会根据当前选中的调试配置（在调试视图的下拉菜单中选择）来启动调试会话。
    - 它允许你设置断点、查看变量、单步执行代码等标准的调试操作。
    - 如果在调试配置中设置了`preLaunchTask`，那么在启动调试会话之前，这个任务会被执行。
2. **"Run Debug File"**:
    
    - "Run Debug File" 是一个快捷方式，它允许你快速运行当前打开的文件作为一个独立的程序，而不需要事先配置一个完整的调试配置。
    - 这个命令通常用于快速测试小段代码或者脚本，而不需要设置复杂的调试环境。
    - 它不会使用`launch.json`中的配置，也不会执行`preLaunchTask`。
    - "Run Debug File" 通常对应于在终端中直接运行一个程序，但它会附加调试器以便进行调试。

>**总结**：右侧使用的是默认配置，左侧使用的是自定义配置；默认配置如果识别到对应编译器会自动调用，手动配置得自己创建


2. **测试**
	- **Run Debug File按钮功能测试**
		![1733659996593.png](https://www.helloimg.com/i/2024/12/08/67558bf6a4832.png)
	- **Start Debugging按钮功能测试**
		![1733660088973.png](https://www.helloimg.com/i/2024/12/08/67558c5465e1b.png)






---


>作为附加研究项，接下来我们还是研究下怎么搞好`lanuch.json`，防止每次编译调试都弹出弹窗

3. **可选**
	- **参考教程**
		[VS Code之C/C++程序的调试(Debug)功能简介 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/85273055)
		[VS Code 配置 C/C++ 编程运行环境（保姆级教程）_visual studio code c++配置-CSDN博客](https://blog.csdn.net/qq_42417071/article/details/137438374)
	- **新建文件**：新建`launch.json`文件
	```json
// 该配launch.json置实现了先编译后调试的任务流(当代码没有防止断点时不会进入debug流程)

  {

                "name": "C/C++: gcc.exe build active file",                  // 编译调试配置名称
                "type": "cppdbg",                                            // 调试器类型
                "request": "launch",                                         // 配置类型
                "program": "${fileDirname}\\${fileBasenameNoExtension}.exe", // 执行的CLI命令本体
                "args": [],
                "stopAtEntry": false,                                        // 是否在代码中打断点

                "cwd": "E:\\mingw64\\bin",                                   //  执行命令的所在目录
                "environment": [],                                           // 环境变量
                "externalConsole": false,                                    // 是否使用外部控制台
                "MIMode": "gdb",                                             // 调试器类型
                "miDebuggerPath": "E:\\mingw64\\bin\\gdb.exe",               // gdb的安装目录
                "setupCommands": [
                  {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                  },
                  {
                    "description": "Set Disassembly Flavor to Intel",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                   }
                ],
                "preLaunchTask": "C/C++: gcc.exe build active file"
              },
	```
	- **验证功能**：报错如下（此为点击RUN AND DEBUG上的运行按钮报错，RUN C/C++ File按钮没有这个问题）
		![1733660671788.png](https://www.helloimg.com/i/2024/12/08/67558e78b62d2.png)
	- **分析错误**：同时在点的时候，需要在cpp文件页面，否则也会报错，因为需要active file是cpp文件
		 ![1733661546637.png](https://www.helloimg.com/i/2024/12/08/675591e2a3053.png)
					图1：该选项按钮只对CPP文件生效
				![1733661591197.png](https://www.helloimg.com/i/2024/12/08/6755920e614f7.png)
						图2：该按钮对C文件生效
	- **问题解决**：不使用图1的编译运行，使用图2的即可



# 四、总结