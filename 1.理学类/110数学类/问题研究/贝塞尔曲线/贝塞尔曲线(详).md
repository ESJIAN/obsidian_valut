[知乎原文](https://zhuanlan.zhihu.com/p/688186803)

## 0.背景

贝塞尔曲线（Bezier Curve）在计算机图形学和相关领域中被广泛使用，主要是因为它能够提供平滑的曲线形状，并且可以通过控制点来精确控制曲线的形态。贝塞尔曲线的优化主要解决了以下几个问题：

1. **平滑性**：贝塞尔曲线能够生成非常平滑的曲线，这对于图形显示和打印质量是非常关键的。
    
2. **控制性**：通过调整控制点的位置，用户可以精确地控制曲线的形状，这对于设计和绘图非常重要。
    
3. **参数化表示**：贝塞尔曲线是参数化的，这意味着可以通过改变参数t（在0到1之间变化）来生成曲线上的不同点，从而绘制出整个曲线。
    
4. **局部控制**：改变一个控制点只会影响曲线的一部分，而不是整体，这使得曲线的局部调整成为可能。
    
5. **计算效率**：虽然贝塞尔曲线的计算相对简单，但是对于高阶的贝塞尔曲线，计算量可能会增大。优化算法可以提高这些计算的效率。
    
6. **存储效率**：贝塞尔曲线可以用较少的数据量来表示复杂的形状，这在存储和传输图形数据时非常有用。
    
7. **曲线的精确表示**：在一些应用中，需要曲线通过特定的点，贝塞尔曲线可以通过调整控制点来确保曲线精确地通过这些点。
    
8. **曲线的逼近和拟合**：在实际应用中，可能需要用曲线去逼近或拟合一组给定的点，贝塞尔曲线提供了一种有效的数学工具来实现这一点。
    
9. **动画和动态效果**：在动画制作中，贝塞尔曲线可以用来创建平滑的过渡和动态效果，优化可以使得这些效果更加流畅和自然。
    
10. **曲线的分割和组合**：贝塞尔曲线可以被分割成多个部分，每部分都是一个低阶的贝塞尔曲线，这使得复杂曲线的构建和管理变得更加容易。
## ﻿1.Bezier曲线

贝塞尔曲线于 1962 年，由法国工程师皮埃尔·贝济埃（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计,贝塞尔曲线最初由保尔·德·卡斯特里奥于1959年运用德卡斯特里奥算法开发，以稳定数值的方法求出贝塞尔曲线.

---

**先从几个简单的例子开始：**

### 1.1 一阶贝塞尔曲线

![](https://pic4.zhimg.com/80/v2-bfe84f33fded3297ed4e2f8f244d11ab_720w.webp)

对于一阶贝塞尔曲线为我们可以看到是一条直线，通过几何知识，很容易根据t的值得出线段上那个点的坐标。

给定点 P0、P1，线性贝塞尔曲线只是一条两点之间的直线。这条线由下式给出：

B(t)=P0+(P1−P0)t=(1−t)P0+tP1,t∈[0,1]

一阶曲线就是很好理解, 就是根据t来的线性插值。P0表示的是一个向量 [x,y], 其中x和y是分别按照这个公式来计算的。

### 1.2 二阶贝塞尔曲线

![](https://pic4.zhimg.com/80/v2-b425084add8a5120c92a93bb44a6564f_720w.webp)

![](https://picx.zhimg.com/80/v2-8b545a1afa7566af1f5d9c4f6feedd25_720w.webp)

在平面内任选 3 个不共线的点，依次用线段连接。在第一条线段上任选一个点 D。计算该点到线段起点的距离AD，与该线段总长AB的比例。

![](https://pic4.zhimg.com/80/v2-f65232326b060b366e240d8805df1857_720w.webp)

根据上一步得到的比例，从第二条线段上找出对应的点 E，使得 AD:AB=BE:BC

![](https://picx.zhimg.com/80/v2-34a323cc1a0c945dd6d989b7597cd3df_720w.webp)

![](https://pic3.zhimg.com/80/v2-3f6b94ae612974c40b9019a1cb5c4268_720w.webp)

  

这时候DE又是一条直线了, 就可以按照一阶的贝塞尔方程来进行线性插值了：

t=AD:AE

这时候就可以推出公式了：

P0=(1−t)P0+tP1 P1=(1−t)P1+tP2

整理一下公式, 得到**二阶贝塞尔公式**：

B(t)=(1−t)2P0+2t(1−t)P1+t2P2,t∈[0,1]

动画效果：

![动图封面](https://pic4.zhimg.com/v2-e40165c7c4d059db8c913daecf337d85_b.jpg)

### 1.3 三阶贝塞尔曲线

![](https://picx.zhimg.com/80/v2-2c8112639edbe85c1c5c75bb59e0179f_720w.webp)

四个点对应是三次的贝塞尔曲线. 分别在 、、AB、BC、CD 之间采EFG点, EFG三个点对应着二阶贝塞尔, 在、EF、FG之间采集、H、I点来降阶为一阶贝塞尔曲线.

公式：

B(t)=P0(1−t)3+3P1t(1−t)2+3P2t2(1−t)+P3t3,t∈[0,1]0

动画效果

![动图](https://picx.zhimg.com/v2-45d35cb4e1b446501fcefac07b3dab55_b.webp)

  

### 1.4 贝塞尔曲线公式

> 贝塞尔曲线是通过空间中的n+1个点P0,P1,P2,…,Pn来定义的，这些点称为控制点。控制点决定了曲线的形状，贝塞尔曲线定义如下：  
> C(u)=∑i=0nBn,i(u)Pi  
> 其中系数定义如下：  
> Bn,i(u)=n!i!(n−i)!ui(1−u)n−i

贝塞尔曲线上对应于参数位置为u的点，是所有控制点的“加权”平均值，其中权重是系数Bn,i(u)，其中u的定义域为[0,1]。函数Bn,i(u),0≤i≤n被称为**贝塞尔基函数**或**伯恩斯坦多项式**。

将控制点点P0P1,P2,…,Pn按此顺序连接，我们得到了一个**控制多边形**，它帮助我们描述了曲线的大致形状。

下图展示了由11个控制点定义的贝塞尔曲线，其中蓝色点是对应于u=0.4的曲线上的点。如图所示，曲线或多或少地跟随着多边形线。

![](https://picx.zhimg.com/80/v2-2db98e884cfe9c911d4d52f63d2898eb_720w.webp)

**问题：当u的定义域非[0,1]时如何处理？**

贝塞尔曲线不总是定义在[0,1]这一标准区间上，有时其定义域可能为[a,b]。在这种情况下，就需要进行变量的转换。我们需要做的是，将u从区间[a,b]映射到[0,1]，然后在基函数中使用转换后的u值。具体的转换方法如下：

u′=u−ab−a

将转换后的u′代入到基函数Bn,i(u)中，可以得到新的公式：

Bn,i(u′)=n!i!(n−i)!(u−ab−a)i(1−u−ab−a)n−i

这一变换后的基函数定义了在区间[a,b]上的贝塞尔曲线

---

## 2. 贝塞尔曲线的特点和性质

### 2.1 基本性质

- **贝塞尔曲线由n+1个控制点定义，曲线的度数是n**： 在每个基函数中，u的指数是i+(n−i)=n。因此，曲线的度数是n  
      
    
- 曲线C(u)通过第一个控制点P0和最后一个控制点Pn  
      
    
- **非负性**：所有基函数都是非负的。  
      
    
- **单位分割**：在任一特定的u值下，这些基函数值的总和为1。这保证了曲线上的任一点都是控制点加权平均的结果，且权重总和为1  
    

![](https://pic4.zhimg.com/80/v2-8684d8d4f6a294dd2736e38f01b8f26b_720w.webp)

![](https://pica.zhimg.com/80/v2-7b5c9765e49928949d1cc8c3410236f2_720w.webp)

在上面的左侧图片中，展示了一个基于五个控制点构成的贝塞尔曲线。而右侧的图则展示了作为u值函数的五个基函数。

这些图表揭示了当u=0.5时，这五个基函数的分布情况。图中最右侧的竖条图清晰地展现了如何将数值1等分为五部分，这就是所谓的**单位分割**。

所有基函数的取值范围从0到1，它们的总和恰好为1，因此，这些基函数在计算加权平均时充当了权重的角色。更简单地说，计算**C**(u)时，实际上是将控制点Pi按照Bn,i(u)的权重进行加权汇总。

  

- **凸包性质**

贝塞尔曲线的一个显著特点是，它完全被其n+1个控制点所形成的凸包所包围。所谓凸包，指的是能够包含一组点集所有点的最小凸形状。

在下面的示例中，11个控制点形成的凸包以灰色表示。值得注意的是，并不是所有控制点都位于凸包的边缘。比如，控制点3、4、5、6、8和9位于凸包内部。除了起点和终点，曲线始终位于这个凸包之内。

![](https://picx.zhimg.com/80/v2-2db98e884cfe9c911d4d52f63d2898eb_720w.webp)

  

- **变差减少性**

在平面上，这个性质意味着没有任何直线能与贝塞尔曲线相交的次数超过它与曲线的控制多边形相交的次数。

![](https://picx.zhimg.com/80/v2-52611b8ec318239621b709093fc559bb_720w.webp)

如上图所示，黄色直线与曲线相交3次，但与控制多边形相交了7次； 红色直线与曲线相交5次，与控制多边形也相交7次； 而青色直线与曲线及其控制多边形都只相交两次。 你可以尝试绘制其他直线以验证这一性质。

若曲线是空间中的曲线，则只需将“直线”改为“平面”。

这一性质的意义何在？它告诉我们，与控制多边形相比，贝塞尔曲线的复杂性（即转弯和扭曲的程度）会更低。换言之，控制多边形相较于它所定义的贝塞尔曲线，会有更频繁的转弯和扭曲，因为任意直线与控制多边形相交的次数总是多于与曲线相交的次数。

  

- **仿射不变性**

对贝塞尔曲线进行仿射变换时，其变换结果能够通过控制点经过相同变换后的新位置来确定。这一特性极为有利。当我们需要对贝塞尔曲线执行几何或仿射变换操作时，直接对控制点施加变换即可。完成控制点的变换后，由这些调整后的控制点所定义的新贝塞尔曲线即为所求。因此，无需直接对曲线本身进行变换处理。

  

- **递归性**

递归性指其系数满足下式：

【】Bi,n(t)=(1−t)Bi,n−1(t)+tBi−1,n−1(t)【i=0,1,⋯,n】

- **一阶导数性质**

![](https://pic1.zhimg.com/80/v2-f520eabc742e12635d84bb5c70a4878c_720w.webp)

  

假设上图中贝塞尔的 t 是由左到右从 0 到 1 增加的，那么贝塞尔曲线在 t=0 时的导数是和 P0P1的斜率（导数）是相同，t=1 时的导数是和P3P4 的斜率（导数）是相同的

![](https://pic2.zhimg.com/80/v2-318e0b50b009e18054f22424df0539f5_720w.webp)

这一点的性质可以用在贝塞尔曲线的拼接，只要保证三点一线中的中间点是两段贝塞尔曲线的连接点，就可以保证两端贝塞尔曲线的导数连续。

  

### 2.2 控制点的移动对曲线的影响

当我们调整一个贝塞尔曲线的控制点位置时，曲线形状将发生变化。这引出一个问题：  
  
**控制点移动到新的位置时，贝塞尔曲线将如何变形？**

假设控制点 Pk 移动到 Pk+v 的新位置，向量 v 表示移动的方向和距离。如图所示：

![](https://picx.zhimg.com/80/v2-f95b6411c13da31230eebf2159b16d3f_720w.webp)

  

原始贝塞尔曲线表示为： C(u)=∑i=0nBn,i(u)Pi

由于新的贝塞尔曲线是由 P0,P1,...,Pk+v,...,Pn定义的，新的贝塞尔曲线方程 D(u) 可以写成：

D(u)=∑i=0k−1Bn,i(u)Pi+Bn,k(u)(Pk+v)+∑i=k+1nBn,i(u)Pi=∑i=0nBn,i(u)Pi+Bn,k(u)v=C(u)+Bn,k(u)v

在上式中，因为只有第 k 项控制点使用了 Pk+v，所以我们得出新曲线是原始曲线与额外的项 Bn,k(u)v 的组合。

因此，新曲线上任一给定 u 对应的点，可以通过将原始曲线上相同位置的点沿向量 v 的方向平移 |Bn,k(u)v| 的距离来获得。

更具体地来说，对于任意给定的 _u_ 值，原曲线上对应的点为 C(u)，新曲线上对应的点为 D(u)，且 D(u)=C(u)+Bn,k(u)v。

以下图说明这一变化：

![](https://pic1.zhimg.com/80/v2-4a74ee2fd88c747580487feb9da91476_720w.webp)

  

图中，黑色与红色曲线分别代表由9个控制点定义的同一8次贝塞尔曲线的原始和变形状态。黑色曲线为原始状态。若其中一个控制点沿蓝色向量移动到新位置，黑色曲线便转变为红色曲线。

图中同时标出了u=0.5时两条曲线上的对应点。可以明显看出，C(0.5) 沿相同方向移动至 D(0.5)。从 C(0.5) 到 D(0.5) 的距离等同于向量

​ B8,3(0.5)v=8!(3!(8−3)!)×0.53(1−0.5)8−3v=0.22v

因此，**该距离约为原始控制点3和下图所示的新控制点3之间距离的22%**

从这一分析中，我们可以得出另一个重要的结论：

> 因为 Bn,k(u) 在开区间 (0,1) 内非零，因此 Bn,k(u)v 在此区间内不是零向量。这意味着除了端点 C(0) 和 C(1) 外，所有原始曲线上的点都会被移动到新的位置上。由此可见：  
> ​**移动控制点将会全面改变贝塞尔曲线的形状。**

---

## 3. 计算贝塞尔曲线上一点：De Casteljau 算法

**在构造 éBézier 曲线后，如何找到曲线上参数为 u 处的点 C(u)？**

一种简单的方法是将 u 代入贝塞尔曲线的公式：

C(u)=∑i=0nBn,i(u)Pi

其中系数定义如下：

Bn,i(u)=n!i!(n−i)!ui(1−u)n−i

计算每个基函数的值，并计算每个基函数及其对应控制点的乘积，最后将它们相加。虽然这样可以，但不是**数值稳定**的（即在计算伯恩斯坦多项式的过程中可能引入数值误差）。

还记得本文开始几个小节关于一阶、二阶、三阶贝塞尔曲线的推导过程吗，这就是**De Casteljau 算法**：

首先，我们以编号的形式记录下控制点，如 P0 记作 00，P1 记作 01，依此类推，直至 Pn 的编号为 0n。第一个数字 0 表示第0阶或第一次迭代。在接下来的迭代中，这些数字会变成、、1、2、3 等。

> **De Casteljau 算法的核心在于找到线段 AB 上某个点 C，该点按 u:1−u 的比例将线段 AB 划分。从而确立点 C 的具体位置。**

![](https://pic2.zhimg.com/80/v2-55ef5683609f75322c0738a8095faf45_720w.webp)

线段AB 的向量可以表示为 B−A。由于 u 是介于 0 和1 之间的比例，所以点 C 的位置可以用 u(B−A) 来描述。再加上 A 点的坐标，我们可以得到 C 的准确位置为

A+u(B−A)=(1−u)A+uB

因此，对于任何给定的 u 值， 我们都能准确地定位在 A 与 B 之间的一点 C。

  

**如何找到贝塞尔曲线上任意一处参数 u 的点 C(u)：**

首先将控制点依次连接，得到一个折线：即 00−01−02−03...−0n 多段线，然后根据上述公式在每对相邻控制点之间找到新点 1i，这个新点将原线段 0i−0(i+1) 按 u:1−u 的比例分割。通过这种方式，我们可以得到 n 个新点：10,11,12,...,1(n−1)，它们共同构成了一条新的折线。

![](https://pic2.zhimg.com/80/v2-0aad75976c9281bdba3fd60f93d4e865_720w.webp)

如上图所示，例如，当 u=0.4 时，通过插值可以得到点10位于起始控制点00和01之间， 其中00−1010−01=u1−u 。(00即点0，00中的第一个0表示0阶，第二个0表示第0个点。01即点1，01中的第一个0表示0阶，第二个1表示第1个点）

第二次迭代：点11位于点01和02之间，01−1111−02=u1−u以此类推，可以计算出点、、12、13、14。这些新产生的点都以蓝色标记。

每一次迭代，我们获得的"新控制点"的数量都比之前迭代的结果少1，直到最减少到唯一的点n0。这一点就是在给定 u 值下，贝塞尔曲线上的对应点 C(u)。

举例：在上图中， 点20可以通过以 u:1−u 的比例划分线段10−11得到，。 点21通过边11−12划分得到 点22通过边12−13划分得到 点23通过边13−14划分得到。 从而得到了由点20,21,22,23定义的三阶折线。 在折线段20−21−22−23的两两点之间进行插值，将得到个新的折线段30−31−32。继续迭代，将得到点40和41， 组成新的折线段40−41。 继续迭代，将得到点50，这就是曲线上的点 C(0.4)。

**用一张图表示De Casteljau 算法的迭代过程：**

![](https://pic1.zhimg.com/80/v2-69c43934c78bdd5922803a8d744a3632_720w.webp)

从初始列，即第 0 列，我们通过两两点之间的插值可以计算出第1列的"新点"，从第1列我们得到第2列，依此类推。最终，在应用了 n 次之后，我们将得到唯一的点 n0，这就是贝塞尔曲线上的点C(u)。

  

### **3.1 递归关系：自顶向下的计算方法**

上述计算可以递归地表达。初始时，令 P0,j 为 Pj，其中 j=0,1,...,n。P0,j 表示第 0 列的第 j 项。那么第 i 列的第 j 项的计算如下：

Pi,j=(1−u)Pi−1,j+uPi−1,j+1{i=1,2,…,nj=0,1,…,n−i

基于这个公式，可能会立即想到以下递归算法：

```cpp
function deCasteljau(i,j)
if i = 0 then
   return P（0,j）
else
   return (1-u) * deCasteljau(i-1,j)+  u * deCasteljau(i-1,j+1)
```

这个算法看起来简单，但是它极其低效。原因如下。我们从调用 deCasteljau(n,0) 开始，计算 Pn,0。else 分支将这个调用会递归产生两个新的调用，即deCasteljau(n−1,0) 用于计算 Pn−1,0 和 deCasteljau(n−1,1) 用于计算 Pn−1,1。

![](https://pic3.zhimg.com/80/v2-fc7b084f4dbb2342ad999f29b9cf891e_720w.webp)

对 deCasteljau(n−1,0) 的调用。又会产生两个新的调用，deCasteljau(n−2,0) 用于计算 Pn−2,0 和 deCasteljau(n−2,1) 用于计算 Pn−2,1。对 deCasteljau(n−1,1) 的调用也会产生两个新的调用，deCasteljau(n−2,1) 用于计算 Pn−2,1 和 deCasteljau(n−2,2) 用于计算 Pn−2,2。

因此，deCasteljau(n−2,1) 被调用了两次。依次类推，会发现计算 Pi,j 的函数被重复调用了，这是对性能非常浪费的。

### **3.2 三角形计算方案：自底向上的计算方法**

以下面在由 8 个控制点 00,01,...,07定义的 7 次贝塞尔曲线为例。给定一个在 [0,1] 中的 u，我们如何计算这个贝塞尔曲线上对应的点呢？曲线上的点是由选定点形成的等边三角形的底边对面的顶点！

![](https://pica.zhimg.com/80/v2-7ae1c55099c8ff90b586a7c1868dcdce_720w.webp)

  

例如，如果选定的控制点点是 02, 03, 04 和 05，那么对应于 u 的这四个控制点定义的曲线上的点是 32。即蓝色的三角形的顶点。如果选定的控制点是 11, 12 和 13，则曲线上的点是 31。即黄色的三角形的顶点。如果选定的点是 30, 31, 32, 33 和 34，曲线上的点是 70。

反之同理，70 是由控制点 60 和 61 定义的贝塞尔曲线上的点。它也可以是由 50, 51 和 52 控制点定义的曲线上的点，也可以是由 40, 41, 42 和 43 控制点定义的曲线上的点。

如此我们就可以自底向上的计算每一项Pi,j，以蓝色三角形为例，先计算最左列的P0,2,P0,3,P0,4,P0,5，再计算第二列的P1,2,P1,3,P1,4,P0,5，再计算第三列的P2,2,P2,3，再计算最终点P3,2，这样可以避免自定向下计算带来的重复项计算的问题。

---

## 4. 贝塞尔曲线的导数

### **4.1 贝塞尔曲线的导数仍然是贝塞尔曲线**

要在贝塞尔曲线上的某点计算切向量和法向量，首先要计算在该点的一阶和二阶导数。

由 n+1 个控制点 P0,P1,...,Pn 定义的贝塞尔曲线如下：

C(u)=∑i=0nBn,i(u)Pi

其中 Bn,i(u) 定义如下：

Bn,i(u)=n!i!(n−i)!ui(1−u)n−i

其中控制点Pi是常数且与变量 u 相互独立，因此，计算贝塞尔曲线的导数 C′(u)可以简化为计算 Bn,i(u) 的导数。

通过一些代数操作，我们可以得到：

dduBn,i(u)=Bn,i′(u)=n(Bn−1,i−1(u)−Bn−1,i(u))

因此曲线的导数 C′(u)为：

dduC(u)=C′(u)=∑i=0n−1Bn−1,i(u){n(Pi+1−Pi)}

设 :

Q0=n(P1−P0) Q1=n(P2−P1) Q2=n(P3−P2) Qn−1=n(Pn−Pn−1)

上述方程简化为以下形式：

C′(u)=∑i=0n−1Bn−1,i(u)Qi

  

> **结论：可以看出贝塞尔曲线 的导数C′(u)是由 n 个控制点 n(P1−P0), n(P2−P1), n(P3−P2), ..., n(Pn−Pn−1) 定义的 n−1 次贝塞尔曲线。**

这个导数曲线通常被称为原贝塞尔曲线的**轨迹图**。

注意，Pi+1−Pi 是从 Pi 到 Pi+1 的方向向量，而 n(Pi+1−Pi) 是该方向向量的 n 倍长。下面左图显示了一个7次贝塞尔曲线，右图显示了其导数，是一个6次贝塞尔曲线。

![](https://pic3.zhimg.com/80/v2-69295d891e551c7eace1f33c2951ce86_720w.webp)

![](https://pic1.zhimg.com/80/v2-80be549e8551d2336d47e2950a384a74_720w.webp)

### **4.2 贝塞尔曲线与其第一条和最后一条边相切**

令u=0和u=1，可以得到：

​ C′(0)=n(P1−P0) C′(1)=n(Pn−Pn−1)

第一个公式意味着在u=0时的切向量方向是P1−P0乘以n。因此，指示方向的第一条边与贝塞尔曲线相切。 第二个公式意味着在u=1时的切向量方向是Pn−Pn−1乘以n。因此，指示方向的最后一条边与贝塞尔曲线相切。下图很好地展示了这个属性。

![](https://picx.zhimg.com/80/v2-2db98e884cfe9c911d4d52f63d2898eb_720w.webp)

![](https://picx.zhimg.com/80/v2-9cfb2251fef15a0ae379d4182172f501_720w.webp)

### **4.3 用C1连续性连接两个贝塞尔曲线**

不清楚 C1 连续的可以看我之前一篇文章

[举个栗子：参数连续性和几何连续性4 赞同 · 0 评论文章![](https://pic4.zhimg.com/v2-b84df7825ab21969aa998f5dda6721b9_180x120.jpg)](https://zhuanlan.zhihu.com/p/682706735)

利用贝塞尔曲线与其第一条和最后一条边相切的这个特性，可以将两条或更多的贝塞尔曲线连接起来，组合成我们想要的形状。

设第一条曲线C(u)由m+1个控制点P0,P1,P2,...,Pm定义， 设第二条曲线D(u)由n+1个控制点Q0,Q1,Q2,...,Qn定义， 如果我们想要将这两条贝塞尔曲线连接起来，那么Pm必须等于Q0，这保证了C0级连续

第一条曲线与其最后一条边相切，第二条曲线与其第一条边相切。因此，为了实现平滑过渡，Pm−1，Pm=Q0和Q1四个点必须在同一直线上，使得从Pm−1到Pm的方向与从Q0到Q1的方向相同，如下图所示：

![](https://pic3.zhimg.com/80/v2-fa497b22d17168064472c718a484e170_720w.webp)

以这种方式连接两个贝塞尔曲线看起来很平滑，但它仍然是C0连续，而不是C1连续。但是，它满足G1连续（具有相同的切向量方向，但切向量大小不相等）。 为了保证C1连续性，我们必须确保第一条曲线在u=1处的切向量C′(1)，与第二条曲线在u=0处的切向量D′(0)，是等的。也就是说，必须满足以下关系：

C′(1)=m(Pm−Pm−1)=D′(0)=n(Q1−Q0)

这个关系说明要在连接点保证C1连续性，第一条曲线的最后一条边的长度（即|pm−pm−1|）与第二条曲线的第一条边的长度（即|q1−q0|）的比例必须是n/m。由于度数m和n是固定的，我们可以调整pm−1或q1在同一直线上的位置，使得上述关系得到满足。

![](https://picx.zhimg.com/80/v2-9f043a74ca90c8c96f504b2d122d0f19_720w.webp)

![](https://pic2.zhimg.com/80/v2-e5181af9de78d97759958a534ea7aeff_720w.webp)

上面左图中为两条贝塞尔曲线连接而成，其中**浅色的折线**定义了一条4次贝塞尔曲线，而**深色的折线**定义了一条5次贝塞尔曲线。 由于第一条曲线的最后一段和第二条曲线的第一段不在同一直线上，所以这两条曲线并未平滑相接。

上面右图展示了在连接点处与一条直线相切的两条贝塞尔曲线。然而，它们并不是C1连续的。左边的曲线是4次的，而右边的曲线是7次的。

但是，左曲线的最后一段与第二条曲线的第一段的比例看起来接近1，它们是G1连续的而不是C1连续的。为了实现C1连续性，我们应该增加左曲线的最后段的长度（或者减少右曲线的第一段的长度），使其比例接近7/4=1.75，从而满足C1连续

  

### 4.4 构造闭合的贝塞尔曲线

利用上面的这种切线性质，如果让第一个和最后一个控制点相同（即P0=Pn）并且P1,P0和Pn−1共线，那么生成的贝塞尔曲线将是一个封闭曲线，并且在连接点处是G1连续的。

如果要在P0处达到C1连续性，必须使 P1−P0=Pn−Pn−1（即曲线的第一段和最后一段有相同的长度并且P1,P0=Pn,Pn−1共线）

![](https://picx.zhimg.com/80/v2-6b11e35be63d6cd3f63205e2888100d9_720w.webp)

  

### **4.5 导数与de Casteljau算法之间的关系**

重新改写一下贝塞尔曲线的导数形式：

C′(u)=∑i=0n−1Bn−1,i(u){n(Pi+1−Pi)}=n[(∑i=0n−1Bn,i(u)Pi+1)−(∑i=0n−1Bn,i(u)Pi)]

贝塞尔曲线的导数可以看作是两条n−1次贝塞尔曲线的差 现在让这两条曲线分别为C1(u)和C2(u)：

C1(u)=∑i=0n−1Bn,i(u)Pi+1C2(u)=∑i=0n−1Bn,i(u)Pi

根据上面定义，可以知道第一条曲线C1(u)由控制点P1,P2,...,Pn定义，第二条曲线C2(u)由控制点P0,P1,...,Pn−1定义，因此，原曲线的导数定义为：

C′(u)=n(C1(u)−C2(u))

为了计算贝塞尔曲线的导数C′(u)，可以先使用de Casteljau算法计算C1(u)和C2(u)的值，然后，再计算它们的差，乘以n就得到了C′(u)。

**计算C1(u)和C2(u)：**

如下图，最左侧的列有所有给定的控制点，点n0代表原始贝塞尔曲线上的点C(u)，点(n−1)0和(n−1)1连成的线段是用来插值获取点n0的控制折线，即点n0位于(n−1)0和(n−1)1的线段上，并以u:1−u的比例将其分割。

![](https://pic3.zhimg.com/80/v2-f831db107e272877f58bf28d3ccf507e_720w.webp)

  

由于曲线C1(u)由控制点01,02,...,0n定义，因此点(n−1)1是曲线C1(u)上的点。同样地，由于C2(u)由控制点00,01,...,0(n−1)定义，因此点(n−1)0是曲线C2(u)上的点，向量C1(u)−C2(u)表示从点(n−1)0到点(n−1)1的向量，而原贝塞尔曲线的导数C′(u)的是n倍的C1(u)−C2(u)。

这说明，从(n−1)0到(n−1)1的线段与C(u)处的切线向量方向相同，它在C(u)处与曲线相切！

**结论：de Casteljau算法迭代中的最后一条折线，实际上是一条线段，在C(u)处与贝塞尔曲线相切。**

下图是一个例子，所示的点为u=0.5处。显然，de Casteljau迭代过程中的最后一条折线段在C(0.5)处与曲线相切。

![](https://pic4.zhimg.com/80/v2-2a41cb6e155f4c3b5aa98e2dcc4d440f_720w.webp)

  

### **4.6 计算贝塞尔的高阶导数**

C(u)的一阶导数如下：

C′(u)=∑i=0n−1Bn−1,i(u)Qi

将导数公式应用于上述贝塞尔曲线，得到以下结果，给出了原始贝塞尔曲线的二阶导数：

C′′=∑i=0n−2Bn−2,i(u){(n−1)(Qi+1−Qi)}=∑i=0n−2Bn−2,i(u){n(n−1)(Pi+2−2Pi+1+Pi)}

为了简洁地表达高阶导数，可以使用有限差分的方式。定义Di0为控制点Pi本身，其中0≤i≤n。定义第一层差分Di1为前一层的差分，如下：

D01= D10−D00=P1−P0D11= D20−D10=P2−P1...Dn−21 = Dn−10−Dn−20=Pn−1−Pn−2 Dn−11 = Dn0−Dn−10=Pn−Pn−1 

第一层差分只有n个点，比给定的控制点少一个，简写一下，第一层的差分如下所示：

Di1=Di+10−Di00≤i≤n−1

第二层差分被定义为第一层点的差分：

Di2=Di+11−Di10≤i≤n−2

这个第二层差分有n−1个点。重复这个过程，我们可以定义第k层差分如下。第k层差分有n−k+1个点。

Dik=Di+1k−1−Dik−10≤i≤n−k

有了这些定义，可以简洁地表达更高阶的导数。首先，让我们使用Di1重新写下C′(u)：

C′(u)=n∑i=0n−1Bn−1,i(u)(Pi+1−Pi)=n∑i=0n−1Bn−1,i(u)(Di+10−Di0)=n∑i=0n−1Bn−1,i(u)Di1

将导数应用于C′(u)来计算C″(u)，得到了一个使用Di2表示C″(u)的公式：

C″(u)=n(n−1)∑i=0n−2Bn−2,i(u)(Di+11−Di1)=n(n−1)∑i=0n−2Bn−2,i(u)Di2

对C″(u)做同样的处理，我们得到了一个使用Di3表示C‴(u)的公式：

C′′′(u)=n(n−1)(n−2)∑i=0n−3Bn−3,i(u)(Di+12−Di2)=n(n−1)(n−2)∑i=0n−3Bn−3,i(u)Di3

继续这个过程，我们可以计算出第k阶导数C(k)(u)使用Dik的表示形式：

C[k](u)=n(n−1)(n−2)⋯(n−k+1)∑i=0n−kBn−k,i(u)(Di+1k−1−Dik−1)=n(n−1)(n−2)⋯(n−k+1)∑i=0n−kBn−k,i(u)Dik

因此，要在特定的u处计算C(u)的第k阶导数，我们首先计算Dik的值，然后应用de Casteljau算法计算由Dik定义的贝塞尔曲线上对应于u的点。

如下图所示，我们已有第0列所有Di0的值（即控制点本身），然后使用两两差分来计算第1列的Di1的值。重复这个过程直到我们达到如下所示的第k列：

![](https://pic4.zhimg.com/80/v2-ad0c757813fa2cfe7b1b6a42bf78270d_720w.webp)

  

最后，使用de Casteljau算法计算出第k列点的Bn−k,i(u)的值，与Dik相乘后累加，再将结果乘以n(n−1)(n−2)...(n−k+1)，就得到了C(k)(u)的值！

## 5. 贝塞尔曲线的拆分

**曲线拆分**的过程是将一个贝塞尔曲线在特定点C(u)处一分为二，每一部分仍然是贝塞尔曲线。分割后的每段曲线都需要一套新的控制点来描述其形状，原有的控制点将不再适用。此外，由于原始贝塞尔曲线的阶次是n，被切割成两部分后，每个部分都是原贝塞尔曲线的子集，因此得到的新贝塞尔曲线的阶次也必须是n。

假设我们n+1个控制点P0,P1,P2,...,Pn，参数 0≤u≤1，目标是找到两组新的n+1个控制点Q0,Q1,Q2,...,Qn和R0,R1,R2,...,Rn。

这两组控制点各自定义的贝塞尔曲线分别对应原始曲线在[0,u]和[u,1]区间的部分。

虽然正确性证明有点繁琐，但实际上算法非常简单。事实上，deCasteljau 的算法用于计算曲线上点 C(u) 时已经提供了所有必要的信息。在下面的左图中，展示了用 deCasteljau 算法计算 C(u) 的所有中间步骤，右图显示了在点 C(u) 处曲线拆分后的形状及相应的控制折线。

![](https://pic4.zhimg.com/80/v2-fa2df8873d09393131b31fe4fef907cb_720w.webp)

![](https://pic3.zhimg.com/80/v2-e79d3378dff8efbc2a8f3066ecdd7d4a_720w.webp)

仔细比较这两幅图，左图中，**左半段**贝塞尔曲线的控制点由P00=P0,P10,P20,P30,P40,P50和P60=C(u)组成 **右半段**贝塞尔曲线的控制点由点P60=C(u),P51,P42,P33,P24,P15和P06=P6组成。 下图展示了这些点：

![](https://pic4.zhimg.com/80/v2-2de2a1c91cad9596616b4be9afd949bf_720w.webp)

![](https://pic3.zhimg.com/80/v2-0f6e2916c6befd3b6a3601598e81520c_720w.webp)

回想一下deCasteljau算法的三角形计算方案：对于给定的u，计算C(u)需要n次迭代，在计算过程中，可以收集每列的第一个点和最后一个点，并且最终，第一个点（或最后一个点）的集合对应于原始曲线在[0,u]（或[u,1]）上定义的片段。

因此，在下面的三角形方案中，箭头指向的顶边(红色：00,10,20,30,40,50,60)和箭头相反方向的底边(蓝色：60,51,42,33,24,15,06)分别对应位第一段曲线和第二段曲线段的控制点。有了控制点，也就可以得出拆分后的两段贝塞尔曲线（可以重新计算获得）

![](https://pic4.zhimg.com/80/v2-2cd2511dc399409ece0c83a6cfefa773_720w.webp)

  

注意：点50和51定义的线段在点60处与曲线相切（见上图），即左曲线的最后一段（即线段50−60）与左曲线相切，右曲线的第一段（即线段60−51）与右曲线相切。

**曲线拆分为何至关重要？** 曲线拆分的应用范围广泛。例如，它可以被用来找出两个贝塞尔曲线的交汇点、对贝塞尔曲线进行渲染，以及简化曲线设计过程。设想我们设计了一条曲线，却发现它并不完全符合我们的预期。在这种情形下，我们可能会考虑在某些特定的点上将曲线分割为两个部分：一个部分达到了我们的满意度，而另一部分则没有。接下来，我们可以忽略掉那部分我们已经满意的，将注意力集中在仍需改进的部分上。

## 6. 贝塞尔曲线的升阶

不改变贝塞尔曲线的形状，同时增加贝塞尔曲线的度数（即阶数/次数），称为**贝塞尔曲线的升阶**。

假设我们有一个由 n+1个控制点P0,P1,P2,...,Pn定义的n阶贝塞尔曲线，我们希望将这个曲线的度数提升到n+1而不改变其形状。由于n+1阶贝塞尔曲线需要由n+2个控制点定义，因此，我们需要找到一个新的控制点集，显然，P0 和 Pn 必须在新控制点集中，因为贝塞尔曲线会通过首尾控制点，曲线升阶不改变曲线的形状。因此，我们需要n个新的控制点，假设新的控制点集为 Q0,Q1,Q2,...,Qn+1，根据上述要求有，Q0=P0 和 Qn+1=Pn。其他控制点的计算方式如下：

Qi=in+1Pi−1+(1−in+1)Pi1≤i≤n

以下是从Q1到Qn每个控制点的公式：

Q1=1n+1P0+(1−1n+1)P1Q2=2n+1P1+(1−2n+1)P2Q3=3n+1P2+(1−3n+1)P3⋮Qn−1=n−1n+1Pn−2+(1−n−1n+1)Pn−1Qn=nn+1Pn−1+(1−nn+1)Pn

原始多段线的每一段上正好会有一个新的控制点。即：线段Pi−1Pi 包含新控制点Qi。

在deCasteljau算法中，线段AB上一点C，将AB按比例 u:1−u 分割，可以写作 C=(1−u)A+uB。在上式中，Qi将线段Pi−1Pi 按比例 1−in+1:in+1 分割。这个比例不是一个常数，而是随着 i 的值变化的，但与deCasteljau算法很相似

获得了新的控制点集后，原控制点集就可以弃用。由于原始控制多段线的每一段都包含一个新控制点，用新控制点集合替换旧控制点集合的过程可以看作是在原始控制点处切掉角。

见下图，图中显示了一个4度贝塞尔曲线，控制点以红色矩形显示，控制多段线以虚线显示。将其度数增加到5后，新的控制多段线以实线段显示。显然，所有角都被切掉了。下表给出了原始控制多段线上每一段的比例。

|i|1 - i/(n+1)|i/(n+1)|
|---|---|---|
|1|0.8|0.2|
|2|0.6|0.4|
|3|0.4|0.6|
|4|0.2|0.8|

![](https://pica.zhimg.com/80/v2-9b82c41093646cbad1aafb5a208611c8_720w.webp)

  

随着曲线度数的增加，控制点的数量也会增加。并且，新的控制多边形会逐渐向曲线靠拢。在下面的图形中，我们从一个度数为6、控制点为7个的贝塞尔曲线开始，然后，其度数增加到7、8、10、15和29。从图中可以看出，随着度数的增加，曲线的形状没有改变，控制多边形越来越接近曲线。最终，随着度数不断增加到无限，控制多边形将趋向于曲线，曲线则相当于控制多边形的一个极限位置。

![](https://pic3.zhimg.com/80/v2-a9d86b65c9a0a14d8ca82ae374077f30_720w.webp)

![](https://pic3.zhimg.com/80/v2-f5465f571cec3a300511b9ab9a5317fc_720w.webp)

![](https://pic4.zhimg.com/80/v2-d95c617e2506abc3ff29ccba01165a51_720w.webp)

![](https://pic4.zhimg.com/80/v2-18a66af1f9f8cb7ec166ff0bc838f9e5_720w.webp)

![](https://pic1.zhimg.com/80/v2-ca4e606e47d495be3dcf4fb0bd716752_720w.webp)

![](https://pic4.zhimg.com/80/v2-07c7b589f0c420e93d957d1394ab4159_720w.webp)

## 7.总结

总的来说，要定义一个n阶的贝塞尔曲线，我们需要在空间中选择n+1个控制点，这些点大致描述了所需曲线的形状。

然后，如果它不符合我们的期望，我们可以移动控制点。随着一个或多个控制点的移动，贝塞尔曲线的形状相应地发生变化。但是，曲线始终位于由控制点定义的凸包内（**凸包性质**），并且生成的曲线形状比控制多边形简单（**变差减少性质**）。

除此之外，贝塞尔曲线还具有**非负性**、**单位分割**、**仿射不变性**、**递归性**等性质。贝塞尔曲线不具备**局部修改性**，移动控制点将会全面改变贝塞尔曲线的形状，这也是其逐渐被**样条曲线**和**Nurbs曲线**取代的原因。

**De Casteljau算法**用于计算任意参数位置时，对应的贝塞尔曲线上一点，这是一种**自底向上**的**三角形计算方案**，能够避免**自顶向下**计算方案递归调用时带来的不必要的性能开销。

还了**贝塞尔曲线导数**的性质应用广泛，例如，如何将两个**贝塞尔曲线连接_在一起并保证连接点处C1连续，如何构造_*闭合的贝塞尔曲线以及计算**高阶贝塞尔导数**。

最后还介绍了贝塞尔曲线的**拆分**和**升阶**方法，这个早期在工程中也是具有很大的应用。
### 7.1优点

### 7.2缺点

尽管贝塞尔曲线在许多场合下都有广泛应用，但也存在一些不适用的情况。以下是一些例子：

1. 高度精确的曲线：贝塞尔曲线是由有限个控制点所定义的，当需要绘制极其精确的曲线时，可能无法满足需求；
2. 曲率变化较大的曲线：贝塞尔曲线的控制点数量决定了曲线的平滑程度。在曲率变化较大的情况下，可能需要增加更多的控制点来准确描述曲线的形状；
3. 特殊曲线类型：某些特殊曲线类型，如圆或椭圆等，可能有更适合的数学表示方法，而不是使用贝塞尔曲线。
## 8.代码实现
### 8.1Matlab求解曲线
## 文献引用

- Gerald Farin, _Curves and Surfaces for CAGD: A Practical Guide_, fourth edition, Academic Press, 1997.
- Josef Hoschek and Dieter Lasser, _Fundamentals of Computer Aided Geometric Design_, translated from the German 1989 edition by Larry L. Schumaker, A K Peters, 1993.
- Les Piegl and Wayne Tiller, _The NURBS Book_, second edition, Springer-Verlag, 1997.
- David F. Rogers and J. Alan Adams, _Mathematical Elements for Computer Graphics_, second edition, McGraw-Hill, 1990.